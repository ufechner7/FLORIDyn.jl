<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exported Functions · FLORIDyn.jl</title><meta name="title" content="Exported Functions · FLORIDyn.jl"/><meta property="og:title" content="Exported Functions · FLORIDyn.jl"/><meta property="twitter:title" content="Exported Functions · FLORIDyn.jl"/><meta name="description" content="Documentation for FLORIDyn.jl."/><meta property="og:description" content="Documentation for FLORIDyn.jl."/><meta property="twitter:description" content="Documentation for FLORIDyn.jl."/><meta property="og:url" content="https://ufechner7.github.io/FLORIDyn.jl/functions/"/><meta property="twitter:url" content="https://ufechner7.github.io/FLORIDyn.jl/functions/"/><link rel="canonical" href="https://ufechner7.github.io/FLORIDyn.jl/functions/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FLORIDyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLORIDyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">Exported Types</a></li><li class="is-active"><a class="tocitem" href>Exported Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Calculating-the-wind-directions"><span>Calculating the wind directions</span></a></li><li class="toplevel"><a class="tocitem" href="#Calculating-the-wind-velocity"><span>Calculating the wind velocity</span></a></li><li class="toplevel"><a class="tocitem" href="#Calculating-the-wind-shear"><span>Calculating the wind shear</span></a></li><li class="toplevel"><a class="tocitem" href="#Calculating-the-wind-turbulence"><span>Calculating the wind turbulence</span></a></li><li class="toplevel"><a class="tocitem" href="#Controller-functions"><span>Controller functions</span></a></li><li class="toplevel"><a class="tocitem" href="#FLORIS"><span>FLORIS</span></a></li><li class="toplevel"><a class="tocitem" href="#FLORIDyn"><span>FLORIDyn</span></a></li></ul></li><li><a class="tocitem" href="../settings/">Settings</a></li><li><a class="tocitem" href="../developer/">Developer notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Exported Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exported Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl/blob/main/docs/src/functions.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h1><h1 id="Calculating-the-wind-directions"><a class="docs-heading-anchor" href="#Calculating-the-wind-directions">Calculating the wind directions</a><a id="Calculating-the-wind-directions-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-wind-directions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getWindDirT" href="#FLORIDyn.getWindDirT"><code>FLORIDyn.getWindDirT</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_Constant, wind_dir, iT, _)</code></pre><p>Return wind direction in SOWFA-degrees for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir</code>: The wind direction (scalar).</li><li><code>iT</code>: Index or indices of the turbines (can be an integer or vector).</li><li><code>_</code>: Placeholder for unused argument.</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Array of wind direction values, same size as <code>iT</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L9-L21">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_Constant_wErrorCov, wind_dir::WindDirType, iT, t)</code></pre><p>Return wind direction in SOWFA-deg for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir::WindDirType</code>: <a href="../types/#FLORIDyn.WindDirType">WindDirType</a></li><li><code>iT</code>: Vector of turbine indices (can be any indexable collection)</li><li><code>t</code>: Time step</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Vector of wind directions for the selected turbines, including random perturbation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L30-L42">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_Interpolation, wind_dir::AbstractMatrix, iT, t)</code></pre><p><strong>Direction_Interpolation</strong></p><p>Returns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.</p><p>Arguments:</p><ul><li>wind_dir::Matrix: columns are time and phi (wind direction)</li><li>iT: single value or vector with turbine index/indices</li><li>t: time of request</li></ul><p>Returns:</p><ul><li>phi: Vector of wind directions for each turbine in iT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L122-L137">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_Interpolation_wErrorCov, wind_dir::WindDirMatrix, iT, t)</code></pre><p>Returns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.</p><p>Arguments:</p><ul><li>wind_dir::WindDirMatrix: <a href="../types/#FLORIDyn.WindDirMatrix">WindDirMatrix</a></li><li>iT: single value or vector with turbine index/indices</li><li>t: time of request</li></ul><p>Returns:</p><ul><li>phi: Vector of wind directions for each turbine in iT</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L159-L172">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_InterpTurbine, wind_dir::AbstractMatrix iT, t)</code></pre><p>Return wind direction in SOWFA-degrees for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir::Matrix</code>: Each row is <code>[time, phi_T0, phi_T1, ...]</code>.</li><li>`iT: Index or indices of turbines.</li><li><code>t</code>: Time of request.</li></ul><p><strong>Returns</strong></p><ul><li><code>phi::Vector{Float64}</code>: Wind direction(s) for the selected turbine(s) at time <code>t</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L214-L226">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_InterpTurbine_wErrorCov, wind_dir::WindDirMatrix, iT, t)</code></pre><p>Return wind direction in SOWFA-deg for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir::WindDirMatrix</code>: See: <a href="../types/#FLORIDyn.WindDirMatrix"><code>WindDirMatrix</code></a></li><li><code>iT</code>: Index or indices of the turbines (can be integer or vector)</li><li><code>t</code>: Time of request (Float64)</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Wind direction(s) for requested turbine(s), perturbed with noise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L253-L265">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_RW_with_Mean, wind_dir_now, wind_dir::WindDirTriple)</code></pre><p>Returns the wind direction at the respective turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir_now</code>: Current value (vector)</li><li><code>wind_dir::WindDirTriple</code>: <a href="../types/#FLORIDyn.WindDirTriple"><code>WindDirTriple</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Updated wind direction(s) (vector)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L294-L305">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_RW_with_Mean, wind_dir::WindDirTriple, iT, t)</code></pre><p>Random walk with mean reversion model for wind direction.</p><p><strong>Arguments</strong></p><ul><li><code>::Direction_RW_with_Mean</code>: Direction mode indicator</li><li><code>wind_dir::WindDirTriple</code>: Wind direction data containing Init, CholSig, and MeanPull</li><li><code>iT</code>: Turbine index or indices</li><li><code>t</code>: Time value (unused in this implementation)</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Wind direction(s) for the requested turbine(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L316-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getWindDirT_EnKF" href="#FLORIDyn.getWindDirT_EnKF"><code>FLORIDyn.getWindDirT_EnKF</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getWindDirT_EnKF(::Direction_EnKF_InterpTurbine, wind_dir::AbstractMatrix, iT, t)</code></pre><p><strong>Direction<em>EnKF</em>InterpTurbine</strong></p><p>Return wind direction in SOWFA-deg for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir::Matrix</code>: Matrix where each row is [time, <code>phi_T0</code>, <code>phi_T1</code>, ... <code>phi_Tn</code>]</li><li><code>iT</code>: Index or indices of the turbines (can be integer or vector)</li><li><code>t</code>: Time of request (scalar)</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Wind direction(s) at time <code>t</code> for turbine(s) <code>iT</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_direction.jl#L84-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getDataDir" href="#FLORIDyn.getDataDir"><code>FLORIDyn.getDataDir</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getDataDir(set::Settings, wind::Wind, wf::WindFarm, t)</code></pre><p>Retrieve wind direction data for all turbines at the current simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing the direction mode configuration</li><li><code>wind::Wind</code>: Wind field data structure containing direction information and input type</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine states and configuration</li><li><code>t</code>: Current simulation time for temporal interpolation</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Wind direction values (typically in radians) for all turbines at the specified time</li></ul><p><strong>Description</strong></p><p>This function reads wind direction data and returns the current wind direction angle (phi) for all  turbines in the wind farm. The function handles two different input modes:</p><ol><li><p><strong>Random Walk with Mean mode</strong> (<code>wind.input_dir == &quot;RW_with_Mean&quot;</code>): Uses the current wind farm  state from <code>wf.States_WF[wf.StartI, 2]</code> along with the wind direction data to compute direction.</p></li><li><p><strong>Standard temporal interpolation mode</strong>: Uses the wind direction data directly with temporal  interpolation for all turbines at the specified simulation time.</p></li></ol><p>The function dispatches to <code>getWindDirT</code> with appropriate parameters based on the input mode,  ensuring consistent wind direction estimation across different modeling approaches.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get wind direction for all turbines at current simulation time
phi = getDataDir(settings, wind_data, wind_farm, 100.0)

# The returned phi contains direction values for all turbines
direction_turbine_1 = phi[1]</code></pre><p><strong>Notes</strong></p><ul><li>The function automatically handles different wind input modes through conditional logic</li><li>For random walk mode, uses existing wind farm state as reference</li><li>For standard mode, performs temporal interpolation across all turbines</li></ul><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.getWindDirT"><code>getWindDirT</code></a>: Underlying function for wind direction temporal interpolation</li><li><a href="../settings/#Settings"><code>Settings</code></a>: Configuration structure containing direction mode settings</li><li><a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>: Wind field data structure containing direction information and input type</li><li><a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>: Wind farm configuration structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/correction/direction.jl#L4-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.correctDir!" href="#FLORIDyn.correctDir!"><code>FLORIDyn.correctDir!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correctDir!(::Direction_All, set::Settings, wf::WindFarm, wind::Wind, t)</code></pre><p>Apply direction correction to all turbines in the wind farm using the Direction_All strategy.</p><p><strong>Arguments</strong></p><ul><li><code>::Direction_All</code>: The direction correction strategy type that applies corrections to all turbines</li><li><code>set::Settings</code>: Simulation settings containing the direction mode configuration</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine states and configuration (modified in-place)</li><li><code>wind::Wind</code>: Wind field data structure containing direction information and input type</li><li><code>t</code>: Current simulation time for temporal interpolation</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: This function modifies the wind farm state in-place and returns nothing</li></ul><p><strong>Description</strong></p><p>This function applies a direction correction using the Direction_All strategy, which updates the  wind direction for all turbines in the wind farm. The function performs the following operations:</p><ol><li><strong>Data Retrieval</strong>: Calls <code>getDataDir</code> to obtain current wind direction data for all turbines</li><li><strong>State Update</strong>: Updates the wind direction in the wind farm state (<code>wf.States_WF[:, 2]</code>)</li><li><strong>Operational Point Orientation</strong>: If the state matrix has 4 columns, also updates the  operational point orientation (<code>wf.States_WF[wf.StartI, 4]</code>) to match the wind direction</li></ol><p>The correction is applied uniformly to all turbines using the first direction value from the  retrieved direction data.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Apply direction correction to all turbines
correctDir!(Direction_All(), settings, wind_farm, wind_data, 100.0)

# The wind farm state is modified in-place
current_direction = wind_farm.States_WF[1, 2]  # Updated direction for first turbine</code></pre><p><strong>Notes</strong></p><ul><li>This function modifies the wind farm state in-place (indicated by the <code>!</code> suffix)</li><li>All turbines receive the same direction correction value (<code>phi[1]</code>)</li><li>The operational point orientation is only updated if the state matrix has 4 columns</li><li>Direction values are typically in radians following standard wind engineering conventions</li></ul><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.getDataDir"><code>getDataDir</code></a>: Function for retrieving wind direction data</li><li><a href="../types/#FLORIDyn.Direction_All"><code>Direction_All</code></a>: Direction correction strategy type</li><li><a href="../settings/#Settings"><code>Settings</code></a>: Simulation settings structure</li><li><a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>: Wind farm configuration structure</li><li><a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>: Wind field data structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/correction/direction.jl#L63-L111">source</a></section></article><h1 id="Calculating-the-wind-velocity"><a class="docs-heading-anchor" href="#Calculating-the-wind-velocity">Calculating the wind velocity</a><a id="Calculating-the-wind-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-wind-velocity" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getDataVel" href="#FLORIDyn.getDataVel"><code>FLORIDyn.getDataVel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getDataVel(set::Settings, wind::Wind, wf::WindFarm, t, tmp_m, floris::Floris)</code></pre><p>Retrieve wind velocity data for all turbines at the current simulation time using various input modes.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing the velocity mode configuration</li><li><code>wind::Wind</code>: Wind field data structure containing velocity information and input type</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine states and configuration</li><li><code>t</code>: Current simulation time for temporal interpolation</li><li><code>tmp_m</code>: Temporary matrix containing reduction factors and other intermediate calculations</li><li><code>floris::Floris</code>: FLORIS model parameters including wake model coefficients</li></ul><p><strong>Returns</strong></p><ul><li><code>u</code>: Wind velocity values for all turbines at the specified time</li><li><code>wind::Wind</code>: Updated wind field data structure (may be modified for certain input modes)</li></ul><p><strong>Description</strong></p><p>This function reads wind velocity data and returns the current wind speed (U) for all turbines  in the wind farm. The function handles multiple input modes through conditional logic:</p><ol><li><p><strong>Interpolation and Integration mode</strong> (<code>&quot;I_and_I&quot;</code>): Uses <code>getWindSpeedT</code> with turbine positions,  wind direction, and FLORIS parameters. Applies wake effects reduction if the simulation time  exceeds the wind speed estimator offset.</p></li><li><p><strong>Random Walk with Mean mode</strong> (<code>&quot;RW_with_Mean&quot;</code>): Uses the current wind farm state from  <code>wf.States_WF[wf.StartI, 1]</code> with the wind velocity model.</p></li><li><p><strong>Ensemble Kalman Filter mode</strong> (<code>&quot;EnKF_InterpTurbine&quot;</code>): Uses EnKF-based interpolation  at turbine locations via <code>getWindSpeedT_EnKF</code>.</p></li><li><p><strong>Standard temporal interpolation mode</strong> (default): Uses direct temporal interpolation  with <code>getWindSpeedT</code> for all turbines.</p></li></ol><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get wind velocity for all turbines at current simulation time
u, updated_wind = getDataVel(settings, wind_data, wind_farm, 100.0, temp_matrix, floris_params)

# The returned u contains velocity values for all turbines
velocity_turbine_1 = u[1]</code></pre><p><strong>Notes</strong></p><ul><li>The function automatically handles different wind input modes through conditional logic</li><li>For I<em>and</em>I mode, wake effects are applied based on timing and reduction factors</li><li>The wind structure may be modified and returned for certain input modes</li><li>Velocity values are in m/s</li><li>Wake reduction is only applied in I<em>and</em>I mode when sufficient time has elapsed</li></ul><p><strong>See also</strong></p><ul><li><a href="../settings/#Settings"><code>Settings</code></a>: Simulation settings structure</li><li><a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>: Wind field data structure</li><li><a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>: Wind farm configuration structure</li><li><a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>: FLORIS model parameters structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/correction/velocity.jl#L14-L69">source</a></section></article><h1 id="Calculating-the-wind-shear"><a class="docs-heading-anchor" href="#Calculating-the-wind-shear">Calculating the wind shear</a><a id="Calculating-the-wind-shear-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-wind-shear" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getWindShearT" href="#FLORIDyn.getWindShearT"><code>FLORIDyn.getWindShearT</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getWindShearT(::Shear_Interpolation, WindShear::AbstractMatrix, z)</code></pre><p>Compute the wind shear at a given height <code>z</code> using the specified <code>WindShear</code> model.</p><p><strong>Arguments</strong></p><ul><li><code>::Shear_Interpolation</code>: (Type only) Use interpolation to determine the wind shear.</li><li><code>WindShear</code>: A matrix describing the wind shear profile.</li><li><code>z</code>: The height (in meters) at which to evaluate the wind shear.</li></ul><p><strong>Returns</strong></p><ul><li>The wind shear value at height <code>z</code>.</li></ul><p><strong>REMARKS</strong></p><p>Expects a .csv file called &quot;WindShearProfile.csv&quot; with a normalized wind speed profile for different heights:</p><pre><code class="nohighlight hljs">z, (u_z/u0)
z, (u_z/u0)
z, (u_z/u0)</code></pre><p>There is a linear interpolation between every pair. In case z is out of bounds the function will use the closest available setpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_shear.jl#L6-L28">source</a></section><section><div><pre><code class="language-julia hljs">getWindShearT(::Shear_PowerLaw, WindShear, z_norm)</code></pre><p>Return the shear factor <code>u_eff = shear * u_referenceHeight</code> using the power law.</p><p><strong>Arguments</strong></p><ul><li><code>Shear_PowerLaw</code>: (type only, unused) Specifies that this method applies to the power law model</li><li><code>WindShear</code>: A struct of type (<code>WindShear</code>)(@ref)<ul><li><code>z0</code>: Reference height (not used in this function)</li><li><code>alpha</code>: WindShear coefficient</li></ul></li><li><code>z_norm</code>: Height(s) (can be scalar or array)</li></ul><p><strong>Returns</strong></p><ul><li><code>shear</code>: The shear factor at the given height(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_shear.jl#L58-L72">source</a></section></article><h1 id="Calculating-the-wind-turbulence"><a class="docs-heading-anchor" href="#Calculating-the-wind-turbulence">Calculating the wind turbulence</a><a id="Calculating-the-wind-turbulence-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-wind-turbulence" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getDataTI" href="#FLORIDyn.getDataTI"><code>FLORIDyn.getDataTI</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getDataTI(set::Settings, wind::Wind, wf::WindFarm, t) -&gt; Vector</code></pre><p>Retrieve turbulence intensity data for all turbines at the current simulation time.</p><p>This function obtains turbulence intensity values for all turbines in the wind farm using the configured turbulence model and wind field data. It serves as a wrapper around the underlying turbulence intensity retrieval system.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Settings object containing simulation configuration<ul><li><code>set.turb_mode</code>: Turbulence model configuration specifying the retrieval method</li></ul></li><li><code>wind::Wind</code>: Wind configuration object containing turbulence intensity data<ul><li><code>wind.ti</code>: Turbulence intensity data, parameters, or model configuration</li></ul></li><li><code>wf::WindFarm</code>: Wind farm object containing turbine information<ul><li><code>wf.nT</code>: Number of turbines in the wind farm</li></ul></li><li><code>t</code>: Current simulation time for time-dependent turbulence intensity models</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Turbulence intensity values for all turbines (dimensionless, typically 0.05-0.25)</li></ul><p><strong>Behavior</strong></p><p>The function creates a vector of all turbine indices <code>[1, 2, ..., nT]</code> and retrieves the corresponding turbulence intensity values using the specified turbulence model. The actual retrieval method depends on the <code>set.turb_mode</code> configuration and can include:</p><ul><li>Constant turbulence intensity</li><li>Time-interpolated values from data files</li><li>Turbine-specific interpolation</li><li>Random walk models with covariance</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get turbulence intensity for all turbines at t=100s
TI_values = getDataTI(settings, wind_config, wind_farm, 100.0)
println(&quot;TI for turbine 1: &quot;, TI_values[1])</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.getWindTiT"><code>getWindTiT</code></a>: Underlying function for turbulence intensity retrieval</li><li><a href="#FLORIDyn.correctTI!"><code>correctTI!</code></a>: Function that uses this data to update wind farm states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/correction/turbulence.jl#L71-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getWindTiT" href="#FLORIDyn.getWindTiT"><code>FLORIDyn.getWindTiT</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getWindTiT(::TI_Constant, wind_ti::Number, iT, _)</code></pre><p>Return turbulence intensity for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>::TI_Constant</code>: type parameter to indicate constant wind turbulence</li><li><code>wind_ti::Number</code>: Constant value (turbulence intensity)</li><li><code>iT</code>: Index or indices of the turbines</li><li><code>_</code>: will be ignored</li></ul><p><strong>Returns</strong></p><ul><li><code>Ti</code>: Array of turbulence intensity values for each turbine index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_turbulence.jl#L4-L17">source</a></section><section><div><pre><code class="language-julia hljs">getWindTiT(::TI_Interpolation, wind_ti::AbstractMatrix, iT, t)</code></pre><p>Interpolates the wind turbulence intensity (TI) at a given time <code>t</code> using the specified <code>TI_Interpolation</code> method.</p><p><strong>Arguments</strong></p><ul><li><code>::TI_Interpolation</code>: Use linear interpolation to calculate the turbulence intensity.</li><li><code>wind_ti::Matrix</code>: Matrix containing wind turbulence intensity values over time.</li><li><code>iT</code>: Index/indices of the turbines (can be Int or array).</li><li><code>t</code>: The specific time at which to interpolate the turbulence intensity.</li></ul><p><strong>Returns</strong></p><ul><li>The interpolated turbulence for the requested turbine(s) at time <code>t</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The function assumes that <code>wind_ti</code> contains the necessary data for interpolation as (time, TI) pairs (n×2 matrix)</li><li>Uniform interpolation version - all turbines experience the same changes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_turbulence.jl#L54-L72">source</a></section><section><div><pre><code class="language-julia hljs">getWindTiT(::TI_InterpTurbine, wind_ti::AbstractMatrix, iT, t)</code></pre><p>Retrieve the wind turbulence intensity (TI) for a specific turbine at a given time.</p><p><strong>Arguments</strong></p><ul><li><code>::TI_InterpTurbine</code>: The turbulence intensity interpolation object for the turbine.</li><li><code>wind_ti::AbstractMatrix</code>: Matrix containing wind turbulence intensity values.</li><li><code>iT</code>: Index of the turbine for which the TI is requested.</li><li><code>t</code>: Time at which the TI value is needed.</li></ul><p><strong>Returns</strong></p><ul><li>The interpolated wind turbulence intensity value for the specified turbine at time <code>t</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/windfield/windfield_turbulence.jl#L139-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.correctTI!" href="#FLORIDyn.correctTI!"><code>FLORIDyn.correctTI!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correctTI!(::TI_None, set::Settings, wf::WindFarm, wind::Wind, t) -&gt; Nothing</code></pre><p>Update turbulence intensity values in the wind farm state matrix without correction.</p><p>This function implements the &quot;no correction&quot; strategy for turbulence intensity, where  the wind farm turbulence intensity values are updated with fresh data from the wind  field model without applying any correction algorithms. It serves as the baseline  approach for turbulence intensity handling in FLORIDyn simulations.</p><p><strong>Arguments</strong></p><ul><li><code>::TI_None</code>: Dispatch type indicating no turbulence intensity correction algorithm</li><li><code>set::Settings</code>: Settings object containing simulation configuration and turbulence model parameters<ul><li><code>set.turb_mode</code>: Turbulence model configuration specifying the retrieval method</li></ul></li><li><code>wf::WindFarm</code>: Wind farm object containing the state matrices to be updated<ul><li><code>wf.States_WF</code>: Wind field states matrix where column 3 contains turbulence intensity values</li><li><code>wf.StartI</code>: Starting indices for each turbine&#39;s operational points</li><li><code>wf.nT</code>: Number of turbines</li></ul></li><li><code>wind::Wind</code>: Wind configuration object containing turbulence intensity data<ul><li><code>wind.ti</code>: Turbulence intensity data or model parameters</li></ul></li><li><code>t</code>: Current simulation time for time-dependent turbulence intensity retrieval</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: The function modifies the wind farm state in-place</li></ul><p><strong>Behavior</strong></p><ol><li>Retrieves current turbulence intensity values for all turbines using <a href="#FLORIDyn.getDataTI"><code>getDataTI</code></a></li><li>Updates the wind farm state matrix <code>wf.States_WF</code> at rows <code>wf.StartI</code> and column 3</li><li>Transposes the turbulence intensity vector to match the matrix structure</li><li>Provides error handling for matrix update operations</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Update turbulence intensity without correction at t=50s
correctTI!(TI_None(), settings, wf, wind, 50.0)

# The wind farm state matrix is now updated with new TI values
current_ti = wf.States_WF[wf.StartI, 3]</code></pre><p><strong>Notes</strong></p><ul><li>The function modifies the wind farm object in-place (indicated by the <code>!</code> suffix)</li><li>This &quot;no correction&quot; approach provides baseline turbulence intensity without  applying wake-induced corrections or measurement-based adjustments</li><li>Error handling ensures graceful failure if matrix dimensions are incompatible</li></ul><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.getDataTI"><code>getDataTI</code></a>: Function used to retrieve turbulence intensity data</li><li><a href="../types/#FLORIDyn.TI_None"><code>TI_None</code></a>: Dispatch type for no correction strategy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/correction/turbulence.jl#L4-L53">source</a></section></article><h1 id="Controller-functions"><a class="docs-heading-anchor" href="#Controller-functions">Controller functions</a><a id="Controller-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Controller-functions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getYaw" href="#FLORIDyn.getYaw"><code>FLORIDyn.getYaw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getYaw(::Yaw_SOWFA, ConYawData::AbstractMatrix, iT, t) -&gt; Float64 or Vector{Float64}</code></pre><p>Return the yaw angle at time <code>t</code> for the specified turbine(s) using linear interpolation.</p><p><strong>Arguments</strong></p><ul><li><code>::Yaw_SOWFA</code>: Controller type dispatch parameter for SOWFA-style yaw control</li><li><code>ConYawData::Matrix{Float64}</code>: Control data matrix where:<ul><li>First column contains time values (in seconds)</li><li>Subsequent columns contain yaw angles for each turbine (in degrees)</li></ul></li><li><code>iT</code>: Turbine index or indices to query:<ul><li><code>Integer</code>: Single turbine index (1-based)</li><li><code>AbstractVector{&lt;:Integer}</code>: Vector of turbine indices for multiple turbines</li></ul></li><li><code>t::Real</code>: Requested time (in seconds)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Single yaw angle (in degrees) if <code>iT</code> is an integer</li><li><code>Vector{Float64}</code>: Vector of yaw angles (in degrees) if <code>iT</code> is a vector</li></ul><p><strong>Behavior</strong></p><ul><li><strong>Interpolation</strong>: Uses linear interpolation between time points with flat extrapolation</li><li><strong>Out-of-bounds handling</strong>: If <code>t</code> is outside the time range, the function:<ul><li>Issues a warning message</li><li>Clamps <code>t</code> to the nearest boundary (first or last time point)</li></ul></li><li><strong>Single time point</strong>: If only one time point exists, returns the corresponding yaw value directly</li><li><strong>Error handling</strong>: Throws an error if <code>iT</code> is not an integer or vector of integers</li></ul><p><strong>Data Format</strong></p><p>The <code>con_yaw_data</code> matrix should have the structure:</p><pre><code class="nohighlight hljs">[time₁  yaw₁₁  yaw₁₂  ...  yaw₁ₙ]
[time₂  yaw₂₁  yaw₂₂  ...  yaw₂ₙ]
[  ⋮      ⋮      ⋮    ⋱     ⋮  ]
[timeₘ  yawₘ₁  yawₘ₂  ...  yawₘₙ]</code></pre><p>where <code>m</code> is the number of time steps and <code>n</code> is the number of turbines.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example control data: 3 time points, 2 turbines
con_yaw_data = [0.0  10.0  5.0;   # t=0s: T1=10°, T2=5°
                1.0  15.0  10.0;  # t=1s: T1=15°, T2=10°
                2.0  20.0  15.0]  # t=2s: T1=20°, T2=15°

# Get yaw for turbine 1 at t=0.5s (interpolated)
yaw1 = getYaw(Yaw_SOWFA(), con_yaw_data, 1, 0.5)  # Returns 12.5°

# Get yaw for multiple turbines at t=1.5s
yaws = getYaw(Yaw_SOWFA(), con_yaw_data, [1, 2], 1.5)  # Returns [17.5°, 12.5°]

# Out-of-bounds time (will issue warning)
yaw_oob = getYaw(Yaw_SOWFA(), con_yaw_data, 1, 5.0)  # Returns 20.0° with warning</code></pre><p><strong>See Also</strong></p><ul><li><a href="../types/#FLORIDyn.Yaw_SOWFA"><code>Yaw_SOWFA</code></a>: Controller type for SOWFA-style yaw control</li><li><code>Interpolations.linear_interpolation</code>: Underlying interpolation method used</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/controller/controller.jl#L4-L61">source</a></section></article><h1 id="FLORIS"><a class="docs-heading-anchor" href="#FLORIS">FLORIS</a><a id="FLORIS-1"></a><a class="docs-heading-anchor-permalink" href="#FLORIS" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.calcCt" href="#FLORIDyn.calcCt"><code>FLORIDyn.calcCt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcCt(a, _) -&gt; Number or Vector</code></pre><p>Calculate the thrust coefficient <code>ct</code> for a wind turbine based on the axial induction factor <code>a</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: Axial induction factor, typically between 0 and 0.5 (can be a scalar or vector)</li><li>_: unused parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>ct::Number</code>: The calculated thrust coefficient.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floris/gaussian.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.centerline" href="#FLORIDyn.centerline"><code>FLORIDyn.centerline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centerline(states_op, states_t, states_wf, floris, d_rotor)</code></pre><p>Compute the centerline wake properties for a wind farm simulation.</p><p><strong>Arguments</strong></p><ul><li><code>states_op</code>: Operational states of the turbines (e.g., yaw, pitch, etc.).</li><li><code>states_t</code>: Turbine-specific states (e.g., rotor speed, torque, etc.).</li><li><code>states_wf</code>: Wind farm-level states (e.g., wind direction, wind speed, etc.).</li><li><code>floris</code>: Parameters for the FLORIS wake model.</li><li><code>d_rotor</code>: Rotor diameter or characteristic length scale.</li></ul><p><strong>Returns</strong></p><ul><li>The computed centerline wake properties <code>delta</code>, which includes the deflection in the y and z directions.</li></ul><p><strong>Notes</strong></p><p>This function is part of the Gaussian wake model implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floris/gaussian.jl#L66-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.discretizeRotor" href="#FLORIDyn.discretizeRotor"><code>FLORIDyn.discretizeRotor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretizeRotor(n_rp::Int)</code></pre><p>Discretizes the rotor into a <code>n_rp</code> segments. The algorithm returns the normalized center location ∈ [-0.5, 0.5] and the relative area the segment represents.</p><p><strong>Arguments</strong></p><ul><li><code>n_rp::Int</code>: The number of radial points to discretize the rotor into.</li></ul><p><strong>Returns</strong></p><ul><li>The tuple <code>(m_rp, w)</code> where:<ul><li><code>m_rp</code>: A matrix of size <code>(nC, 3)</code> where <code>nC</code> is the number of segments. The first column is all zeros,   the second and third columns contain the normalized radial positions.</li><li><code>w</code>: A vector of weights corresponding to each segment, summing to approximately 1.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>The algorithm returns the normalized center location in the range <code>[-0.5, 0.5]</code> and the relative area that each segment represents.</li><li>The isocell algorithm is used, which may not yield exactly <code>n_rp</code> cells but aims to achieve a similar number.</li><li>For details, see the publication by Masset et al.: <a href="https://orbi.uliege.be/bitstream/2268/91953/1/masset_isocell_orbi.pdf">Masset et al. (2009)</a></li><li>The choice of <code>N1 = 3</code> is made here, but values of <code>4</code> or <code>5</code> are also viable options. The choice of <code>3</code> is close to optimal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floris/discretization.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.init_states" href="#FLORIDyn.init_states"><code>FLORIDyn.init_states</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_states(set::Settings, wf::WindFarm, wind::Wind, init_turb, floris::Floris, sim::Sim)</code></pre><p>Initialize the state arrays for wind farm simulation using the Gaussian wake model.</p><p>This function sets up the initial conditions for turbines, observation points, and wind field  states based on the provided configuration parameters. It computes initial positions, wind  conditions, and wake properties for each turbine in the wind farm.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options for velocity, direction, and turbulence models</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, dimensions, and state arrays (see <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>)</li><li><code>wind::Wind</code>: Wind conditions including velocity, direction, and turbulence intensity data (see <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>)</li><li><code>init_turb</code>: Initial turbine state parameters (axial induction factor, yaw angle, turbulence intensity)</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>sim::Sim</code>: Simulation parameters including time step and start time (see <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a>)</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(states_op, states_t, states_wf)</code> containing:</p><ul><li><code>states_op::Matrix</code>: Observation point states with 3D coordinates and wake positions</li><li><code>states_t::Matrix</code>: Turbine states including control parameters and operational conditions  </li><li><code>states_wf::Matrix</code>: Wind field states with velocity, direction, and turbulence data</li></ul><p><strong>Description</strong></p><p>The function performs the following initialization steps for each turbine:</p><ol><li>Retrieves wind field data (velocity, direction, turbulence intensity) based on the specified input methods</li><li>Initializes wind field states at all observation points for the turbine</li><li>Calculates downwind distances for wake coordinate system</li><li>Sets initial turbine states from provided parameters</li><li>Computes crosswind wake deflections using the centerline function</li><li>Transforms coordinates from wake-relative to world coordinate system</li><li>Updates observation point positions including turbine base and nacelle offsets</li></ol><p><strong>Notes</strong></p><ul><li>Supports multiple wind input methods including interpolation, constant values, and random walk models</li><li>Handles both 3D and 4D wind field configurations (with optional orientation data)</li><li>Uses SOWFA coordinate system conventions for angle transformations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floris/gaussian.jl#L231-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getVars" href="#FLORIDyn.getVars"><code>FLORIDyn.getVars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getVars(rps::Union{Matrix, Adjoint}, c_t, yaw, ti, ti0, floris::Floris, d_rotor)</code></pre><p>Compute and return variables related to the Gaussian wake model for wind turbines.</p><p>In particular, it calculates the field width, the potential core data and the deflection. These values are needed for the calculation of the wake shape and speed  reduction. The values are based of the state of every individual OP.</p><p><strong>Arguments</strong></p><ul><li><code>rps</code>: Matrix of reference points where the variables are evaluated.</li><li><code>c_t</code>: Thrust coefficient(s) for the turbine(s).</li><li><code>yaw</code>: Yaw angle(s) of the turbine(s) in radians or degrees.</li><li><code>ti</code>: Turbulence intensity at the reference points.</li><li><code>ti0</code>: Ambient turbulence intensity.</li><li><code>floris::Floris</code>: FLORIS model parameters containing Gaussian wake model parameters (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>).</li><li><code>d_rotor</code>: Rotor diameter(s) of the turbine(s).</li></ul><p><strong>Returns</strong></p><p>Returns the tuple</p><ul><li>sig_y::Vector: Gaussian variance in y direction (sqrt of)</li><li>sig_z::Vector: Gaussian variance in z direction (sqrt of)</li><li>c_t: Thrust coefficient, same as OP.Ct</li><li>x_0: Potential core length</li><li>delta: Deflection</li><li>pc_y: Potential core boundary in y dir</li><li>pc_z: Potential core boundary in z dir</li></ul><p><strong>SOURCES</strong></p><ul><li>[1] Experimental and theoretical study of wind turbine wakes in yawed conditions - M. Bastankhah and F. Porté-Agel</li><li>[2] Design and analysis of a spatially heterogeneous wake - A. Farrell, J. King et al.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floris/gaussian.jl#L337-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getPower" href="#FLORIDyn.getPower"><code>FLORIDyn.getPower</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getPower(wf::WindFarm, m::AbstractMatrix, floris::Floris, con::Con)</code></pre><p>Calculate the power output of wind turbines in a wind farm simulation.</p><p>This function computes the power generated by wind turbines based on their operational states, wind conditions, and control settings. It accounts for yaw angle effects and optional yaw range constraints using hyperbolic tangent functions for smooth operational limits.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine states, dimensions, and operational data with current axial induction factors and yaw angles (see <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>)</li><li><code>m::Matrix</code>: Measurement or simulation data matrix where column 3 contains effective wind speeds at turbine locations [m/s]</li><li><code>floris::Floris</code>: FLORIS model parameters containing air density, drivetrain efficiency, and power curve parameters (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>con::Con</code>: Controller configuration object with yaw control settings and operational constraints (see <a href="../settings/#FLORIDyn.Con"><code>Con</code></a>)</li></ul><p><strong>Returns</strong></p><ul><li><code>P::Vector{Float64}</code>: Power output for each turbine in the wind farm [W]</li></ul><p><strong>Description</strong></p><p>The function calculates power using the standard wind turbine power equation with yaw corrections:</p><pre><code class="language-julia hljs">P = 0.5 × ρ × A × Cp × U³ × η × cos(γ)^p_p × f_yaw_constraints</code></pre><p>Where:</p><ul><li><code>ρ</code> is air density [<code>floris.airDen</code>] [kg/m³]</li><li><code>A</code> is rotor swept area <code>π × (D/2)²</code> [m²]</li><li><code>Cp</code> is power coefficient calculated as <code>4a(1-a)²</code> [-]</li><li><code>U</code> is effective wind speed from column 3 of matrix <code>m</code> [m/s]</li><li><code>η</code> is drivetrain efficiency [<code>floris.eta</code>] [-]</li><li><code>γ</code> is yaw angle [rad]</li><li><code>p_p</code> is yaw power exponent [<code>floris.p_p</code>] [-]</li><li><code>f_yaw_constraints</code> is optional yaw range constraint factor [-]</li></ul><p>The yaw constraint factor is applied when <code>con.tanh_yaw</code> is true:</p><pre><code class="language-julia hljs">f_yaw_constraints = [0.5 × tanh((γ_max - γ) × 50) + 0.5] × 
                           [-0.5 × tanh((γ_min - γ) × 50) + 0.5]</code></pre><p><strong>Notes</strong></p><ul><li>Power coefficient is calculated from axial induction factor: <code>Cp = 4a(1-a)²</code></li><li>Yaw effects reduce power output according to <code>cos(γ)^p_p</code> where <code>p_p</code> is typically 1.88</li><li>Optional yaw range constraints use hyperbolic tangent functions with slope factor 50 for smooth transitions</li><li>When <code>con.tanh_yaw</code> is enabled, power is smoothly constrained within [<code>con.yawRangeMin</code>, <code>con.yawRangeMax</code>]</li><li>The constraint functions approach step functions but provide smooth gradients for optimization</li><li>Axial induction factors are extracted from <code>wf.States_T[wf.StartI, 1]</code> for current time step</li><li>Yaw angles are converted from degrees to radians internally</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floris/gaussian.jl#L633-L682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.runFLORIS" href="#FLORIDyn.runFLORIS"><code>FLORIDyn.runFLORIS</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runFLORIS(set::Settings, location_t, states_wf, states_t, d_rotor, 
          floris::Floris, windshear::Union{Matrix, WindShear})</code></pre><p>Execute the FLORIS (FLOw Redirection and Induction in Steady State) wake model simulation for wind farm analysis.</p><p>This function performs a comprehensive wake analysis using the Gaussian wake model to calculate velocity reductions, turbulence intensity additions, and effective wind speeds at turbine locations. It accounts for wake interactions, rotor discretization, wind shear effects, and turbulence propagation.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options for wind shear modeling</li><li><code>location_t</code>: Matrix of turbine positions [x, y, z] coordinates for each turbine [m]</li><li><code>states_wf</code>: Wind field state matrix containing velocity, direction, and turbulence data</li><li><code>states_t</code>: Turbine state matrix with axial induction factors, yaw angles, and turbulence intensities</li><li><code>d_rotor</code>: Vector of rotor diameters for each turbine [m]</li><li><code>floris::Floris</code>: FLORIS model parameters containing wake model coefficients and rotor discretization settings (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>windshear</code>: Wind shear profile data for vertical wind speed variation modeling, either a matrix or of type <a href="../types/#FLORIDyn.WindShear"><code>WindShear</code></a></li></ul><p><strong>Returns</strong></p><p>A tuple <code>(T_red_arr, T_aTI_arr, T_Ueff, T_weight)</code> containing:</p><ul><li><code>T_red_arr::Vector{Float64}</code>: Velocity reduction factors for each turbine [-]</li><li><code>T_aTI_arr::Union{Vector{Float64}, Nothing}</code>: Added turbulence intensity from upstream wakes [%]</li><li><code>T_Ueff::Union{Float64, Nothing}</code>: Effective wind speed at the last turbine location [m/s]</li><li><code>T_weight::Union{Vector{Float64}, Nothing}</code>: Gaussian weight factors for wake overlap calculations [-]</li></ul><p><strong>Description</strong></p><p>The function performs the following computational steps:</p><p><strong>1. Rotor Discretization</strong></p><ul><li>Discretizes rotor planes into radial points using the isocell algorithm</li><li>Applies yaw rotation transformations to rotor point coordinates</li><li>Handles both active turbines (d_rotor &gt; 0) and placeholder turbines</li></ul><p><strong>2. Single Turbine Case</strong></p><p>For single turbine simulations, only wind shear effects are calculated without wake interactions.</p><p><strong>3. Multi-Turbine Wake Analysis</strong></p><p>For each upstream turbine affecting downstream turbines:</p><p><strong>Coordinate Transformations</strong></p><ul><li>Transforms rotor points to wake coordinate system aligned with wind direction</li><li>Applies rotational matrices for wind direction and turbine yaw angles</li><li>Filters turbines based on minimum downstream distance (10 rotor diameters)</li></ul><p><strong>Wake Variable Calculations</strong></p><ul><li>Computes wake expansion coefficients, potential core dimensions, and deflection using <code>getVars</code></li><li>Calculates crosswind wake positions and radial distances from wake centerline</li><li>Determines core region boundaries and near/far wake transitions</li></ul><p><strong>Velocity Reduction Modeling</strong></p><ul><li>Applies different deficit models for core region vs. Gaussian wake regions</li><li>Uses velocity deficit superposition for multiple wake interactions</li><li>Accounts for yaw-induced wake deflection and asymmetry</li></ul><p><strong>Turbulence Intensity Enhancement</strong></p><ul><li>Calculates added turbulence intensity using empirical correlations</li><li>Applies Gaussian weighting for spatial distribution of turbulence enhancement</li><li>Uses parameters k<em>fa, k</em>fb, k<em>fc, k</em>fd for turbulence intensity modeling</li></ul><p><strong>4. Wind Shear Integration</strong></p><ul><li>Applies vertical wind shear corrections to the downstream turbine</li><li>Uses wind shear profile data for realistic boundary layer effects</li></ul><p><strong>Mathematical Models</strong></p><p>The function implements several key wake modeling equations:</p><p><strong>Velocity Deficit</strong>: Based on Gaussian wake theory with yaw corrections <strong>Deflection</strong>: Uses analytical wake deflection models for yawed turbines   <strong>Turbulence</strong>: Empirical correlations for wake-added turbulence intensity <strong>Superposition</strong>: Linear superposition of velocity deficits from multiple wakes</p><p><strong>Notes</strong></p><ul><li>Uses SOWFA (Simulator for Offshore Wind Farm Applications) coordinate conventions</li><li>Implements state-of-the-art Gaussian wake model with yaw considerations</li><li>Supports both research and engineering applications for wind farm optimization</li><li>Computational complexity scales as O(N²) for N turbines due to wake interactions</li><li>Requires proper initialization of turbine states and wind field conditions</li></ul><p><strong>References</strong></p><ul><li>Bastankhah, M. and Porté-Agel, F. (2016). Experimental and theoretical study of wind turbine wakes in yawed conditions</li><li>Niayifar, A. and Porté-Agel, F. (2016). Analytical modeling of wind farms: A new approach for power prediction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floris/gaussian.jl#L440-L522">source</a></section></article><h1 id="FLORIDyn"><a class="docs-heading-anchor" href="#FLORIDyn">FLORIDyn</a><a id="FLORIDyn-1"></a><a class="docs-heading-anchor-permalink" href="#FLORIDyn" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.initSimulation" href="#FLORIDyn.initSimulation"><code>FLORIDyn.initSimulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initSimulation(wf::Union{Nothing, WindFarm}, sim::Sim)</code></pre><p>Initialize or load a wind farm simulation state based on simulation settings.</p><p>This function handles the initialization phase of a wind farm simulation by either saving  the current initialized state to disk or loading a previously saved state, depending on  the simulation configuration.</p><p><strong>Arguments</strong></p><ul><li><code>wf::Union{Nothing, WindFarm}</code>: Wind farm object containing the initialized simulation state, or <code>Nothing</code> if no state is available. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>sim::Sim</code>: Simulation configuration object containing initialization settings and file paths. See <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>wf::Union{Nothing, WindFarm}</code>: The wind farm state, either the original input state (for &quot;init&quot; mode) or a loaded state from disk (for &quot;load&quot; mode)</li></ul><p><strong>Behavior</strong></p><p>The function operates in two modes based on <code>sim.init</code>:</p><p><strong>&quot;init&quot; Mode</strong></p><ul><li>Uses the provided wind farm state as-is</li><li>If <code>sim.save_init_state</code> is <code>true</code>, saves the current state to <code>&quot;T_init.jld2&quot;</code> in the specified data directory</li><li>Logs the save operation for user feedback</li></ul><p><strong>&quot;load&quot; Mode</strong></p><ul><li>Attempts to load a previously saved wind farm state from <code>&quot;T_init.jld2&quot;</code></li><li>Falls back to the provided state if loading fails (with warning)</li><li>Handles file I/O errors gracefully</li></ul><p><strong>File Operations</strong></p><ul><li><strong>Save path</strong>: <code>$(sim.path_to_data)/T_init.jld2</code></li><li><strong>Format</strong>: JLD2 binary format for efficient Julia object serialization</li><li><strong>Error handling</strong>: Loading failures produce warnings but do not halt execution</li></ul><p><strong>Notes</strong></p><ul><li>The function is case-insensitive for the initialization mode string</li><li>File operations use the path specified in <code>sim.path_to_data</code></li><li>Loading errors are caught and logged as warnings, allowing simulation to proceed with the original state</li><li>This mechanism enables reproducible simulations by preserving and reusing initial conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/floridyn_cl.jl#L61-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.findTurbineGroups" href="#FLORIDyn.findTurbineGroups"><code>FLORIDyn.findTurbineGroups</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findTurbineGroups(wf::WindFarm, floridyn::FloriDyn)</code></pre><p>Determine wake interaction dependencies between turbines in a wind farm.</p><p>This function analyzes the spatial relationships between turbines to identify which turbines  are affected by the wakes of upstream turbines. It uses coordinate transformations to the  wind-aligned reference frame and geometric criteria to determine wake interactions.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, operational points, and wind field states. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters containing wake interaction thresholds. See <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>vv_dep::Vector{Vector{Int64}}</code>: A vector of vectors where <code>vv_dep[i]</code> contains the indices of all turbines  that affect turbine <code>i</code> through wake interactions. Each inner vector lists the upstream turbine indices  that influence the wake conditions at the corresponding turbine.</li></ul><p><strong>Algorithm</strong></p><ol><li><strong>Coordinate Transformation</strong>: For each turbine pair, transforms coordinates to a wind-aligned frame using the closest operational point</li><li><strong>Wake Zone Detection</strong>: Applies geometric criteria to determine if a downstream turbine lies within the wake zone:<ul><li>Upstream extent: <code>r₁[1] ≥ -uw × D[iT]</code> (allowing for slight upstream influence)</li><li>Downstream extent: <code>r₁[1] ≤ dw × D[iT]</code> (wake extends downstream)  </li><li>Lateral extent: <code>|r₁[2]| ≤ cw × D[iT]</code> (wake width constraint)</li></ul></li><li><strong>Dependency Matrix</strong>: Constructs a boolean dependency matrix and extracts indices for each turbine</li></ol><p><strong>Mathematical Description</strong></p><p>The wake interaction criteria are evaluated in the wind-aligned coordinate system:</p><pre><code class="nohighlight hljs">r₁ = R(φ) × (rₒₚ - rₜᵤᵣᵦ)</code></pre><p>where:</p><ul><li><code>R(φ)</code> is the rotation matrix for wind direction angle <code>φ</code></li><li><code>rₒₚ</code> is the position of the closest operational point from the upstream turbine</li><li><code>rₜᵤᵣᵦ</code> is the position of the downstream turbine being evaluated</li></ul><p><strong>Notes</strong></p><ul><li>The function uses the closest operational point from each upstream turbine to determine wind direction</li><li>Wake zones are defined as multiples of rotor diameter using the FLORIDyn parameters</li><li>Self-interaction (turbine affecting itself) is explicitly excluded</li><li>The coordinate transformation accounts for the SOWFA wind direction convention</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/floridyn_cl.jl#L196-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.prepareSimulation" href="#FLORIDyn.prepareSimulation"><code>FLORIDyn.prepareSimulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepareSimulation(set::Settings, wind::Wind, con::Con, floridyn::FloriDyn, floris::Floris, turbProp, sim::Sim)</code></pre><p>Prepares the simulation environment for a wind farm analysis using the provided settings and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options.</li><li><code>wind::Wind</code>: Wind conditions or wind field data. See: <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a> </li><li><code>con::Con</code>: Controller parameters of the turbines.  See: <a href="../settings/#FLORIDyn.Con"><code>Con</code></a></li><li><code>floridyn::FloriDyn</code>: Parameters specific to the FLORIDyn model. See: <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li><li><code>floris::Floris</code>: Parameters specific to the FLORIS model. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>turbProp</code>: Properties of the turbines involved in the simulation.</li><li><code>sim::Sim</code>: Simulation-specific parameters or state. See: <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li></ul><p><strong>Arguments that get modified</strong></p><ul><li><code>wind</code>: Updated with wind velocity, direction, turbulence intensity, and shear profile.</li><li><code>con</code>: Updated with yaw data.</li><li><code>sim</code>: Updated with the number of simulation steps.</li><li><code>floris</code>: May include additional parameters for the FLORIS model.</li></ul><p><strong>Returns</strong></p><ul><li>Returns the tuple <code>(wf, wind, sim, con, floris)</code> where:<ul><li><code>wf</code>: Wind farm struct containing turbine states and positions. See: <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>wind</code>: Updated wind conditions.</li><li><code>sim</code>: Updated simulation parameters.</li><li><code>con</code>: Updated controller parameters.</li><li><code>floris</code>: Parameters for the FLORIS model.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/prepare_simulation.jl#L136-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.perturbationOfTheWF!" href="#FLORIDyn.perturbationOfTheWF!"><code>FLORIDyn.perturbationOfTheWF!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">perturbationOfTheWF!(wf::WindFarm, wind::Wind)</code></pre><p>Apply stochastic perturbations to the wind field states in-place.</p><p>This function adds Gaussian noise to the wind field parameters to model measurement  uncertainty or natural variability in wind conditions. The perturbations are applied  conditionally based on the wind perturbation configuration and are added directly  to the wind farm state matrix.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm struct containing the state matrix <code>States_WF</code> to be perturbed</li><li><code>wind::Wind</code>: Wind configuration struct containing perturbation settings. See <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: The function modifies the wind farm state in-place</li></ul><p><strong>Behavior</strong></p><p>The function applies independent Gaussian perturbations to three wind field parameters:</p><p><strong>Velocity Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.vel == true</code></li><li><strong>Target</strong>: Column 1 of <code>wf.States_WF</code> (wind velocity [m/s])</li><li><strong>Noise</strong>: <code>wind.perturbation.vel_sigma * randn(nOP × nT)</code></li></ul><p><strong>Direction Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.dir == true</code></li><li><strong>Target</strong>: Column 2 of <code>wf.States_WF</code> (wind direction [degrees])</li><li><strong>Noise</strong>: <code>wind.perturbation.dir_sigma * randn(nOP × nT)</code></li></ul><p><strong>Turbulence Intensity Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.ti == true</code>  </li><li><strong>Target</strong>: Column 3 of <code>wf.States_WF</code> (turbulence intensity [-])</li><li><strong>Noise</strong>: <code>wind.perturbation.ti_sigma * randn(nOP × nT)</code></li></ul><p><strong>Mathematical Description</strong></p><p>For each enabled perturbation type, the function applies:</p><pre><code class="nohighlight hljs">States_WF[:, col] += σ × N(0,1)</code></pre><p>where:</p><ul><li><code>σ</code> is the standard deviation for the specific parameter</li><li><code>N(0,1)</code> is standard normal random noise with dimensions <code>(nOP × nT)</code></li><li><code>nOP</code> is the number of operational points per turbine</li><li><code>nT</code> is the total number of turbines</li></ul><p><strong>Notes</strong></p><ul><li>The function uses in-place modification (indicated by the <code>!</code> suffix)</li><li>Perturbations are applied independently to each operational point and turbine</li><li>The random noise follows a standard normal distribution scaled by the respective sigma values</li><li>Only enabled perturbation types (based on boolean flags) are applied</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/floridyn_cl.jl#L123-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.setUpTmpWFAndRun" href="#FLORIDyn.setUpTmpWFAndRun"><code>FLORIDyn.setUpTmpWFAndRun</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setUpTmpWFAndRun(set::Settings, wf::WindFarm, floris::Floris, wind::Wind)</code></pre><p>Execute FLORIS wake calculations for all turbines in a wind farm with wake interactions.</p><p>This function orchestrates the computation of wake effects for each turbine by setting up  temporary wind farm configurations that include influencing upstream turbines. It handles  both single turbine (no wake interactions) and multi-turbine scenarios with complex wake  interaction patterns.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings and configuration parameters</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, operational points, dependencies, and interpolation data<ul><li><code>wf.nT</code>: Number of turbines</li><li><code>wf.States_WF</code>: Wind field states matrix</li><li><code>wf.States_T</code>: Turbine states matrix</li><li><code>wf.States_OP</code>: Operational point states matrix</li><li><code>wf.dep</code>: Turbine dependency relationships (from <a href="#FLORIDyn.findTurbineGroups"><code>findTurbineGroups</code></a>)</li><li><code>wf.intOPs</code>: Interpolation weights and indices (from <a href="#FLORIDyn.interpolateOPs"><code>interpolateOPs</code></a>)</li><li><code>wf.posBase</code>: Base turbine positions [m]</li><li><code>wf.posNac</code>: Nacelle position offsets [m]</li><li><code>wf.D</code>: Rotor diameters [m]</li><li><code>wf.StartI</code>: Starting indices for each turbine&#39;s operational points</li></ul></li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations. See <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>wind::Wind</code>: Wind field configuration including shear properties. See <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>M::Matrix{Float64}</code>: Results matrix of size <code>(nT × 3)</code> where each row contains:<ul><li>Column 1: Total velocity reduction factor (product of all wake effects)</li><li>Column 2: Combined added turbulence intensity from all upstream turbines</li><li>Column 3: Effective wind speed at turbine [m/s]</li></ul></li><li><code>wf</code>: Updated wind farm object with modified fields:<ul><li><code>wf.Weight</code>: Normalized interpolation weights for each turbine</li><li><code>wf.red_arr</code>: Wake reduction matrix showing turbine-to-turbine wake effects</li></ul></li></ul><p><strong>Algorithm</strong></p><p>The function processes each turbine individually:</p><p><strong>Single Turbine Case (No Dependencies)</strong></p><ul><li>Directly calls FLORIS with the turbine&#39;s wind field state</li><li>No wake interactions considered</li><li>Results stored directly in output matrix</li></ul><p><strong>Multi-Turbine Case (With Dependencies)</strong></p><ol><li><strong>Temporary Configuration Setup</strong>: Creates temporary arrays sized for the target turbine plus all influencing turbines</li><li><strong>Interpolation Application</strong>: Uses precomputed interpolation weights to determine states at influencing turbine positions</li><li><strong>Coordinate Transformation</strong>: Applies wind direction-based coordinate transformations to account for spatial offsets</li><li><strong>FLORIS Execution</strong>: Runs wake model with the complete multi-turbine configuration</li><li><strong>Result Processing</strong>: Combines wake effects and normalizes weights</li></ol><p><strong>Mathematical Description</strong></p><p>For multi-turbine scenarios, the effective position of influencing turbines is computed as:</p><pre><code class="nohighlight hljs">tmp_Tpos[i] = base_position - R(φ) × [offset_x, offset_y, offset_z]</code></pre><p>where <code>R(φ)</code> is the rotation matrix for wind direction <code>φ</code>.</p><p>The total wake reduction is the product of individual wake effects:</p><pre><code class="nohighlight hljs">T_red = ∏ᵢ T_red_arr[i]</code></pre><p>Combined turbulence intensity follows root-sum-square combination:</p><pre><code class="nohighlight hljs">T_addedTI = √(∑ᵢ T_aTI_arr[i]²)</code></pre><p><strong>Wind Field Interpolation</strong></p><p>The function supports optional wind field interpolation via coefficient matrices:</p><ul><li><strong>Velocity interpolation</strong>: Uses <code>wf.C_Vel</code> if available</li><li><strong>Direction interpolation</strong>: Uses <code>wf.C_Dir</code> if available</li></ul><p><strong>Notes</strong></p><ul><li>The function modifies the wind farm object in-place, updating weight and reduction arrays</li><li>Interpolation weights are normalized to ensure proper weighting</li><li>Special handling for variable rotor diameter configurations</li><li>Coordinate transformations use the SOWFA to world conversion via <a href="#FLORIDyn.angSOWFA2world"><code>angSOWFA2world</code></a></li><li>The algorithm efficiently handles both simple single-turbine and complex multi-turbine wake scenarios</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/floridyn_cl.jl#L431-L509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.interpolateOPs" href="#FLORIDyn.interpolateOPs"><code>FLORIDyn.interpolateOPs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolateOPs(wf::WindFarm)</code></pre><p>Compute interpolation weights and indices for operational points affecting each turbine.</p><p>This function determines the optimal interpolation strategy for each turbine by identifying  the closest operational points from influencing upstream turbines. It computes weights and  indices that enable smooth interpolation of wind field states and turbine conditions at  arbitrary turbine positions.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine dependencies, operational point states, and positional data<ul><li><code>wf.nT</code>: Number of turbines</li><li><code>wf.StartI</code>: Starting indices for each turbine&#39;s operational points  </li><li><code>wf.dep</code>: Dependency relationships between turbines (from <a href="#FLORIDyn.findTurbineGroups"><code>findTurbineGroups</code></a>)</li><li><code>wf.States_OP</code>: Matrix of operational point states</li><li><code>wf.posBase</code>: Base positions of turbines [m]</li><li><code>wf.nOP</code>: Number of operational points per turbine</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>intOPs::Vector{Matrix{Float64}}</code>: Interpolation data for each turbine where <code>intOPs[i]</code> is an  <code>N×4</code> matrix for turbine <code>i</code> with <code>N</code> influencing turbines. Each row contains:<ul><li>Column 1: First operational point index</li><li>Column 2: Weight for first operational point</li><li>Column 3: Second operational point index  </li><li>Column 4: Weight for second operational point</li></ul></li></ul><p><strong>Algorithm</strong></p><p>For each turbine and its influencing upstream turbines:</p><ol><li><p><strong>Distance Calculation</strong>: Computes Euclidean distances from all operational points of  the influencing turbine to the target turbine position</p></li><li><p><strong>Interpolation Strategy Selection</strong>: Based on the closest operational point location:</p><ul><li><strong>First OP closest</strong>: Uses first and second operational points</li><li><strong>Last OP closest</strong>: Uses second-to-last and last operational points</li><li><strong>Interior OP closest</strong>: Uses the two closest operational points for optimal interpolation</li></ul></li><li><p><strong>Weight Computation</strong>: For interior cases, applies linear projection to determine interpolation weights:</p><pre><code class="language-julia hljs">d = dot(ab, ac) / dot(ab, ab)
weights = [1-d, d] # Clamped to [0,1]</code></pre></li></ol><p><strong>Mathematical Description</strong></p><p>The interpolation uses linear projection for weight computation:</p><pre><code class="nohighlight hljs">d = (b - a) · (c - a) / |b - a|²</code></pre><p>where:</p><ul><li><code>a</code>, <code>b</code> are positions of the two closest operational points</li><li><code>c</code> is the target turbine position</li><li><code>d</code> is the projection parameter (clamped to [0,1])</li></ul><p><strong>Notes</strong></p><ul><li>Edge cases (first/last operational points) use predefined weight combinations</li><li>Weights always sum to 1.0 for proper interpolation</li><li>The function handles variable numbers of influencing turbines per target turbine</li><li>Interpolation indices are global across the entire operational point matrix</li><li>This preprocessing enables efficient interpolation during simulation time steps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/floridyn_cl.jl#L317-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.iterateOPs!" href="#FLORIDyn.iterateOPs!"><code>FLORIDyn.iterateOPs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterateOPs!(::IterateOPs_basic, wf::WindFarm, sim::Sim, floris::Floris, floridyn::FloriDyn)</code></pre><p>Advance operational points through the wind field using time-marching dynamics.</p><p>This function implements the basic time-stepping algorithm for operational points (OPs) in the  FLORIDyn simulation. It advances all operational points through space based on wind velocities  and wake deflection effects, maintaining proper ordering and updating turbine states accordingly.</p><p><strong>Arguments</strong></p><ul><li><code>::IterateOPs_basic</code>: Dispatch type indicating the basic iteration algorithm</li><li><code>wf::WindFarm</code>: Wind farm object containing all turbine and operational point states. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a><ul><li><code>wf.States_OP</code>: Matrix of operational point states [x, y, z, <code>dw_pos</code>, <code>cw_x</code>, <code>cw_z</code>, ...]</li><li><code>wf.States_T</code>: Matrix of turbine states </li><li><code>wf.States_WF</code>: Matrix of wind field states [velocity, direction, <code>turbulence_intensity</code>, ...]</li><li><code>wf.StartI</code>: Starting indices for each turbine&#39;s operational points</li><li><code>wf.nT</code>: Number of turbines</li><li><code>wf.nOP</code>: Number of operational points per turbine</li><li><code>wf.D</code>: Rotor diameters [m]</li></ul></li><li><code>sim::Sim</code>: Simulation configuration object. See <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a><ul><li><code>sim.time_step</code>: Time step size [s]</li><li><code>sim.dyn.advection</code>: Advection scaling factor</li></ul></li><li><code>floris::Floris</code>: FLORIS model parameters for wake deflection calculations. See <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters. See <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>Algorithm</strong></p><p>The function performs the following steps for each time iteration:</p><p><strong>1. State Preservation</strong></p><p>Saves the current turbine operational point states before advancement to preserve boundary conditions.</p><p><strong>2. Spatial Advancement</strong></p><p><strong>Downwind Movement</strong></p><p>Advances operational points downstream based on local wind velocity:</p><pre><code class="nohighlight hljs">step_dw = Δt × U × advection_factor
OP_dw_position += step_dw</code></pre><p><strong>Crosswind Deflection</strong></p><p>Calculates wake centerline deflection using FLORIS model and updates crosswind positions:</p><pre><code class="nohighlight hljs">deflection = centerline(States_OP, States_T, States_WF, floris, D)
OP_cw_position = deflection</code></pre><p><strong>3. Coordinate System Transformation</strong></p><p>Converts local wind-aligned movements to world coordinates using wind direction:</p><pre><code class="nohighlight hljs">φ = angSOWFA2world(wind_direction)
x_world += cos(φ) × step_dw - sin(φ) × step_cw_x
y_world += sin(φ) × step_dw + cos(φ) × step_cw_x
z_world += step_cw_z</code></pre><p><strong>4. Temporal Shifting</strong></p><p>Uses circular shifting to advance the time history:</p><ul><li>Shifts all state matrices by one time step</li><li>Initializes new operational points with saved turbine states</li><li>Maintains temporal continuity of the simulation</li></ul><p><strong>5. Spatial Ordering</strong></p><p>Ensures operational points remain ordered by downstream position for each turbine:</p><ul><li>Sorts operational points by downstream position (<code>States_OP[:, 4]</code>)</li><li>Maintains consistency across all state matrices</li></ul><p><strong>Mathematical Description</strong></p><p>The coordinate transformation from wind-aligned to world coordinates follows:</p><pre><code class="nohighlight hljs">[x&#39;]   [cos(φ)  -sin(φ)] [step_dw ]
[y&#39;] = [sin(φ)   cos(φ)] [step_cw_x]</code></pre><p>where <code>φ</code> is the wind direction angle in world coordinates.</p><p><strong>Notes</strong></p><ul><li>The function modifies the wind farm object in-place (indicated by the <code>!</code> suffix)</li><li>Temporal shifting maintains a moving window of operational point history</li><li>Spatial ordering ensures downstream distance monotonicity for wake calculations</li><li>The algorithm handles both advection and deflection physics simultaneously</li><li>Coordinate transformations account for SOWFA wind direction conventions via <a href="#FLORIDyn.angSOWFA2world"><code>angSOWFA2world</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/iterate.jl#L4-L87">source</a></section><section><div><pre><code class="language-julia hljs">iterateOPs!(::IterateOPs_basic, wf::WindFarm, sim::Sim, floris::Floris, 
            floridyn::FloriDyn, buffers::IterateOPsBuffers)</code></pre><p>Allocation-free version of iterateOPs! that uses pre-allocated buffers.</p><p>This is the high-performance, zero-allocation version of the operational point iteration algorithm. All temporary arrays are pre-allocated in the buffers parameter to eliminate runtime allocations.</p><p><strong>Arguments</strong></p><ul><li><code>::IterateOPs_basic</code>: Dispatch type indicating the basic iteration algorithm</li><li><code>wf::WindFarm</code>: Wind farm object (same as standard version)</li><li><code>sim::Sim</code>: Simulation configuration object (same as standard version)  </li><li><code>floris::Floris</code>: FLORIS model parameters (same as standard version)</li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters (same as standard version)</li><li><code>buffers::IterateOPsBuffers</code>: Pre-allocated buffers for all temporary calculations. See <a href="../types/#FLORIDyn.IterateOPsBuffers"><code>IterateOPsBuffers</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>Performance Notes</strong></p><ul><li>Zero allocations during execution (after initial buffer setup)</li><li>Suitable for performance-critical applications and benchmarking</li><li>Buffers can be reused across multiple calls for maximum efficiency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/iterate.jl#L204-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.angSOWFA2world" href="#FLORIDyn.angSOWFA2world"><code>FLORIDyn.angSOWFA2world</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angSOWFA2world(deg_SOWFA)</code></pre><p>Convert wind direction angle from SOWFA convention to world coordinate system.</p><p>This function performs coordinate transformation between different wind direction conventions used in wind farm simulations. SOWFA (Simulator fOr Wind Farm Applications) uses a different angular reference system than the standard world coordinate system used in calculations.</p><p><strong>Arguments</strong></p><ul><li><code>deg_SOWFA::Real</code>: Wind direction angle in SOWFA convention [degrees]</li></ul><p><strong>Returns</strong></p><ul><li><code>rad_World::Float64</code>: Wind direction angle in world coordinate system [radians]</li></ul><p><strong>Coordinate System Conversion</strong></p><p>The transformation follows the relationship:</p><pre><code class="nohighlight hljs">θ_world = 270° - θ_SOWFA</code></pre><p><strong>SOWFA Convention</strong></p><ul><li>Wind direction angles are defined clockwise from a reference direction</li></ul><p><strong>World Convention</strong></p><ul><li>Wind direction angles are defined counterclockwise for mathematical calculations</li><li>Standard convention used in wake models and analytical computations</li></ul><p><strong>Mathematical Description</strong></p><p>The conversion process:</p><ol><li><strong>Angular transformation</strong>: <code>deg_World = 270 - deg_SOWFA</code></li><li><strong>Unit conversion</strong>: <code>rad_World = deg2rad(deg_World)</code></li></ol><p>The 270° offset accounts for the difference between clockwise (SOWFA) and  counterclockwise (world) angular conventions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Convert 90° SOWFA direction to world coordinates
world_angle = angSOWFA2world(90.0)  # Returns 3.141592... (180° in radians)

# Convert 0° SOWFA direction  
world_angle = angSOWFA2world(0.0)   # Returns 4.712388... (270° in radians)</code></pre><p><strong>Notes</strong></p><ul><li>The function handles the sign convention difference between coordinate systems</li><li>Output is always in radians for use in trigonometric calculations</li><li>This transformation is essential for proper wake modeling in wind farm simulations</li><li>The 270° offset ensures proper alignment between SOWFA and mathematical conventions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/floridyn_cl.jl#L4-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.runFLORIDyn" href="#FLORIDyn.runFLORIDyn"><code>FLORIDyn.runFLORIDyn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runFLORIDyn(set::Settings, wf::WindFarm, wind::Wind, sim::Sim, con::Con, 
            floridyn::FloriDyn, floris::Floris)</code></pre><p>Main entry point for the FLORIDyn closed-loop simulation.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings and configuration parameters.</li><li><code>wf::WindFarm</code>: See: <a href="../types/#FLORIDyn.WindFarm">WindFarm</a> simulation state, including turbine and wind farm states.</li><li><code>wind::Wind</code>: See: <a href="../settings/#FLORIDyn.Wind">Wind</a> field settings.</li><li><code>sim::Sim</code>: Simulation state or configuration object. See: <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li><li><code>con::Con</code>: Controller object or control parameters. See: <a href="../settings/#FLORIDyn.Con"><code>Con</code></a></li><li><code>floridyn::FloriDyn</code>: Parameters specific to the FLORIDyn model. See: <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li><li><code>floris::Floris</code>: Parameters specific to the FLORIS model. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li></ul><p><strong>Returns</strong></p><p>A tuple <code>(wf, md, mi)</code> containing:</p><ul><li><code>wf::WindFarm</code>: Updated simulation state with final turbine positions, wind field states, and operational point data</li><li><code>md::DataFrame</code>: Measurement data with columns:<ul><li><code>:Time</code>: Simulation time steps</li><li><code>:ForeignReduction</code>: Wind speed reduction factors (%) due to wake effects from other turbines</li><li><code>:AddedTurbulence</code>: Additional turbulence intensity (%) induced by upstream turbines</li><li><code>:EffWindSpeed</code>: Effective wind speed (m/s) at each turbine after wake effects</li><li><code>:FreeWindSpeed</code>: Free-stream wind speed (m/s) without wake interference</li><li><code>:PowerGen</code>: Generated electrical power (MW) for each turbine</li></ul></li><li><code>mi::Matrix</code>: Interaction matrix combining time data with turbine-to-turbine wake interaction coefficients                for each simulation step</li></ul><p><strong>Description</strong></p><p>Runs a closed-loop wind farm simulation using the FLORIDyn and FLORIS models,  applying control strategies and updating turbine states over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/f10914d9aa4973c6fea5eb45f154fd912faf2181/src/floridyn_cl/floridyn_cl.jl#L637-L669">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Exported Types</a><a class="docs-footer-nextpage" href="../settings/">Settings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 28 July 2025 11:53">Monday 28 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
