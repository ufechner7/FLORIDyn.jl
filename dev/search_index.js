var documenterSearchIndex = {"docs":
[{"location":"functions/#Exported-Functions","page":"Exported Functions","title":"Exported Functions","text":"","category":"section"},{"location":"functions/#Calculating-the-wind-directions","page":"Exported Functions","title":"Calculating the wind directions","text":"","category":"section"},{"location":"functions/#FLORIDyn.getWindDirT","page":"Exported Functions","title":"FLORIDyn.getWindDirT","text":"getWindDirT(::Direction_Constant, wind_dir, iT, _)\n\nReturn wind direction in SOWFA-degrees for the requested turbine(s).\n\nArguments\n\nwind_dir: The wind direction (scalar).\niT: Index or indices of the turbines (can be an integer or vector).\n_: Placeholder for unused argument.\n\nReturns\n\nphi: Array of wind direction values, same size as iT.\n\n\n\n\n\ngetWindDirT(::Direction_Constant_wErrorCov, wind_dir::WindDirType, iT, t)\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::WindDirType: WindDirType\niT: Vector of turbine indices (can be any indexable collection)\nt: Time step\n\nReturns\n\nphi: Vector of wind directions for the selected turbines, including random perturbation\n\n\n\n\n\ngetWindDirT(::Direction_Interpolation, wind_dir::AbstractMatrix, iT, t)\n\nDirection_Interpolation\n\nReturns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.\n\nArguments:\n\nwind_dir::Matrix: columns are time and phi (wind direction)\niT: single value or vector with turbine index/indices\nt: time of request\n\nReturns:\n\nphi: Vector of wind directions for each turbine in iT\n\n\n\n\n\ngetWindDirT(::Direction_Interpolation_wErrorCov, wind_dir::WindDirMatrix, iT, t)\n\nReturns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.\n\nArguments:\n\nwind_dir::WindDirMatrix: WindDirMatrix\niT: single value or vector with turbine index/indices\nt: time of request\n\nReturns:\n\nphi: Vector of wind directions for each turbine in iT\n\n\n\n\n\ngetWindDirT(::Direction_InterpTurbine, wind_dir::AbstractMatrix iT, t)\n\nReturn wind direction in SOWFA-degrees for the requested turbine(s).\n\nArguments\n\nwind_dir::Matrix: Each row is [time, phi_T0, phi_T1, ...].\n`iT: Index or indices of turbines.\nt: Time of request.\n\nReturns\n\nphi::Vector{Float64}: Wind direction(s) for the selected turbine(s) at time t.\n\n\n\n\n\ngetWindDirT(::Direction_InterpTurbine_wErrorCov, wind_dir::WindDirMatrix, iT, t)\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::WindDirMatrix: See: WindDirMatrix\niT: Index or indices of the turbines (can be integer or vector)\nt: Time of request (Float64)\n\nReturns\n\nphi: Wind direction(s) for requested turbine(s), perturbed with noise.\n\n\n\n\n\ngetWindDirT(::Direction_RW_with_Mean, wind_dir_now, wind_dir::WindDirTriple)\n\nReturns the wind direction at the respective turbine(s).\n\nArguments\n\nwind_dir_now: Current value (vector)\nwind_dir::WindDirTriple: WindDirTriple\n\nReturns\n\nphi: Updated wind direction(s) (vector)\n\n\n\n\n\ngetWindDirT(::Direction_RW_with_Mean, wind_dir::WindDirTriple, iT, t)\n\nRandom walk with mean reversion model for wind direction.\n\nArguments\n\n::Direction_RW_with_Mean: Direction mode indicator\nwind_dir::WindDirTriple: Wind direction data containing Init, CholSig, and MeanPull\niT: Turbine index or indices\nt: Time value (unused in this implementation)\n\nReturns\n\nphi: Wind direction(s) for the requested turbine(s)\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getWindDirT_EnKF","page":"Exported Functions","title":"FLORIDyn.getWindDirT_EnKF","text":"getWindDirT_EnKF(::Direction_EnKF_InterpTurbine, wind_dir::AbstractMatrix, iT, t)\n\nDirectionEnKFInterpTurbine\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::Matrix: Matrix where each row is [time, phi_T0, phi_T1, ... phi_Tn]\niT: Index or indices of the turbines (can be integer or vector)\nt: Time of request (scalar)\n\nReturns\n\nphi: Wind direction(s) at time t for turbine(s) iT\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getDataDir","page":"Exported Functions","title":"FLORIDyn.getDataDir","text":"getDataDir(set::Settings, wind::Wind, wf::WindFarm, t)\n\nRetrieve wind direction data for all turbines at the current simulation time.\n\nArguments\n\nset::Settings: Simulation settings containing the direction mode configuration\nwind::Wind: Wind field data structure containing direction information and input type\nwf::WindFarm: Wind farm object containing turbine states and configuration\nt: Current simulation time for temporal interpolation\n\nReturns\n\nphi: Wind direction values (typically in radians) for all turbines at the specified time\n\nDescription\n\nThis function reads wind direction data and returns the current wind direction angle (phi) for all  turbines in the wind farm. The function handles two different input modes:\n\nRandom Walk with Mean mode (wind.input_dir == \"RW_with_Mean\"): Uses the current wind farm  state from wf.States_WF[wf.StartI, 2] along with the wind direction data to compute direction.\nStandard temporal interpolation mode: Uses the wind direction data directly with temporal  interpolation for all turbines at the specified simulation time.\n\nThe function dispatches to getWindDirT with appropriate parameters based on the input mode,  ensuring consistent wind direction estimation across different modeling approaches.\n\nExamples\n\n# Get wind direction for all turbines at current simulation time\nphi = getDataDir(settings, wind_data, wind_farm, 100.0)\n\n# The returned phi contains direction values for all turbines\ndirection_turbine_1 = phi[1]\n\nNotes\n\nThe function automatically handles different wind input modes through conditional logic\nFor random walk mode, uses existing wind farm state as reference\nFor standard mode, performs temporal interpolation across all turbines\n\nSee also\n\ngetWindDirT: Underlying function for wind direction temporal interpolation\nSettings: Configuration structure containing direction mode settings\nWind: Wind field data structure containing direction information and input type\nWindFarm: Wind farm configuration structure\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.correctDir!","page":"Exported Functions","title":"FLORIDyn.correctDir!","text":"correctDir!(::Direction_All, set::Settings, wf::WindFarm, wind::Wind, t)\n\nApply direction correction to all turbines in the wind farm using the Direction_All strategy.\n\nArguments\n\n::Direction_All: The direction correction strategy type that applies corrections to all turbines\nset::Settings: Simulation settings containing the direction mode configuration\nwf::WindFarm: Wind farm object containing turbine states and configuration (modified in-place)\nwind::Wind: Wind field data structure containing direction information and input type\nt: Current simulation time for temporal interpolation\n\nReturns\n\nnothing: This function modifies the wind farm state in-place and returns nothing\n\nDescription\n\nThis function applies a direction correction using the Direction_All strategy, which updates the  wind direction for all turbines in the wind farm. The function performs the following operations:\n\nData Retrieval: Calls getDataDir to obtain current wind direction data for all turbines\nState Update: Updates the wind direction in the wind farm state (wf.States_WF[:, 2])\nOperational Point Orientation: If the state matrix has 4 columns, also updates the  operational point orientation (wf.States_WF[wf.StartI, 4]) to match the wind direction\n\nThe correction is applied uniformly to all turbines using the first direction value from the  retrieved direction data.\n\nExamples\n\n# Apply direction correction to all turbines\ncorrectDir!(Direction_All(), settings, wind_farm, wind_data, 100.0)\n\n# The wind farm state is modified in-place\ncurrent_direction = wind_farm.States_WF[1, 2]  # Updated direction for first turbine\n\nNotes\n\nThis function modifies the wind farm state in-place (indicated by the ! suffix)\nAll turbines receive the same direction correction value (phi[1])\nThe operational point orientation is only updated if the state matrix has 4 columns\nDirection values are typically in radians following standard wind engineering conventions\n\nSee also\n\ngetDataDir: Function for retrieving wind direction data\nDirection_All: Direction correction strategy type\nSettings: Simulation settings structure\nWindFarm: Wind farm configuration structure\nWind: Wind field data structure\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-velocity","page":"Exported Functions","title":"Calculating the wind velocity","text":"","category":"section"},{"location":"functions/#FLORIDyn.getDataVel","page":"Exported Functions","title":"FLORIDyn.getDataVel","text":"getDataVel(set::Settings, wind::Wind, wf::WindFarm, t, tmp_m, floris::Floris)\n\nRetrieve wind velocity data for all turbines at the current simulation time using various input modes.\n\nArguments\n\nset::Settings: Simulation settings containing the velocity mode configuration\nwind::Wind: Wind field data structure containing velocity information and input type\nwf::WindFarm: Wind farm object containing turbine states and configuration\nt: Current simulation time for temporal interpolation\ntmp_m: Temporary matrix containing reduction factors and other intermediate calculations\nfloris::Floris: FLORIS model parameters including wake model coefficients\n\nReturns\n\nu: Wind velocity values for all turbines at the specified time\nwind::Wind: Updated wind field data structure (may be modified for certain input modes)\n\nDescription\n\nThis function reads wind velocity data and returns the current wind speed (U) for all turbines  in the wind farm. The function handles multiple input modes through conditional logic:\n\nInterpolation and Integration mode (\"I_and_I\"): Uses getWindSpeedT with turbine positions,  wind direction, and FLORIS parameters. Applies wake effects reduction if the simulation time  exceeds the wind speed estimator offset.\nRandom Walk with Mean mode (\"RW_with_Mean\"): Uses the current wind farm state from  wf.States_WF[wf.StartI, 1] with the wind velocity model.\nEnsemble Kalman Filter mode (\"EnKF_InterpTurbine\"): Uses EnKF-based interpolation  at turbine locations via getWindSpeedT_EnKF.\nStandard temporal interpolation mode (default): Uses direct temporal interpolation  with getWindSpeedT for all turbines.\n\nExamples\n\n# Get wind velocity for all turbines at current simulation time\nu, updated_wind = getDataVel(settings, wind_data, wind_farm, 100.0, temp_matrix, floris_params)\n\n# The returned u contains velocity values for all turbines\nvelocity_turbine_1 = u[1]\n\nNotes\n\nThe function automatically handles different wind input modes through conditional logic\nFor IandI mode, wake effects are applied based on timing and reduction factors\nThe wind structure may be modified and returned for certain input modes\nVelocity values are in m/s\nWake reduction is only applied in IandI mode when sufficient time has elapsed\n\nSee also\n\nSettings: Simulation settings structure\nWind: Wind field data structure\nWindFarm: Wind farm configuration structure\nFloris: FLORIS model parameters structure\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-shear","page":"Exported Functions","title":"Calculating the wind shear","text":"","category":"section"},{"location":"functions/#FLORIDyn.getWindShearT","page":"Exported Functions","title":"FLORIDyn.getWindShearT","text":"getWindShearT(::Shear_Interpolation, WindShear::AbstractMatrix, z)\n\nCompute the wind shear at a given height z using the specified WindShear model.\n\nArguments\n\n::Shear_Interpolation: (Type only) Use interpolation to determine the wind shear.\nWindShear: A matrix describing the wind shear profile.\nz: The height (in meters) at which to evaluate the wind shear.\n\nReturns\n\nThe wind shear value at height z.\n\nREMARKS\n\nExpects a .csv file called \"WindShearProfile.csv\" with a normalized wind speed profile for different heights:\n\nz, (u_z/u0)\nz, (u_z/u0)\nz, (u_z/u0)\n\nThere is a linear interpolation between every pair. In case z is out of bounds the function will use the closest available setpoint.\n\n\n\n\n\ngetWindShearT(::Shear_PowerLaw, WindShear, z_norm)\n\nReturn the shear factor u_eff = shear * u_referenceHeight using the power law.\n\nArguments\n\nShear_PowerLaw: (type only, unused) Specifies that this method applies to the power law model\nWindShear: A struct of type (WindShear)(@ref)\nz0: Reference height (not used in this function)\nalpha: WindShear coefficient\nz_norm: Height(s) (can be scalar or array)\n\nReturns\n\nshear: The shear factor at the given height(s)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-turbulence","page":"Exported Functions","title":"Calculating the wind turbulence","text":"","category":"section"},{"location":"functions/#FLORIDyn.getDataTI","page":"Exported Functions","title":"FLORIDyn.getDataTI","text":"getDataTI(set::Settings, wind::Wind, wf::WindFarm, t) -> Vector\n\nRetrieve turbulence intensity data for all turbines at the current simulation time.\n\nThis function obtains turbulence intensity values for all turbines in the wind farm using the configured turbulence model and wind field data. It serves as a wrapper around the underlying turbulence intensity retrieval system.\n\nArguments\n\nset::Settings: Settings object containing simulation configuration\nset.turb_mode: Turbulence model configuration specifying the retrieval method\nwind::Wind: Wind configuration object containing turbulence intensity data\nwind.ti: Turbulence intensity data, parameters, or model configuration\nwf::WindFarm: Wind farm object containing turbine information\nwf.nT: Number of turbines in the wind farm\nt: Current simulation time for time-dependent turbulence intensity models\n\nReturns\n\nVector: Turbulence intensity values for all turbines (dimensionless, typically 0.05-0.25)\n\nBehavior\n\nThe function creates a vector of all turbine indices [1, 2, ..., nT] and retrieves the corresponding turbulence intensity values using the specified turbulence model. The actual retrieval method depends on the set.turb_mode configuration and can include:\n\nConstant turbulence intensity\nTime-interpolated values from data files\nTurbine-specific interpolation\nRandom walk models with covariance\n\nExample\n\n# Get turbulence intensity for all turbines at t=100s\nTI_values = getDataTI(settings, wind_config, wind_farm, 100.0)\nprintln(\"TI for turbine 1: \", TI_values[1])\n\nSee Also\n\ngetWindTiT: Underlying function for turbulence intensity retrieval\ncorrectTI!: Function that uses this data to update wind farm states\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getWindTiT","page":"Exported Functions","title":"FLORIDyn.getWindTiT","text":"getWindTiT(::TI_Constant, wind_ti::Number, iT, _)\n\nReturn turbulence intensity for the requested turbine(s).\n\nArguments\n\n::TI_Constant: type parameter to indicate constant wind turbulence\nwind_ti::Number: Constant value (turbulence intensity)\niT: Index or indices of the turbines\n_: will be ignored\n\nReturns\n\nTi: Array of turbulence intensity values for each turbine index\n\n\n\n\n\ngetWindTiT(::TI_Interpolation, wind_ti::AbstractMatrix, iT, t)\n\nInterpolates the wind turbulence intensity (TI) at a given time t using the specified TI_Interpolation method.\n\nArguments\n\n::TI_Interpolation: Use linear interpolation to calculate the turbulence intensity.\nwind_ti::Matrix: Matrix containing wind turbulence intensity values over time.\niT: Index/indices of the turbines (can be Int or array).\nt: The specific time at which to interpolate the turbulence intensity.\n\nReturns\n\nThe interpolated turbulence for the requested turbine(s) at time t.\n\nNotes\n\nThe function assumes that wind_ti contains the necessary data for interpolation as (time, TI) pairs (n×2 matrix)\nUniform interpolation version - all turbines experience the same changes.\n\n\n\n\n\ngetWindTiT(::TI_InterpTurbine, wind_ti::AbstractMatrix, iT, t)\n\nRetrieve the wind turbulence intensity (TI) for a specific turbine at a given time.\n\nArguments\n\n::TI_InterpTurbine: The turbulence intensity interpolation object for the turbine.\nwind_ti::AbstractMatrix: Matrix containing wind turbulence intensity values.\niT: Index of the turbine for which the TI is requested.\nt: Time at which the TI value is needed.\n\nReturns\n\nThe interpolated wind turbulence intensity value for the specified turbine at time t.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.correctTI!","page":"Exported Functions","title":"FLORIDyn.correctTI!","text":"correctTI!(::TI_None, set::Settings, wf::WindFarm, wind::Wind, t) -> Nothing\n\nUpdate turbulence intensity values in the wind farm state matrix without correction.\n\nThis function implements the \"no correction\" strategy for turbulence intensity, where  the wind farm turbulence intensity values are updated with fresh data from the wind  field model without applying any correction algorithms. It serves as the baseline  approach for turbulence intensity handling in FLORIDyn simulations.\n\nArguments\n\n::TI_None: Dispatch type indicating no turbulence intensity correction algorithm\nset::Settings: Settings object containing simulation configuration and turbulence model parameters\nset.turb_mode: Turbulence model configuration specifying the retrieval method\nwf::WindFarm: Wind farm object containing the state matrices to be updated\nwf.States_WF: Wind field states matrix where column 3 contains turbulence intensity values\nwf.StartI: Starting indices for each turbine's operational points\nwf.nT: Number of turbines\nwind::Wind: Wind configuration object containing turbulence intensity data\nwind.ti: Turbulence intensity data or model parameters\nt: Current simulation time for time-dependent turbulence intensity retrieval\n\nReturns\n\nNothing: The function modifies the wind farm state in-place\n\nBehavior\n\nRetrieves current turbulence intensity values for all turbines using getDataTI\nUpdates the wind farm state matrix wf.States_WF at rows wf.StartI and column 3\nTransposes the turbulence intensity vector to match the matrix structure\nProvides error handling for matrix update operations\n\nExample\n\n# Update turbulence intensity without correction at t=50s\ncorrectTI!(TI_None(), settings, wf, wind, 50.0)\n\n# The wind farm state matrix is now updated with new TI values\ncurrent_ti = wf.States_WF[wf.StartI, 3]\n\nNotes\n\nThe function modifies the wind farm object in-place (indicated by the ! suffix)\nThis \"no correction\" approach provides baseline turbulence intensity without  applying wake-induced corrections or measurement-based adjustments\nError handling ensures graceful failure if matrix dimensions are incompatible\n\nSee Also\n\ngetDataTI: Function used to retrieve turbulence intensity data\nTI_None: Dispatch type for no correction strategy\n\n\n\n\n\n","category":"function"},{"location":"functions/#Controller-functions","page":"Exported Functions","title":"Controller functions","text":"","category":"section"},{"location":"functions/#FLORIDyn.getYaw","page":"Exported Functions","title":"FLORIDyn.getYaw","text":"getYaw(::Yaw_SOWFA, ConYawData::AbstractMatrix, iT, t) -> Float64 or Vector{Float64}\n\nReturn the yaw angle at time t for the specified turbine(s) using linear interpolation.\n\nArguments\n\n::Yaw_SOWFA: Controller type dispatch parameter for SOWFA-style yaw control\nConYawData::Matrix{Float64}: Control data matrix where:\nFirst column contains time values (in seconds)\nSubsequent columns contain yaw angles for each turbine (in degrees)\niT: Turbine index or indices to query:\nInteger: Single turbine index (1-based)\nAbstractVector{<:Integer}: Vector of turbine indices for multiple turbines\nt::Real: Requested time (in seconds)\n\nReturns\n\nFloat64: Single yaw angle (in degrees) if iT is an integer\nVector{Float64}: Vector of yaw angles (in degrees) if iT is a vector\n\nBehavior\n\nInterpolation: Uses linear interpolation between time points with flat extrapolation\nOut-of-bounds handling: If t is outside the time range, the function:\nIssues a warning message\nClamps t to the nearest boundary (first or last time point)\nSingle time point: If only one time point exists, returns the corresponding yaw value directly\nError handling: Throws an error if iT is not an integer or vector of integers\n\nData Format\n\nThe con_yaw_data matrix should have the structure:\n\n[time₁  yaw₁₁  yaw₁₂  ...  yaw₁ₙ]\n[time₂  yaw₂₁  yaw₂₂  ...  yaw₂ₙ]\n[  ⋮      ⋮      ⋮    ⋱     ⋮  ]\n[timeₘ  yawₘ₁  yawₘ₂  ...  yawₘₙ]\n\nwhere m is the number of time steps and n is the number of turbines.\n\nExamples\n\n# Example control data: 3 time points, 2 turbines\ncon_yaw_data = [0.0  10.0  5.0;   # t=0s: T1=10°, T2=5°\n                1.0  15.0  10.0;  # t=1s: T1=15°, T2=10°\n                2.0  20.0  15.0]  # t=2s: T1=20°, T2=15°\n\n# Get yaw for turbine 1 at t=0.5s (interpolated)\nyaw1 = getYaw(Yaw_SOWFA(), con_yaw_data, 1, 0.5)  # Returns 12.5°\n\n# Get yaw for multiple turbines at t=1.5s\nyaws = getYaw(Yaw_SOWFA(), con_yaw_data, [1, 2], 1.5)  # Returns [17.5°, 12.5°]\n\n# Out-of-bounds time (will issue warning)\nyaw_oob = getYaw(Yaw_SOWFA(), con_yaw_data, 1, 5.0)  # Returns 20.0° with warning\n\nSee Also\n\nYaw_SOWFA: Controller type for SOWFA-style yaw control\nInterpolations.linear_interpolation: Underlying interpolation method used\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIS","page":"Exported Functions","title":"FLORIS","text":"","category":"section"},{"location":"functions/#FLORIDyn.calcCt","page":"Exported Functions","title":"FLORIDyn.calcCt","text":"calcCt(a, _)\n\nCalculate the thrust coefficient (Ct) for a wind turbine based on the axial induction factor a.\n\nArguments\n\na::Number: Axial induction factor, typically between 0 and 0.5.\n_: unused parameter\n\nReturns\n\nCt::Number: The calculated thrust coefficient.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.centerline","page":"Exported Functions","title":"FLORIDyn.centerline","text":"centerline(states_op, states_t, states_wf, floris, d_rotor)\n\nCompute the centerline wake properties for a wind farm simulation.\n\nArguments\n\nstates_op: Operational states of the turbines (e.g., yaw, pitch, etc.).\nstates_t: Turbine-specific states (e.g., rotor speed, torque, etc.).\nstates_wf: Wind farm-level states (e.g., wind direction, wind speed, etc.).\nfloris: Parameters for the FLORIS wake model.\nd_rotor: Rotor diameter or characteristic length scale.\n\nReturns\n\nThe computed centerline wake properties delta, which includes the deflection in the y and z directions.\n\nNotes\n\nThis function is part of the Gaussian wake model implementation.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.discretizeRotor","page":"Exported Functions","title":"FLORIDyn.discretizeRotor","text":"discretizeRotor(n_rp::Int)\n\nDiscretizes the rotor into a n_rp segments. The algorithm returns the normalized center location ∈ [-0.5, 0.5] and the relative area the segment represents.\n\nArguments\n\nn_rp::Int: The number of radial points to discretize the rotor into.\n\nReturns\n\nThe tuple (m_rp, w) where:\nm_rp: A matrix of size (nC, 3) where nC is the number of segments. The first column is all zeros,   the second and third columns contain the normalized radial positions.\nw: A vector of weights corresponding to each segment, summing to approximately 1.\n\nNotes\n\nThe algorithm returns the normalized center location in the range [-0.5, 0.5] and the relative area that each segment represents.\nThe isocell algorithm is used, which may not yield exactly n_rp cells but aims to achieve a similar number.\nFor details, see the publication by Masset et al.: Masset et al. (2009)\nThe choice of N1 = 3 is made here, but values of 4 or 5 are also viable options. The choice of 3 is close to optimal.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.init_states","page":"Exported Functions","title":"FLORIDyn.init_states","text":"init_states(set::Settings, wf::WindFarm, wind::Wind, init_turb, floris::Floris, sim::Sim)\n\nInitialize the state arrays for wind farm simulation using the Gaussian wake model.\n\nThis function sets up the initial conditions for turbines, observation points, and wind field  states based on the provided configuration parameters. It computes initial positions, wind  conditions, and wake properties for each turbine in the wind farm.\n\nArguments\n\nset::Settings: Simulation settings containing configuration options for velocity, direction, and turbulence models\nwf::WindFarm: Wind farm object containing turbine positions, dimensions, and state arrays (see WindFarm)\nwind::Wind: Wind conditions including velocity, direction, and turbulence intensity data (see Wind)\ninit_turb: Initial turbine state parameters (axial induction factor, yaw angle, turbulence intensity)\nfloris::Floris: FLORIS model parameters for wake calculations (see Floris)\nsim::Sim: Simulation parameters including time step and start time (see Sim)\n\nReturns\n\nA tuple (states_op, states_t, states_wf) containing:\n\nstates_op::Matrix: Observation point states with 3D coordinates and wake positions\nstates_t::Matrix: Turbine states including control parameters and operational conditions  \nstates_wf::Matrix: Wind field states with velocity, direction, and turbulence data\n\nDescription\n\nThe function performs the following initialization steps for each turbine:\n\nRetrieves wind field data (velocity, direction, turbulence intensity) based on the specified input methods\nInitializes wind field states at all observation points for the turbine\nCalculates downwind distances for wake coordinate system\nSets initial turbine states from provided parameters\nComputes crosswind wake deflections using the centerline function\nTransforms coordinates from wake-relative to world coordinate system\nUpdates observation point positions including turbine base and nacelle offsets\n\nNotes\n\nSupports multiple wind input methods including interpolation, constant values, and random walk models\nHandles both 3D and 4D wind field configurations (with optional orientation data)\nUses SOWFA coordinate system conventions for angle transformations\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getVars","page":"Exported Functions","title":"FLORIDyn.getVars","text":"getVars(rps::Union{Matrix, Adjoint}, c_t, yaw, ti, ti0, floris::Floris, d_rotor)\n\nCompute and return variables related to the Gaussian wake model for wind turbines.\n\nIn particular, it calculates the field width, the potential core data and the deflection. These values are needed for the calculation of the wake shape and speed  reduction. The values are based of the state of every individual OP.\n\nArguments\n\nrps: Matrix of reference points where the variables are evaluated.\nc_t: Thrust coefficient(s) for the turbine(s).\nyaw: Yaw angle(s) of the turbine(s) in radians or degrees.\nti: Turbulence intensity at the reference points.\nti0: Ambient turbulence intensity.\nfloris::Floris: FLORIS model parameters containing Gaussian wake model parameters (see Floris).\nd_rotor: Rotor diameter(s) of the turbine(s).\n\nReturns\n\nReturns the tuple\n\nsig_y::Vector: Gaussian variance in y direction (sqrt of)\nsig_z::Vector: Gaussian variance in z direction (sqrt of)\nc_t: Thrust coefficient, same as OP.Ct\nx_0: Potential core length\ndelta: Deflection\npc_y: Potential core boundary in y dir\npc_z: Potential core boundary in z dir\n\nSOURCES\n\n[1] Experimental and theoretical study of wind turbine wakes in yawed conditions - M. Bastankhah and F. Porté-Agel\n[2] Design and analysis of a spatially heterogeneous wake - A. Farrell, J. King et al.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getPower","page":"Exported Functions","title":"FLORIDyn.getPower","text":"getPower(wf::WindFarm, m::AbstractMatrix, floris::Floris, con::Con)\n\nCalculate the power output of wind turbines in a wind farm simulation.\n\nThis function computes the power generated by wind turbines based on their operational states, wind conditions, and control settings. It accounts for yaw angle effects and optional yaw range constraints using hyperbolic tangent functions for smooth operational limits.\n\nArguments\n\nwf::WindFarm: Wind farm object containing turbine states, dimensions, and operational data with current axial induction factors and yaw angles (see WindFarm)\nm::Matrix: Measurement or simulation data matrix where column 3 contains effective wind speeds at turbine locations [m/s]\nfloris::Floris: FLORIS model parameters containing air density, drivetrain efficiency, and power curve parameters (see Floris)\ncon::Con: Controller configuration object with yaw control settings and operational constraints (see Con)\n\nReturns\n\nP::Vector{Float64}: Power output for each turbine in the wind farm [W]\n\nDescription\n\nThe function calculates power using the standard wind turbine power equation with yaw corrections:\n\nP = 0.5 × ρ × A × Cp × U³ × η × cos(γ)^p_p × f_yaw_constraints\n\nWhere:\n\nρ is air density [floris.airDen] [kg/m³]\nA is rotor swept area π × (D/2)² [m²]\nCp is power coefficient calculated as 4a(1-a)² [-]\nU is effective wind speed from column 3 of matrix m [m/s]\nη is drivetrain efficiency [floris.eta] [-]\nγ is yaw angle [rad]\np_p is yaw power exponent [floris.p_p] [-]\nf_yaw_constraints is optional yaw range constraint factor [-]\n\nThe yaw constraint factor is applied when con.tanh_yaw is true:\n\nf_yaw_constraints = [0.5 × tanh((γ_max - γ) × 50) + 0.5] × \n                           [-0.5 × tanh((γ_min - γ) × 50) + 0.5]\n\nNotes\n\nPower coefficient is calculated from axial induction factor: Cp = 4a(1-a)²\nYaw effects reduce power output according to cos(γ)^p_p where p_p is typically 1.88\nOptional yaw range constraints use hyperbolic tangent functions with slope factor 50 for smooth transitions\nWhen con.tanh_yaw is enabled, power is smoothly constrained within [con.yawRangeMin, con.yawRangeMax]\nThe constraint functions approach step functions but provide smooth gradients for optimization\nAxial induction factors are extracted from wf.States_T[wf.StartI, 1] for current time step\nYaw angles are converted from degrees to radians internally\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.runFLORIS","page":"Exported Functions","title":"FLORIDyn.runFLORIS","text":"runFLORIS(set::Settings, location_t, states_wf, states_t, d_rotor, \n          floris::Floris, windshear::Union{Matrix, WindShear})\n\nExecute the FLORIS (FLOw Redirection and Induction in Steady State) wake model simulation for wind farm analysis.\n\nThis function performs a comprehensive wake analysis using the Gaussian wake model to calculate velocity reductions, turbulence intensity additions, and effective wind speeds at turbine locations. It accounts for wake interactions, rotor discretization, wind shear effects, and turbulence propagation.\n\nArguments\n\nset::Settings: Simulation settings containing configuration options for wind shear modeling\nlocation_t: Matrix of turbine positions [x, y, z] coordinates for each turbine [m]\nstates_wf: Wind field state matrix containing velocity, direction, and turbulence data\nstates_t: Turbine state matrix with axial induction factors, yaw angles, and turbulence intensities\nd_rotor: Vector of rotor diameters for each turbine [m]\nfloris::Floris: FLORIS model parameters containing wake model coefficients and rotor discretization settings (see Floris)\nwindshear: Wind shear profile data for vertical wind speed variation modeling, either a matrix or of type WindShear\n\nReturns\n\nA tuple (T_red_arr, T_aTI_arr, T_Ueff, T_weight) containing:\n\nT_red_arr::Vector{Float64}: Velocity reduction factors for each turbine [-]\nT_aTI_arr::Union{Vector{Float64}, Nothing}: Added turbulence intensity from upstream wakes [%]\nT_Ueff::Union{Float64, Nothing}: Effective wind speed at the last turbine location [m/s]\nT_weight::Union{Vector{Float64}, Nothing}: Gaussian weight factors for wake overlap calculations [-]\n\nDescription\n\nThe function performs the following computational steps:\n\n1. Rotor Discretization\n\nDiscretizes rotor planes into radial points using the isocell algorithm\nApplies yaw rotation transformations to rotor point coordinates\nHandles both active turbines (d_rotor > 0) and placeholder turbines\n\n2. Single Turbine Case\n\nFor single turbine simulations, only wind shear effects are calculated without wake interactions.\n\n3. Multi-Turbine Wake Analysis\n\nFor each upstream turbine affecting downstream turbines:\n\nCoordinate Transformations\n\nTransforms rotor points to wake coordinate system aligned with wind direction\nApplies rotational matrices for wind direction and turbine yaw angles\nFilters turbines based on minimum downstream distance (10 rotor diameters)\n\nWake Variable Calculations\n\nComputes wake expansion coefficients, potential core dimensions, and deflection using getVars\nCalculates crosswind wake positions and radial distances from wake centerline\nDetermines core region boundaries and near/far wake transitions\n\nVelocity Reduction Modeling\n\nApplies different deficit models for core region vs. Gaussian wake regions\nUses velocity deficit superposition for multiple wake interactions\nAccounts for yaw-induced wake deflection and asymmetry\n\nTurbulence Intensity Enhancement\n\nCalculates added turbulence intensity using empirical correlations\nApplies Gaussian weighting for spatial distribution of turbulence enhancement\nUses parameters kfa, kfb, kfc, kfd for turbulence intensity modeling\n\n4. Wind Shear Integration\n\nApplies vertical wind shear corrections to the downstream turbine\nUses wind shear profile data for realistic boundary layer effects\n\nMathematical Models\n\nThe function implements several key wake modeling equations:\n\nVelocity Deficit: Based on Gaussian wake theory with yaw corrections Deflection: Uses analytical wake deflection models for yawed turbines   Turbulence: Empirical correlations for wake-added turbulence intensity Superposition: Linear superposition of velocity deficits from multiple wakes\n\nNotes\n\nUses SOWFA (Simulator for Offshore Wind Farm Applications) coordinate conventions\nImplements state-of-the-art Gaussian wake model with yaw considerations\nSupports both research and engineering applications for wind farm optimization\nComputational complexity scales as O(N²) for N turbines due to wake interactions\nRequires proper initialization of turbine states and wind field conditions\n\nReferences\n\nBastankhah, M. and Porté-Agel, F. (2016). Experimental and theoretical study of wind turbine wakes in yawed conditions\nNiayifar, A. and Porté-Agel, F. (2016). Analytical modeling of wind farms: A new approach for power prediction\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn","page":"Exported Functions","title":"FLORIDyn","text":"","category":"section"},{"location":"functions/#FLORIDyn.initSimulation","page":"Exported Functions","title":"FLORIDyn.initSimulation","text":"initSimulation(wf::Union{Nothing, WindFarm}, sim::Sim)\n\nInitialize or load a wind farm simulation state based on simulation settings.\n\nThis function handles the initialization phase of a wind farm simulation by either saving  the current initialized state to disk or loading a previously saved state, depending on  the simulation configuration.\n\nArguments\n\nwf::Union{Nothing, WindFarm}: Wind farm object containing the initialized simulation state, or Nothing if no state is available. See WindFarm\nsim::Sim: Simulation configuration object containing initialization settings and file paths. See Sim\n\nReturns\n\nwf::Union{Nothing, WindFarm}: The wind farm state, either the original input state (for \"init\" mode) or a loaded state from disk (for \"load\" mode)\n\nBehavior\n\nThe function operates in two modes based on sim.init:\n\n\"init\" Mode\n\nUses the provided wind farm state as-is\nIf sim.save_init_state is true, saves the current state to \"T_init.jld2\" in the specified data directory\nLogs the save operation for user feedback\n\n\"load\" Mode\n\nAttempts to load a previously saved wind farm state from \"T_init.jld2\"\nFalls back to the provided state if loading fails (with warning)\nHandles file I/O errors gracefully\n\nFile Operations\n\nSave path: $(sim.path_to_data)/T_init.jld2\nFormat: JLD2 binary format for efficient Julia object serialization\nError handling: Loading failures produce warnings but do not halt execution\n\nNotes\n\nThe function is case-insensitive for the initialization mode string\nFile operations use the path specified in sim.path_to_data\nLoading errors are caught and logged as warnings, allowing simulation to proceed with the original state\nThis mechanism enables reproducible simulations by preserving and reusing initial conditions\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.findTurbineGroups","page":"Exported Functions","title":"FLORIDyn.findTurbineGroups","text":"findTurbineGroups(wf::WindFarm, floridyn::FloriDyn)\n\nDetermine wake interaction dependencies between turbines in a wind farm.\n\nThis function analyzes the spatial relationships between turbines to identify which turbines  are affected by the wakes of upstream turbines. It uses coordinate transformations to the  wind-aligned reference frame and geometric criteria to determine wake interactions.\n\nArguments\n\nwf::WindFarm: Wind farm object containing turbine positions, operational points, and wind field states. See WindFarm\nfloridyn::FloriDyn: FLORIDyn model parameters containing wake interaction thresholds. See FloriDyn\n\nReturns\n\nvv_dep::Vector{Vector{Int64}}: A vector of vectors where vv_dep[i] contains the indices of all turbines  that affect turbine i through wake interactions. Each inner vector lists the upstream turbine indices  that influence the wake conditions at the corresponding turbine.\n\nAlgorithm\n\nCoordinate Transformation: For each turbine pair, transforms coordinates to a wind-aligned frame using the closest operational point\nWake Zone Detection: Applies geometric criteria to determine if a downstream turbine lies within the wake zone:\nUpstream extent: r₁[1] ≥ -uw × D[iT] (allowing for slight upstream influence)\nDownstream extent: r₁[1] ≤ dw × D[iT] (wake extends downstream)  \nLateral extent: |r₁[2]| ≤ cw × D[iT] (wake width constraint)\nDependency Matrix: Constructs a boolean dependency matrix and extracts indices for each turbine\n\nMathematical Description\n\nThe wake interaction criteria are evaluated in the wind-aligned coordinate system:\n\nr₁ = R(φ) × (rₒₚ - rₜᵤᵣᵦ)\n\nwhere:\n\nR(φ) is the rotation matrix for wind direction angle φ\nrₒₚ is the position of the closest operational point from the upstream turbine\nrₜᵤᵣᵦ is the position of the downstream turbine being evaluated\n\nNotes\n\nThe function uses the closest operational point from each upstream turbine to determine wind direction\nWake zones are defined as multiples of rotor diameter using the FLORIDyn parameters\nSelf-interaction (turbine affecting itself) is explicitly excluded\nThe coordinate transformation accounts for the SOWFA wind direction convention\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.prepareSimulation","page":"Exported Functions","title":"FLORIDyn.prepareSimulation","text":"prepareSimulation(set::Settings, wind::Wind, con::Con, floridyn::FloriDyn, floris::Floris, turbProp, sim::Sim)\n\nPrepares the simulation environment for a wind farm analysis using the provided settings and parameters.\n\nArguments\n\nset::Settings: Simulation settings containing configuration options.\nwind::Wind: Wind conditions or wind field data. See: Wind \ncon::Con: Controller parameters of the turbines.  See: Con\nfloridyn::FloriDyn: Parameters specific to the FLORIDyn model. See: FloriDyn\nfloris::Floris: Parameters specific to the FLORIS model. See: Floris\nturbProp: Properties of the turbines involved in the simulation.\nsim::Sim: Simulation-specific parameters or state. See: Sim\n\nArguments that get modified\n\nwind: Updated with wind velocity, direction, turbulence intensity, and shear profile.\ncon: Updated with yaw data.\nsim: Updated with the number of simulation steps.\nfloris: May include additional parameters for the FLORIS model.\n\nReturns\n\nReturns the tuple (wf, wind, sim, con, floris) where:\nwf: Wind farm struct containing turbine states and positions. See: WindFarm\nwind: Updated wind conditions.\nsim: Updated simulation parameters.\ncon: Updated controller parameters.\nfloris: Parameters for the FLORIS model.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.perturbationOfTheWF!","page":"Exported Functions","title":"FLORIDyn.perturbationOfTheWF!","text":"perturbationOfTheWF!(wf::WindFarm, wind::Wind)\n\nApply stochastic perturbations to the wind field states in-place.\n\nThis function adds Gaussian noise to the wind field parameters to model measurement  uncertainty or natural variability in wind conditions. The perturbations are applied  conditionally based on the wind perturbation configuration and are added directly  to the wind farm state matrix.\n\nArguments\n\nwf::WindFarm: Wind farm struct containing the state matrix States_WF to be perturbed\nwind::Wind: Wind configuration struct containing perturbation settings. See Wind\n\nReturns\n\nnothing: The function modifies the wind farm state in-place\n\nBehavior\n\nThe function applies independent Gaussian perturbations to three wind field parameters:\n\nVelocity Perturbation\n\nCondition: wind.perturbation.vel == true\nTarget: Column 1 of wf.States_WF (wind velocity [m/s])\nNoise: wind.perturbation.vel_sigma * randn(nOP × nT)\n\nDirection Perturbation\n\nCondition: wind.perturbation.dir == true\nTarget: Column 2 of wf.States_WF (wind direction [degrees])\nNoise: wind.perturbation.dir_sigma * randn(nOP × nT)\n\nTurbulence Intensity Perturbation\n\nCondition: wind.perturbation.ti == true  \nTarget: Column 3 of wf.States_WF (turbulence intensity [-])\nNoise: wind.perturbation.ti_sigma * randn(nOP × nT)\n\nMathematical Description\n\nFor each enabled perturbation type, the function applies:\n\nStates_WF[:, col] += σ × N(0,1)\n\nwhere:\n\nσ is the standard deviation for the specific parameter\nN(0,1) is standard normal random noise with dimensions (nOP × nT)\nnOP is the number of operational points per turbine\nnT is the total number of turbines\n\nNotes\n\nThe function uses in-place modification (indicated by the ! suffix)\nPerturbations are applied independently to each operational point and turbine\nThe random noise follows a standard normal distribution scaled by the respective sigma values\nOnly enabled perturbation types (based on boolean flags) are applied\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.setUpTmpWFAndRun","page":"Exported Functions","title":"FLORIDyn.setUpTmpWFAndRun","text":"setUpTmpWFAndRun(set::Settings, wf::WindFarm, floris::Floris, wind::Wind)\n\nExecute FLORIS wake calculations for all turbines in a wind farm with wake interactions.\n\nThis function orchestrates the computation of wake effects for each turbine by setting up  temporary wind farm configurations that include influencing upstream turbines. It handles  both single turbine (no wake interactions) and multi-turbine scenarios with complex wake  interaction patterns.\n\nArguments\n\nset::Settings: Simulation settings and configuration parameters\nwf::WindFarm: Wind farm object containing turbine positions, operational points, dependencies, and interpolation data\nwf.nT: Number of turbines\nwf.States_WF: Wind field states matrix\nwf.States_T: Turbine states matrix\nwf.States_OP: Operational point states matrix\nwf.dep: Turbine dependency relationships (from findTurbineGroups)\nwf.intOPs: Interpolation weights and indices (from interpolateOPs)\nwf.posBase: Base turbine positions [m]\nwf.posNac: Nacelle position offsets [m]\nwf.D: Rotor diameters [m]\nwf.StartI: Starting indices for each turbine's operational points\nfloris::Floris: FLORIS model parameters for wake calculations. See Floris\nwind::Wind: Wind field configuration including shear properties. See Wind\n\nReturns\n\nM::Matrix{Float64}: Results matrix of size (nT × 3) where each row contains:\nColumn 1: Total velocity reduction factor (product of all wake effects)\nColumn 2: Combined added turbulence intensity from all upstream turbines\nColumn 3: Effective wind speed at turbine [m/s]\nwf: Updated wind farm object with modified fields:\nwf.Weight: Normalized interpolation weights for each turbine\nwf.red_arr: Wake reduction matrix showing turbine-to-turbine wake effects\n\nAlgorithm\n\nThe function processes each turbine individually:\n\nSingle Turbine Case (No Dependencies)\n\nDirectly calls FLORIS with the turbine's wind field state\nNo wake interactions considered\nResults stored directly in output matrix\n\nMulti-Turbine Case (With Dependencies)\n\nTemporary Configuration Setup: Creates temporary arrays sized for the target turbine plus all influencing turbines\nInterpolation Application: Uses precomputed interpolation weights to determine states at influencing turbine positions\nCoordinate Transformation: Applies wind direction-based coordinate transformations to account for spatial offsets\nFLORIS Execution: Runs wake model with the complete multi-turbine configuration\nResult Processing: Combines wake effects and normalizes weights\n\nMathematical Description\n\nFor multi-turbine scenarios, the effective position of influencing turbines is computed as:\n\ntmp_Tpos[i] = base_position - R(φ) × [offset_x, offset_y, offset_z]\n\nwhere R(φ) is the rotation matrix for wind direction φ.\n\nThe total wake reduction is the product of individual wake effects:\n\nT_red = ∏ᵢ T_red_arr[i]\n\nCombined turbulence intensity follows root-sum-square combination:\n\nT_addedTI = √(∑ᵢ T_aTI_arr[i]²)\n\nWind Field Interpolation\n\nThe function supports optional wind field interpolation via coefficient matrices:\n\nVelocity interpolation: Uses wf.C_Vel if available\nDirection interpolation: Uses wf.C_Dir if available\n\nNotes\n\nThe function modifies the wind farm object in-place, updating weight and reduction arrays\nInterpolation weights are normalized to ensure proper weighting\nSpecial handling for variable rotor diameter configurations\nCoordinate transformations use the SOWFA to world conversion via angSOWFA2world\nThe algorithm efficiently handles both simple single-turbine and complex multi-turbine wake scenarios\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.interpolateOPs","page":"Exported Functions","title":"FLORIDyn.interpolateOPs","text":"interpolateOPs(wf::WindFarm)\n\nCompute interpolation weights and indices for operational points affecting each turbine.\n\nThis function determines the optimal interpolation strategy for each turbine by identifying  the closest operational points from influencing upstream turbines. It computes weights and  indices that enable smooth interpolation of wind field states and turbine conditions at  arbitrary turbine positions.\n\nArguments\n\nwf::WindFarm: Wind farm object containing turbine dependencies, operational point states, and positional data\nwf.nT: Number of turbines\nwf.StartI: Starting indices for each turbine's operational points  \nwf.dep: Dependency relationships between turbines (from findTurbineGroups)\nwf.States_OP: Matrix of operational point states\nwf.posBase: Base positions of turbines [m]\nwf.nOP: Number of operational points per turbine\n\nReturns\n\nintOPs::Vector{Matrix{Float64}}: Interpolation data for each turbine where intOPs[i] is an  N×4 matrix for turbine i with N influencing turbines. Each row contains:\nColumn 1: First operational point index\nColumn 2: Weight for first operational point\nColumn 3: Second operational point index  \nColumn 4: Weight for second operational point\n\nAlgorithm\n\nFor each turbine and its influencing upstream turbines:\n\nDistance Calculation: Computes Euclidean distances from all operational points of  the influencing turbine to the target turbine position\nInterpolation Strategy Selection: Based on the closest operational point location:\nFirst OP closest: Uses first and second operational points\nLast OP closest: Uses second-to-last and last operational points\nInterior OP closest: Uses the two closest operational points for optimal interpolation\nWeight Computation: For interior cases, applies linear projection to determine interpolation weights:\nd = dot(ab, ac) / dot(ab, ab)\nweights = [1-d, d] # Clamped to [0,1]\n\nMathematical Description\n\nThe interpolation uses linear projection for weight computation:\n\nd = (b - a) · (c - a) / |b - a|²\n\nwhere:\n\na, b are positions of the two closest operational points\nc is the target turbine position\nd is the projection parameter (clamped to [0,1])\n\nNotes\n\nEdge cases (first/last operational points) use predefined weight combinations\nWeights always sum to 1.0 for proper interpolation\nThe function handles variable numbers of influencing turbines per target turbine\nInterpolation indices are global across the entire operational point matrix\nThis preprocessing enables efficient interpolation during simulation time steps\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.iterateOPs!","page":"Exported Functions","title":"FLORIDyn.iterateOPs!","text":"iterateOPs!(::IterateOPs_basic, wf::WindFarm, sim::Sim, floris::Floris, floridyn::FloriDyn)\n\nAdvance operational points through the wind field using time-marching dynamics.\n\nThis function implements the basic time-stepping algorithm for operational points (OPs) in the  FLORIDyn simulation. It advances all operational points through space based on wind velocities  and wake deflection effects, maintaining proper ordering and updating turbine states accordingly.\n\nArguments\n\n::IterateOPs_basic: Dispatch type indicating the basic iteration algorithm\nwf::WindFarm: Wind farm object containing all turbine and operational point states. See WindFarm\nwf.States_OP: Matrix of operational point states [x, y, z, dw_pos, cw_x, cw_z, ...]\nwf.States_T: Matrix of turbine states \nwf.States_WF: Matrix of wind field states [velocity, direction, turbulence_intensity, ...]\nwf.StartI: Starting indices for each turbine's operational points\nwf.nT: Number of turbines\nwf.nOP: Number of operational points per turbine\nwf.D: Rotor diameters [m]\nsim::Sim: Simulation configuration object. See Sim\nsim.time_step: Time step size [s]\nsim.dyn.advection: Advection scaling factor\nfloris::Floris: FLORIS model parameters for wake deflection calculations. See Floris\nfloridyn::FloriDyn: FLORIDyn model parameters. See FloriDyn\n\nReturns\n\nnothing\n\nAlgorithm\n\nThe function performs the following steps for each time iteration:\n\n1. State Preservation\n\nSaves the current turbine operational point states before advancement to preserve boundary conditions.\n\n2. Spatial Advancement\n\nDownwind Movement\n\nAdvances operational points downstream based on local wind velocity:\n\nstep_dw = Δt × U × advection_factor\nOP_dw_position += step_dw\n\nCrosswind Deflection\n\nCalculates wake centerline deflection using FLORIS model and updates crosswind positions:\n\ndeflection = centerline(States_OP, States_T, States_WF, floris, D)\nOP_cw_position = deflection\n\n3. Coordinate System Transformation\n\nConverts local wind-aligned movements to world coordinates using wind direction:\n\nφ = angSOWFA2world(wind_direction)\nx_world += cos(φ) × step_dw - sin(φ) × step_cw_x\ny_world += sin(φ) × step_dw + cos(φ) × step_cw_x\nz_world += step_cw_z\n\n4. Temporal Shifting\n\nUses circular shifting to advance the time history:\n\nShifts all state matrices by one time step\nInitializes new operational points with saved turbine states\nMaintains temporal continuity of the simulation\n\n5. Spatial Ordering\n\nEnsures operational points remain ordered by downstream position for each turbine:\n\nSorts operational points by downstream position (States_OP[:, 4])\nMaintains consistency across all state matrices\n\nMathematical Description\n\nThe coordinate transformation from wind-aligned to world coordinates follows:\n\n[x']   [cos(φ)  -sin(φ)] [step_dw ]\n[y'] = [sin(φ)   cos(φ)] [step_cw_x]\n\nwhere φ is the wind direction angle in world coordinates.\n\nNotes\n\nThe function modifies the wind farm object in-place (indicated by the ! suffix)\nTemporal shifting maintains a moving window of operational point history\nSpatial ordering ensures downstream distance monotonicity for wake calculations\nThe algorithm handles both advection and deflection physics simultaneously\nCoordinate transformations account for SOWFA wind direction conventions via angSOWFA2world\n\n\n\n\n\niterateOPs!(::IterateOPs_basic, wf::WindFarm, sim::Sim, floris::Floris, \n            floridyn::FloriDyn, buffers::IterateOPsBuffers)\n\nAllocation-free version of iterateOPs! that uses pre-allocated buffers.\n\nThis is the high-performance, zero-allocation version of the operational point iteration algorithm. All temporary arrays are pre-allocated in the buffers parameter to eliminate runtime allocations.\n\nArguments\n\n::IterateOPs_basic: Dispatch type indicating the basic iteration algorithm\nwf::WindFarm: Wind farm object (same as standard version)\nsim::Sim: Simulation configuration object (same as standard version)  \nfloris::Floris: FLORIS model parameters (same as standard version)\nfloridyn::FloriDyn: FLORIDyn model parameters (same as standard version)\nbuffers::IterateOPsBuffers: Pre-allocated buffers for all temporary calculations. See IterateOPsBuffers.\n\nReturns\n\nnothing\n\nPerformance Notes\n\nZero allocations during execution (after initial buffer setup)\nSuitable for performance-critical applications and benchmarking\nBuffers can be reused across multiple calls for maximum efficiency\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.angSOWFA2world","page":"Exported Functions","title":"FLORIDyn.angSOWFA2world","text":"angSOWFA2world(deg_SOWFA)\n\nConvert wind direction angle from SOWFA convention to world coordinate system.\n\nThis function performs coordinate transformation between different wind direction conventions used in wind farm simulations. SOWFA (Simulator fOr Wind Farm Applications) uses a different angular reference system than the standard world coordinate system used in calculations.\n\nArguments\n\ndeg_SOWFA::Real: Wind direction angle in SOWFA convention [degrees]\n\nReturns\n\nrad_World::Float64: Wind direction angle in world coordinate system [radians]\n\nCoordinate System Conversion\n\nThe transformation follows the relationship:\n\nθ_world = 270° - θ_SOWFA\n\nSOWFA Convention\n\nWind direction angles are defined clockwise from a reference direction\n\nWorld Convention\n\nWind direction angles are defined counterclockwise for mathematical calculations\nStandard convention used in wake models and analytical computations\n\nMathematical Description\n\nThe conversion process:\n\nAngular transformation: deg_World = 270 - deg_SOWFA\nUnit conversion: rad_World = deg2rad(deg_World)\n\nThe 270° offset accounts for the difference between clockwise (SOWFA) and  counterclockwise (world) angular conventions.\n\nExamples\n\n# Convert 90° SOWFA direction to world coordinates\nworld_angle = angSOWFA2world(90.0)  # Returns 3.141592... (180° in radians)\n\n# Convert 0° SOWFA direction  \nworld_angle = angSOWFA2world(0.0)   # Returns 4.712388... (270° in radians)\n\nNotes\n\nThe function handles the sign convention difference between coordinate systems\nOutput is always in radians for use in trigonometric calculations\nThis transformation is essential for proper wake modeling in wind farm simulations\nThe 270° offset ensures proper alignment between SOWFA and mathematical conventions\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.runFLORIDyn","page":"Exported Functions","title":"FLORIDyn.runFLORIDyn","text":"runFLORIDyn(set::Settings, wf::WindFarm, wind::Wind, sim::Sim, con::Con, \n            floridyn::FloriDyn, floris::Floris)\n\nMain entry point for the FLORIDyn closed-loop simulation.\n\nArguments\n\nset::Settings: Simulation settings and configuration parameters.\nwf::WindFarm: See: WindFarm simulation state, including turbine and wind farm states.\nwind::Wind: See: Wind field settings.\nsim::Sim: Simulation state or configuration object. See: Sim\ncon::Con: Controller object or control parameters. See: Con\nfloridyn::FloriDyn: Parameters specific to the FLORIDyn model. See: FloriDyn\nfloris::Floris: Parameters specific to the FLORIS model. See: Floris\n\nReturns\n\nA tuple (wf, md, mi) containing:\n\nwf::WindFarm: Updated simulation state with final turbine positions, wind field states, and operational point data\nmd::DataFrame: Measurement data with columns:\n:Time: Simulation time steps\n:ForeignReduction: Wind speed reduction factors (%) due to wake effects from other turbines\n:AddedTurbulence: Additional turbulence intensity (%) induced by upstream turbines\n:EffWindSpeed: Effective wind speed (m/s) at each turbine after wake effects\n:FreeWindSpeed: Free-stream wind speed (m/s) without wake interference\n:PowerGen: Generated electrical power (MW) for each turbine\nmi::Matrix: Interaction matrix combining time data with turbine-to-turbine wake interaction coefficients                for each simulation step\n\nDescription\n\nRuns a closed-loop wind farm simulation using the FLORIDyn and FLORIS models,  applying control strategies and updating turbine states over time.\n\n\n\n\n\n","category":"function"},{"location":"settings/#Simulation-settings","page":"Settings","title":"Simulation settings","text":"","category":"section"},{"location":"settings/#Introduction","page":"Settings","title":"Introduction","text":"","category":"section"},{"location":"settings/","page":"Settings","title":"Settings","text":"The settings are defined in a .yaml file in the folder data. The function setup converts them into three settings structs, containing strings and numbers. The constructor Settings creates a struct of marker types from these settings structs. ","category":"page"},{"location":"settings/","page":"Settings","title":"Settings","text":"For each of these yaml files there must be a folder with the same name (without the .yaml extension) in the data directory. In this folder the required .csv files must be stored.","category":"page"},{"location":"settings/#Types-created-from-the-yaml-file","page":"Settings","title":"Types created from the yaml file","text":"","category":"section"},{"location":"settings/#FLORIDyn.Sim","page":"Settings","title":"FLORIDyn.Sim","text":"Sim\n\nA mutable struct representing the simulation settings.\n\nFields\n\nfloris::String: The name of the FLORIS model to be used.\nstart_time::Int64: The start time of the simulation in seconds.\nend_time::Int64: The end time of the simulation in seconds.\ntime_step::Int64: The time step for the simulation in seconds.\nsim_step::Union{Nothing, Int64}: Optional simulation step size.\nn_sim_steps::Union{Nothing, Int64}: Optional number of simulation steps.\nrotor_discret::String: The rotor discretization method, e.g., \"Uniform\", \"Gaussian\".\nrotor_points::Int64: The number of rotor points for discretization.\ndyn::Dyn: The dynamic settings for the simulation.\ninit::String: The initialization method, e.g., \"init\", \"load\".\npath_to_data::String: The path to the directory where simulation data is stored.\nsave_init_state::Bool: Whether to save the initial state of the simulation.\nsave_final_state::Bool: Whether to save the final state of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Wind","page":"Settings","title":"FLORIDyn.Wind","text":"Wind\n\nA mutable struct representing wind settings.\n\nFields\n\ninput_vel::String: The type of wind velocity input, e.g., \"Constant\", \"Interpolation\".\ninput_dir::String: The type of wind direction input, e.g., \"Constant\", \"Interpolation\".\ninput_ti::String: The type of turbulence intensity input, e.g., \"Constant\", \"Interpolation\".\ninput_shear::String: The type of wind shear input, e.g., \"PowerLaw\", \"Interpolation\".\ncorrection::WindCorrection: Settings for wind corrections.\nperturbation::WindPerturbation: Settings for wind perturbations.\nvel::Union{Nothing, Float64}: Optional wind velocity value.\ndir::Union{Nothing, Matrix{Float64}, WindDirMatrix, WindDirType, WindDirTriple}: Optional wind direction matrix or covariance data.\nti::Union{Nothing, Float64}: Optional turbulence intensity value.\nshear::Union{Nothing, WindShear}: Optional wind shear profile.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Con","page":"Settings","title":"FLORIDyn.Con","text":"Con\n\nA mutable struct for configuration settings.\n\nFields\n\nyaw::String: The yaw control strategy, e.g., \"Constant\", \"Interpolation\".\nyaw_data::Union{Nothing, Matrix{Float64}}: Optional yaw data matrix.\ntanh_yaw::Bool: Whether to use hyperbolic tangent yaw control.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Floris","page":"Settings","title":"FLORIDyn.Floris","text":"Floris\n\nA mutable struct representing the settings for the FLORIDyn simulation. \n\nFields\n\nalpha::Float64: The alpha parameter for the FLORIS model.\nbeta::Float64: The beta parameter for the FLORIS model.\nk_a::Float64: The k_a parameter for the FLORIS model.\nk_b::Float64: The k_b parameter for the FLORIS model.\nk_fa::Float64: The k_fa parameter for the FLORIS model.\nk_fb::Float64: The k_fb parameter for the FLORIS model.\nk_fc::Float64: The k_fc parameter for the FLORIS model.\nk_fd::Float64: The k_fd parameter for the FLORIS model.\neta::Int: The eta parameter for the FLORIS model.\np_p::Float64: The p_p parameter for the FLORIS model.\nairDen::Float64: The air density for the FLORIS model.\nTIexp::Int: The turbulence intensity exponent for the FLORIS model.\nrotor_points::Union{Nothing, Int64}: Optional number of rotor points.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.FloriDyn","page":"Settings","title":"FLORIDyn.FloriDyn","text":"FloriDyn\n\nA structure representing the settings for the FLORIDyn simulation environment.\n\nFields\n\nn_op::Int: The number of operating points.\ndeltaUW::Float64: The delta U wind speed perturbation.\ndeltaDW::Float64: The delta D wind direction perturbation.\ndeltaCW::Float64: The delta C wind turbulence intensity perturbation.\ndynStateChange::String: The type of dynamic state change, e.g., \"Constant\", \"Interpolation\".\ntwf_model::String: The type of TWF (Turbine Wake Flow) model used, e.g., \"Gaussian\", \"FLORIDyn\".\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.TurbineArray","page":"Settings","title":"FLORIDyn.TurbineArray","text":"TurbineArray\n\nA structure representing the configuration and properties of a wind turbine array.\n\nFields\n\npos::Matrix{Float64}: A matrix containing the positions of turbines. Each row represents                         a turbine with columns for x, y, and z coordinates (in meters).\ntype::Vector{String}: A vector of strings specifying the type/model of each turbine.\ninit_States::Matrix{Float64}: A matrix containing the initial states of each turbine.                                 Each row represents a turbine with columns for:                                 - Column 1: a - axial induction factor                                 - Column 2: yaw - initial yaw angle (in degrees)                                 - Column 3: ti - turbulence intensity\n\nExample\n\n# Create a simple 2-turbine array\npos = [0.0 0.0 0.0; 500.0 0.0 0.0]  # Two turbines 500m apart\ntype = [\"NREL_5MW\", \"NREL_5MW\"]\ninit_states = [0.33 0.0 0.1; 0.33 0.0 0.1]  # Both start with same initial conditions\nturbines = TurbineArray(pos, type, init_states)\n\n\n\n\n\n","category":"type"},{"location":"settings/#Settings","page":"Settings","title":"Settings","text":"","category":"section"},{"location":"settings/#FLORIDyn.setup","page":"Settings","title":"FLORIDyn.setup","text":"setup(filename)\n\nInitializes or configures the system using the provided filename. The filename should specify the path to a configuration or settings file required for setup.\n\nArguments\n\nfilename::String: Path to the .yaml file to be used for setup.\n\nReturns\n\nThe tuple (wind, sim, con) where:\nwind: An instance of the Wind struct containing wind-related parameters.\nsim: An instance of the Sim struct containing simulation parameters.\ncon: An instance of the Con struct containing controller parameters.\nfloris: An instance of the Floris struct containing FLORIS model parameters.\nfloridyn: An instance of the FloriDyn struct containing FLORIDyn model parameters.\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.Settings","page":"Settings","title":"FLORIDyn.Settings","text":"Settings\n\nA mutable struct that holds configuration parameters for the FLORIDyn simulation environment.\n\nFields\n\nvel_mode::VelModel: See: VelModel\ndir_mode::DirModel: See: DirModel\nturb_mode\nshear_mode\ncor_dir_mode\ncor_vel_mode\ncor_turb_mode\niterate_mode\ncontrol_mode\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Settings-Tuple{Wind, Sim, Con}","page":"Settings","title":"FLORIDyn.Settings","text":"Settings(wind::Wind, sim::Sim, con::Con)\n\nCreate and return a Settings object using the provided wind and sim parameters.\n\nArguments\n\nwind::Wind: An instance of the Wind struct containing wind-related parameters.\nsim::Sim: An instance of the Sim struct containing the simulation parameters.\ncon::Con: An instance of the Con struct containing the controller parameters.\n\nReturns\n\nA Settings struct configured with the given wind and simulation parameters.\n\nNotes\n\nThe function uses the str2type helper to convert string representations of model types  into their corresponding Julia types.\nThe Settings struct encapsulates the model settings for velocity, direction,  turbulence intensity, shear, and correction modes.\n\n\n\n\n\n","category":"method"},{"location":"settings/#FLORIDyn.getTurbineData","page":"Settings","title":"FLORIDyn.getTurbineData","text":"getTurbineData(names::Vector{String}) -> NamedTuple\n\nRetrieve nacelle positions and rotor diameters for a given list of wind turbine types.\n\nArguments\n\nnames::Vector{String}: A vector of wind turbine type names. Supported types include:\n\"DTU 10MW\"\n\"DTU 5MW\"\n\"Senvion 6.2M\"\n\"V116\"\n\"V117\"\n\"V162\"\n\"GE Haliade X\"\n\nReturns\n\nA NamedTuple with the following fields:\nNacPos::Matrix{Float64}: An N × 3 matrix where each row corresponds to the (x, y, z) coordinates of the nacelle position for each turbine.\nD::Vector{Float64}: A vector of rotor diameters corresponding to each turbine.\n\nRaises\n\nArgumentError if an unknown or misspelled turbine name is encountered.\n\n\n\n\n\n","category":"function"},{"location":"developer/#Developer-notes","page":"Developer notes","title":"Developer notes","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"This page contains information for developers who want to contribute to or extend FLORIDyn.jl.","category":"page"},{"location":"developer/#Project-structure","page":"Developer notes","title":"Project structure","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The FLORIDyn.jl package is organized into several modules:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"src/ - Main source code\ncontroller/ - Controller implementations\ncorrection/ - Wake correction models\nfloridyn_cl/ - Main simulation loop\nfloris/ - FLORIS model implementations\nwindfield/ - Wind field modeling\ntest/ - Test suite\nexamples/ - Example scripts\ndocs/ - Documentation source\ndata/ - Example data files and configuration settings\nbin/ - Bash scripts to start Julia and for statistics","category":"page"},{"location":"developer/#Development-workflow","page":"Developer notes","title":"Development workflow","text":"","category":"section"},{"location":"developer/#Setting-up-the-development-environment","page":"Developer notes","title":"Setting up the development environment","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Clone the repository:\ngit clone https://github.com/ufechner7/FLORIDyn.jl.git\ncd FLORIDyn.jl\nActivate the project environment:\nusing Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"developer/#Running-tests","page":"Developer notes","title":"Running tests","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To run the full test suite:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"using Pkg\nPkg.test()","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To run specific tests:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"test/test_floris.jl\")","category":"page"},{"location":"developer/#Debugging","page":"Developer notes","title":"Debugging","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Suggestion: Use Infiltrator.jl for debugging.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Add two lines to your .bashrc script (create one if it does not exist yet):","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"alias jl='./bin/run_julia'\nalias jl2='./bin/run_julia2'","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Install the packages Infiltrator.jl and Revise.jl in your global environment:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"julia -e 'using Pkg; Pkg.add(\"Revise\"); Pkg.add(\"Infiltrator\")'","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Now you can launch Julia by typing jl, and for debugging type jl2.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Debugging session:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"bash> jl2\njulia> using FLORIDyn\nAdd the line Main.@infiltrate at the location where you want to set a break point.\njulia> include(\"examples/main.jl\")","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Now the program should run into your breakpoint. You should see the prompt:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"infil> ","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"and by typing the name of any local or global variable you can inspect the content. You can also execute any statement that fails and modify it until it works.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Important: When executing STEP 2, the line Main.@infiltrate must not exist or must be commented.","category":"page"},{"location":"developer/#Building-documentation","page":"Developer notes","title":"Building documentation","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To build the documentation locally:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"scripts/build_docu.jl\")","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"You can get an overview over the exported methods by running the script:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"scripts/stats.jl\")","category":"page"},{"location":"developer/#Code-style-and-conventions","page":"Developer notes","title":"Code style and conventions","text":"","category":"section"},{"location":"developer/#Naming-conventions","page":"Developer notes","title":"Naming conventions","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Use descriptive variable names\nFollow Julia naming conventions (lowercase with underscores for functions and variables)\nType names should use CamelCase\nConstants should be ALL_CAPS","category":"page"},{"location":"developer/#Code-organization","page":"Developer notes","title":"Code organization","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Keep functions focused and small\nUse meaningful docstrings for all exported functions\nInclude type annotations where helpful for clarity\nFollow the existing module structure","category":"page"},{"location":"developer/#Testing","page":"Developer notes","title":"Testing","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Write tests for new functionality\nEnsure all tests pass before submitting pull requests\nInclude edge cases in test coverage\nUse descriptive test names","category":"page"},{"location":"developer/#Contributing","page":"Developer notes","title":"Contributing","text":"","category":"section"},{"location":"developer/#Pull-requests","page":"Developer notes","title":"Pull requests","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Fork the repository\nCreate a feature branch\nMake your changes\nAdd tests for new functionality\nEnsure all tests pass\nUpdate documentation if needed\nSubmit a pull request","category":"page"},{"location":"developer/#Issues","page":"Developer notes","title":"Issues","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"When reporting issues, please include:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Julia version\nFLORIDyn.jl version\nMinimal working example\nError messages and stack traces","category":"page"},{"location":"developer/#Architecture-overview","page":"Developer notes","title":"Architecture overview","text":"","category":"section"},{"location":"developer/#Core-simulation-loop","page":"Developer notes","title":"Core simulation loop","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The main simulation is handled by the floridyn_cl module, which implements the time-stepping algorithm for wake evolution.","category":"page"},{"location":"developer/#Wake-models","page":"Developer notes","title":"Wake models","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The package supports multiple wake models through abstract types:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"VelModel - Velocity deficit models\nDirModel - Wake deflection models\nTurbulenceModel - Turbulence intensity models","category":"page"},{"location":"developer/#Settings-system","page":"Developer notes","title":"Settings system","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Configuration is handled through YAML files that are parsed into Julia structs. See the Settings documentation for details.","category":"page"},{"location":"developer/#Performance-considerations","page":"Developer notes","title":"Performance considerations","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The simulation uses in-place operations where possible to minimize allocations\nKey loops are optimized for performance\nConsider using @profile and BenchmarkTools.jl when optimizing code\nRead the performance tips","category":"page"},{"location":"analysis/#Column-Major-Access-Pattern-Analysis-for-FLORIDyn.jl","page":"-","title":"Column-Major Access Pattern Analysis for FLORIDyn.jl","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Based on my analysis of the src folder, I found several performance-critical patterns that could be slow in Julia due to column-major access:","category":"page"},{"location":"analysis/#**Summary-of-Issues-Found:**","page":"-","title":"Summary of Issues Found:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Column Access Patterns: 52 instances of [:, N] column access patterns\nTranspose Operations: Multiple instances of unnecessary transpose operations\nMemory Layout Issues: Several patterns that fight against Julia's column-major memory layout","category":"page"},{"location":"analysis/#**Major-Performance-Issues-Identified:**","page":"-","title":"Major Performance Issues Identified:","text":"","category":"section"},{"location":"analysis/#1.-**Column-wise-Operations-on-Large-Matrices**","page":"-","title":"1. Column-wise Operations on Large Matrices","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 180, 185, 190)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Column-wise access on potentially large matrices\nwf.States_WF[:, 1] .+= Wind.perturbation.vel_sigma * randn(wf.nOP *wf.nT)\nwf.States_WF[:, 2] .+= Wind.perturbation.dir_sigma * randn(wf.nOP *wf.nT)  \nwf.States_WF[:, 3] .+= Wind.perturbation.ti_sigma * randn(wf.nOP *wf.nT)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: High - These are in perturbationOfTheWF!() which runs every simulation step.","category":"page"},{"location":"analysis/#2.-**Unnecessary-Transpose-Repeat-Operations**","page":"-","title":"2. Unnecessary Transpose + Repeat Operations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 514-516)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Multiple transpose operations with repeat\ntmp_Tpos = repeat(wf.posBase[iT,:]' + wf.posNac[iT,:]', tmp_nT)\ntmp_WF   = repeat(iTWFState', tmp_nT)\ntmp_Tst  = repeat((wf.States_T[wf.StartI[iT], :])', tmp_nT)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Medium-High - In critical simulation loop, causes unnecessary memory allocations.","category":"page"},{"location":"analysis/#3.-**Column-Access-in-Distance-Calculations**","page":"-","title":"3. Column Access in Distance Calculations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 258, 361)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Transpose in distance calculations\ndistOP_iiT = sum((wf.posBase[iiT, 1:2]' .-wf.States_OP[idx_range, 1:2]).^2, dims=2)\ndist = sqrt.(sum((OP_positions' .- turb_pos).^2, dims=2))","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Medium - Called for every turbine pair interaction.","category":"page"},{"location":"analysis/#4.-**Column-wise-Access-in-FLORIS-Calculations**","page":"-","title":"4. Column-wise Access in FLORIS Calculations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: gaussian.jl (Lines 492-493, 499, 501, 528)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Multiple column accesses on rotor point matrices\ncw_y = tmp_RPs[:, 2] .- delta[:, 1]\ncw_z = tmp_RPs[:, 3] .- delta[:, 2]\n# ... and many more column accesses","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: High - Core wake calculation, runs frequently with large rotor point matrices.","category":"page"},{"location":"analysis/#5.-**Data-Loading-Column-Access**","page":"-","title":"5. Data Loading Column Access","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Files: src/windfield/windfield_*.jl (Multiple lines)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Column-wise data access during file reading\ntimes = WindDir[:, 1]\nphis = WindDir[:, 2]\nspeeds = WindVel[:, 2]","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Low-Medium - Mainly during initialization, but still inefficient.","category":"page"},{"location":"analysis/#**Performance-Impact-Assessment:**","page":"-","title":"Performance Impact Assessment:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"High Impact (Critical):\nStates_WF[:, N] operations in perturbationOfTheWF!() - ~15-20% simulation slowdown\nColumn access in gaussian.jl FLORIS calculations - ~10-15% wake calculation slowdown\nMedium Impact (Important):\nTranspose + repeat operations in setUpTmpWFAndRun() - ~5-10% per turbine setup\nDistance calculation transposes - ~5% turbine interaction overhead\nLow Impact (Optimization):\nData loading column access - ~1-2% initialization time","category":"page"},{"location":"analysis/#**Estimated-Total-Performance-Impact:**","page":"-","title":"Estimated Total Performance Impact:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"The column-major access patterns likely cause 20-35% overall performance degradation in the simulation, with the worst impact during:","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Wind field perturbation operations (every time step)\nWake interaction calculations (most computationally intensive part)\nMulti-turbine setup operations (scales with number of turbines)","category":"page"},{"location":"analysis/#**Recommendations-for-Fixes:**","page":"-","title":"Recommendations for Fixes:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Restructure data layout to be row-major for frequently accessed operations\nUse views instead of column slices where possible  \nPre-allocate and reuse temporary arrays instead of transpose operations\nConsider using StaticArrays.jl for small fixed-size operations\nBatch operations to work on contiguous memory when possible","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"The good news is that most of these issues are localized to specific functions and can be fixed systematically without major architectural changes.","category":"page"},{"location":"#FLORIDyn","page":"Home","title":"FLORIDyn","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A dynamic wind farm simulation software, translated from FLORIDyn_Matlab, which was written by Marcus Becker.","category":"page"},{"location":"","page":"Home","title":"Home","text":"His code uses the gaussian wake model from the quasi static wind farm simulation software FLORIS, developed by NREL.","category":"page"},{"location":"#Model-features","page":"Home","title":"Model features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulate wind farms dynamically at a low computational cost\nEstimate the power generated, added turbulence, and wake-induced losses.\nApply heterogeneous and time-varying wind speeds and directions\nTest different modeling approaches","category":"page"},{"location":"#Status","page":"Home","title":"Status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The basic example works.","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"examples/main.jl\")","category":"page"},{"location":"#TODO:","page":"Home","title":"TODO:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"implement the visualization\nadd more unit tests\nimplement the missing functions","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Python version of FLORIDyn is available at https://github.com/TUDelft-DataDrivenControl/OFF .","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia 1.10 or later, if you haven't already.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Before installing this software it is suggested to create a new project, for example like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mkdir test\ncd test\njulia --project=\".\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then add FLORIDyn from  Julia's package manager, by typing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add https://github.com/ufechner7/FLORIDyn.jl\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"at the Julia prompt. You can run the unit tests with the command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg\"test FLORIDyn\"","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Citation of the FLORIDyn model: FLORIDyn - A dynamic and flexible framework for real-time wind farm control, M. Becker, D. Allaerts, J.W. van Wingerden, 2022, http://doi.org/10.1088/1742-6596/2265/3/032103","category":"page"},{"location":"","page":"Home","title":"Home","text":"Used FLORIS model: Experimental and theoretical study of wind turbine wakes in yawed conditions, M. Bastankhah, F. Porté-Agel, 2020, http://doi.org/10.1017/jfm.2016.595","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional references for smaller subcomponents can be found in the code or in the related publications.","category":"page"},{"location":"types/#Exported-Types","page":"Exported Types","title":"Exported Types","text":"","category":"section"},{"location":"types/#The-Wind-Farm-Simulation-struct","page":"Exported Types","title":"The Wind Farm Simulation struct","text":"","category":"section"},{"location":"types/#FLORIDyn.WindFarm","page":"Exported Types","title":"FLORIDyn.WindFarm","text":"WindFarm\n\nA mutable struct representing a wind farm. Fields can be specified using keyword arguments.\n\nFields\n\nnT::Int64: Number of turbines\nnOP::Int64: Number of operating points\nStates_WF::Matrix{Float64}: States of the wind farm\nStates_OP::Matrix{Float64}: States of the operating points\nStates_T::Matrix{Float64}: States of the turbines\nposBase::Matrix{Float64}: Base positions of the turbines\nposNac::Matrix{Float64}: Positions of the nacelles\nD::Vector{Float64}: Diameters of the turbines\nStartI::Matrix{Int}: Start indices for each turbine\nintOPs::Vector{Matrix{Float64}}: Interpolated operating points\nWeight::Vector{Vector{Float64}}: Weights for the operating points\ndep::Vector{Vector{Int}}: Dependencies between turbines\nred_arr::Matrix{Float64}: Reduced array for each turbine\nNames_T::Vector{String}: Names of the states of the turbines\nNames_WF::Vector{String}: Names of the states of the wind farm\nNames_OP::Vector{String}: Names of coordinates the operating points   \n\n\n\n\n\n","category":"type"},{"location":"types/#Abstract-types","page":"Exported Types","title":"Abstract types","text":"","category":"section"},{"location":"types/#FLORIDyn.VelModel","page":"Exported Types","title":"FLORIDyn.VelModel","text":"VelModel\n\nAbstract type representing a velocity model in the wind field module. Subtypes of VelModel implement specific velocity field representations or models.\n\nSee also: \n\nDefining the wind velocity model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.DirModel","page":"Exported Types","title":"FLORIDyn.DirModel","text":"DirModel\n\nAn abstract type representing a directional wind field model.  Subtypes of DirModel should implement specific models for wind directionality.\n\nSee: Defining the wind direction model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.ShearModel","page":"Exported Types","title":"FLORIDyn.ShearModel","text":"ShearModel\n\nAn abstract type representing a wind shear model for vertical wind profiles. Subtypes of ShearModel should implement specific models for wind shear calculations.\n\nSee: Defining the wind shear model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TurbulenceModel","page":"Exported Types","title":"FLORIDyn.TurbulenceModel","text":"TurbulenceModel\n\nAn abstract type representing a turbulence model for wind field calculations. Subtypes of TurbulenceModel should implement specific models for wind turbulence intensity.\n\nSee: Defining the wind turbulence model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.VelCorrection","page":"Exported Types","title":"FLORIDyn.VelCorrection","text":"VelCorrection\n\nAn abstract type representing a velocity correction model for wind field adjustments. Subtypes of VelCorrection should implement specific correction methods for wind velocity.\n\nSee: Defining the velocity correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.DirCorrection","page":"Exported Types","title":"FLORIDyn.DirCorrection","text":"DirCorrection\n\nAn abstract type representing a direction correction model for wind field adjustments. Subtypes of DirCorrection should implement specific correction methods for wind direction.\n\nSee: Defining the direction correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TurbulenceCorrection","page":"Exported Types","title":"FLORIDyn.TurbulenceCorrection","text":"TurbulenceCorrection\n\nAn abstract type representing a turbulence correction model for wind field adjustments. Subtypes of TurbulenceCorrection should implement specific correction methods for turbulence intensity.\n\nSee: Defining the turbulence correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_model","page":"Exported Types","title":"FLORIDyn.IterateOPs_model","text":"IterateOPs_model\n\nAbstract supertype for all operational point iteration algorithms in FLORIDyn.\n\nThis abstract type defines the interface for different strategies used to advance  operational points through the wind field during time-stepping simulations. All  concrete iteration models must be subtypes of this abstract type.\n\nPurpose\n\nThe iteration models determine how operational points (OPs) move through space  and time, affecting:\n\nWake propagation dynamics\nSpatial discretization accuracy\nComputational efficiency\nPhysical representation of wind farm interactions\n\nImplementation\n\nConcrete subtypes implement specific iteration strategies through method dispatch  on functions like iterateOPs!. Each model represents a different  approach to handling the temporal and spatial evolution of operational points.\n\nAvailable Models\n\nIterateOPs_basic: Basic time-stepping with simple advection\nIterateOPs_average: Averaged dynamics for stability\nIterateOPs_buffer: Buffered approach for memory efficiency\nIterateOPs_maximum: Maximum value-based iteration\nIterateOPs_weighted: Weighted interpolation method\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.ControllerModel","page":"Exported Types","title":"FLORIDyn.ControllerModel","text":"ControllerModel\n\nAn abstract type representing a controller model for wind turbines. Subtypes of ControllerModel should implement specific control strategies for turbine operation.\n\nSee: Defining the controller for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-velocity-model","page":"Exported Types","title":"Defining the wind velocity model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind velocity. They are all subtypes of VelModel","category":"page"},{"location":"types/#FLORIDyn.Velocity_Constant","page":"Exported Types","title":"FLORIDyn.Velocity_Constant","text":"Velocity_Constant <: VelModel\n\nA velocity model representing a constant wind velocity field. This struct is used as a type marker  to indicate that the wind velocity does not vary in space or time.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Constant_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_Constant_wErrorCov","text":"Velocity_Constant_wErrorCov <: VelModel\n\nA velocity model representing a constant wind field with associated  error covariance. This struct is a subtype of VelModel and is used  to model wind velocity with an constant value and an error covariance  for uncertainty quantification.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Velocity_EnKF_InterpTurbine","text":"Velocity_EnKF_InterpTurbine <: VelModel\n\nA velocity model type representing an interpolated turbine velocity field using the  Ensemble Kalman Filter (EnKF) approach.\n\nDescription\n\nThis struct is used within the wind field modeling framework to represent the velocity at a turbine location,  where the velocity is estimated or interpolated using EnKF-based techniques.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_I_and_I","page":"Exported Types","title":"FLORIDyn.Velocity_I_and_I","text":"Velocity_I_and_I <: VelModel\n\nA velocity model implementing an interpolation and integration approach for wind velocity estimation.\n\nDescription\n\nThis struct represents a velocity model that combines interpolation techniques with integration methods  to estimate wind velocity fields, typically used for advanced wind field reconstruction scenarios.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Interpolation","page":"Exported Types","title":"FLORIDyn.Velocity_Interpolation","text":"Velocity_Interpolation <: VelModel\n\nA velocity model that uses spatial interpolation techniques to estimate wind velocity fields.\n\nDescription\n\nThis struct represents a velocity model that employs interpolation methods to determine wind velocities  at arbitrary spatial locations based on available measurement data or model predictions.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Interpolation_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_Interpolation_wErrorCov","text":"Velocity_Interpolation_wErrorCov <: VelModel\n\nA velocity model that uses spatial interpolation with associated error covariance information.\n\nDescription\n\nThis struct represents a velocity model that employs interpolation methods to determine wind velocities  and includes error covariance matrices for uncertainty quantification and probabilistic analysis.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Velocity_InterpTurbine","text":"Velocity_InterpTurbine <: VelModel\n\nA velocity model for interpolating wind velocities specifically at turbine locations.\n\nDescription\n\nThis struct represents a velocity model that focuses on estimating wind velocities at turbine hub heights  and rotor positions using interpolation techniques from surrounding measurement points or model data.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_InterpTurbine_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_InterpTurbine_wErrorCov","text":"Velocity_InterpTurbine_wErrorCov <: VelModel\n\nA velocity model for interpolating wind velocities at turbine locations with error covariance information.\n\nDescription\n\nThis struct represents a velocity model that estimates wind velocities at turbine positions using  interpolation techniques and includes associated error covariance matrices for uncertainty analysis  and robust wind farm control applications.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_RW_with_Mean","page":"Exported Types","title":"FLORIDyn.Velocity_RW_with_Mean","text":"Velocity_RW_with_Mean <: VelModel\n\nA velocity model implementing a random walk process with a mean trend component.\n\nDescription\n\nThis struct represents a velocity model that combines a random walk stochastic process with a  deterministic mean component, typically used for modeling wind velocity evolution over time  with both predictable trends and random fluctuations.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_ZOH_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_ZOH_wErrorCov","text":"Velocity_ZOH_wErrorCov <: VelModel\n\nA velocity model using Zero-Order Hold (ZOH) interpolation with error covariance information.\n\nDescription\n\nThis struct represents a velocity model that employs zero-order hold interpolation (piecewise constant)  for wind velocity estimation between measurement points, and includes error covariance matrices for  uncertainty quantification and statistical analysis.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-direction-model","page":"Exported Types","title":"Defining the wind direction model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind direction. They are all subtypes of DirModel","category":"page"},{"location":"types/#FLORIDyn.Direction_Constant","page":"Exported Types","title":"FLORIDyn.Direction_Constant","text":"Direction_Constant <: DirModel\n\nA marker struct used to represent a constant wind direction.\n\nExample:\n\ndir_mode = Direction_constant()\nphi = getWindDirT(dir_mode, 270, [1,2,3], nothing)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Constant_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_Constant_wErrorCov","text":"Direction_Constant_wErrorCov <: DirModel\n\nA marker struct used to indicate a wind direction that is constant with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Direction_EnKF_InterpTurbine","text":"Direction_EnKF_InterpTurbine <: DirModel\n\nA marker struct used to indicate the use of direction-aware Ensemble Kalman Filter (EnKF) interpolation for turbine modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Interpolation","page":"Exported Types","title":"FLORIDyn.Direction_Interpolation","text":"Direction_Interpolation <: DirModel\n\nA marker struct used to represent direction interpolation functionality within the FLORIDyn framework.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Interpolation_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_Interpolation_wErrorCov","text":"Direction_Interpolation_wErrorCov <: DirModel\n\nA marker struct representing a direction interpolation method with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Direction_InterpTurbine","text":"Direction_InterpTurbine <: DirModel\n\nA marker struct used to indicate direction interpolation for turbines.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_InterpTurbine_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_InterpTurbine_wErrorCov","text":"Direction_InterpTurbine_wErrorCov <: DirModel\n\nA marker struct used to indicate the use of direction interpolation for turbines with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_RW_with_Mean","page":"Exported Types","title":"FLORIDyn.Direction_RW_with_Mean","text":"Direction_RW_with_Mean <: DirModel\n\nA marker struct used to indicate the use of a random walk direction model with a mean component.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-shear-model","page":"Exported Types","title":"Defining the wind shear model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind shear.","category":"page"},{"location":"types/#FLORIDyn.Shear_Interpolation","page":"Exported Types","title":"FLORIDyn.Shear_Interpolation","text":"Shear_Interpolation <: ShearModel\n\nA marker struct used to represent the linear interpolation for wind shear profiles.\n\nSee also\n\nShear_PowerLaw\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Shear_PowerLaw","page":"Exported Types","title":"FLORIDyn.Shear_PowerLaw","text":"Shear_PowerLaw <: ShearModel\n\nA marker struct representing the logarithmic law for modeling wind shear profiles.\n\nSee also\n\nShear_Interpolation\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-turbulence-model","page":"Exported Types","title":"Defining the wind turbulence model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind turbulence.","category":"page"},{"location":"types/#FLORIDyn.TI_Constant","page":"Exported Types","title":"FLORIDyn.TI_Constant","text":"TI_Constant <: TurbulenceModel\n\nA marker struct representing a constant turbulence intensity. \n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.TI_EnKF_InterpTurbine","text":"TI_EnKF_InterpTurbine <: TurbulenceModel\n\nA marker struct representing the Turbulence Intensity (TI) Ensemble Kalman Filter (EnKF) interpolation model.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_Interpolation","page":"Exported Types","title":"FLORIDyn.TI_Interpolation","text":"TI_Interpolation <: TurbulenceModel\n\nA marker struct representing the interpolation method for modeling the turbulence.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_InterpTurbine","page":"Exported Types","title":"FLORIDyn.TI_InterpTurbine","text":"TI_InterpTurbine <: TurbulenceModel\n\nA marker struct representing an interpolated turbine model for turbulence intensity calculations.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-velocity-correction","page":"Exported Types","title":"Defining the velocity correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct wind velocity. They are all subtypes of VelCorrection","category":"page"},{"location":"types/#FLORIDyn.Velocity_Influence","page":"Exported Types","title":"FLORIDyn.Velocity_Influence","text":"Velocity_Influence <: VelCorrection\n\nA marker struct used to represent velocity correction based on influence modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_None","page":"Exported Types","title":"FLORIDyn.Velocity_None","text":"Velocity_None <: VelCorrection\n\nA marker struct used to indicate that no velocity corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_wGaspariAndCohn","page":"Exported Types","title":"FLORIDyn.Velocity_wGaspariAndCohn","text":"Velocity_wGaspariAndCohn <: VelCorrection\n\nA marker struct used to represent velocity correction using the Gaspari and Cohn localization method. This correction method is commonly used in ensemble data assimilation for spatial localization.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-direction-correction","page":"Exported Types","title":"Defining the direction correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct wind direction. They are all subtypes of DirCorrection","category":"page"},{"location":"types/#FLORIDyn.Direction_All","page":"Exported Types","title":"FLORIDyn.Direction_All","text":"Direction_All <: DirCorrection\n\nA marker struct used to indicate that all direction corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Influence","page":"Exported Types","title":"FLORIDyn.Direction_Influence","text":"Direction_Influence <: DirCorrection\n\nA marker struct used to represent direction correction based on influence modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_None","page":"Exported Types","title":"FLORIDyn.Direction_None","text":"Direction_None <: DirCorrection\n\nA marker struct used to indicate that no direction corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_wGaspariAndCohn","page":"Exported Types","title":"FLORIDyn.Direction_wGaspariAndCohn","text":"Direction_wGaspariAndCohn <: DirCorrection\n\nA marker struct used to represent direction correction using the Gaspari and Cohn localization method. This correction method is commonly used in ensemble data assimilation for spatial localization.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-turbulence-correction","page":"Exported Types","title":"Defining the turbulence correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct turbulence intensity. They are all subtypes of TurbulenceCorrection","category":"page"},{"location":"types/#FLORIDyn.TI_Influence","page":"Exported Types","title":"FLORIDyn.TI_Influence","text":"TI_Influence <: TurbulenceCorrection\n\nA marker struct used to represent turbulence intensity correction based on influence modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_None","page":"Exported Types","title":"FLORIDyn.TI_None","text":"TI_None <: TurbulenceCorrection\n\nA marker struct used to indicate that no turbulence intensity corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_wGaspariAndCohn","page":"Exported Types","title":"FLORIDyn.TI_wGaspariAndCohn","text":"TI_wGaspariAndCohn <: TurbulenceCorrection\n\nA marker struct used to represent turbulence intensity correction using the Gaspari and Cohn localization method. This correction method is commonly used in ensemble data assimilation for spatial localization.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-controller","page":"Exported Types","title":"Defining the controller","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that control turbine behavior. They are all subtypes of ControllerModel","category":"page"},{"location":"types/#FLORIDyn.Yaw_Constant","page":"Exported Types","title":"FLORIDyn.Yaw_Constant","text":"Yaw_Constant <: ControllerModel\n\nA marker struct used to represent a constant yaw control strategy. In this mode, turbines maintain a fixed yaw angle throughout the simulation.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Yaw_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Yaw_InterpTurbine","text":"Yaw_InterpTurbine <: ControllerModel\n\nA marker struct used to indicate yaw control with turbine interpolation. This mode allows for interpolated yaw angles across different turbine positions.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Yaw_SOWFA","page":"Exported Types","title":"FLORIDyn.Yaw_SOWFA","text":"Yaw_SOWFA <: ControllerModel\n\nA marker struct used to represent yaw control compatible with SOWFA (Simulator fOr Wind Farm Applications). This mode is specifically designed for integration with SOWFA simulation data.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-OP-iteration-model","page":"Exported Types","title":"Defining the OP iteration model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that iterate operational points (OPs) through the wind field. They are all subtypes of IterateOPs_model","category":"page"},{"location":"types/#FLORIDyn.IterateOPs_average","page":"Exported Types","title":"FLORIDyn.IterateOPs_average","text":"IterateOPs_average <: IterateOPs_model\n\nOperational point iteration model using averaged dynamics.\n\nThis iteration strategy employs averaging techniques to advance operational  points through the wind field, providing enhanced numerical stability and  smoother wake evolution compared to basic methods.\n\nAlgorithm Characteristics\n\nStability: Improved numerical stability through temporal averaging\nSmoothness: Reduces oscillations in wake dynamics\nComputational Cost: Moderate overhead due to averaging operations\nAccuracy: Good balance between stability and physical representation\n\nUse Cases\n\nRecommended for:\n\nSimulations requiring smooth wake evolution\nCases with high turbulence or complex wind conditions\nLong-duration simulations where stability is critical\nResearch applications focusing on ensemble statistics\n\nMathematical Approach\n\nThe averaging process involves temporal or spatial averaging of  relevant quantities (velocities, deflections, turbulence) before applying  the advancement step, resulting in more stable operational point trajectories.\n\nNotes\n\nThis model may require additional computational resources compared to basic  methods but provides better stability characteristics for challenging  simulation scenarios.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_basic","page":"Exported Types","title":"FLORIDyn.IterateOPs_basic","text":"IterateOPs_basic <: IterateOPs_model\n\nBasic operational point iteration model with simple time-stepping.\n\nThis is the fundamental iteration strategy that advances operational points  using direct time-stepping based on local wind velocities and wake deflection  effects. It provides the core functionality for FLORIDyn simulations.\n\nAlgorithm Characteristics\n\nSimplicity: Straightforward implementation with minimal overhead\nPerformance: Fastest execution among available iteration models\nAccuracy: Direct physical representation of wake advection\nMemory: Minimal memory requirements\n\nImplementation\n\nThe basic algorithm performs:\n\nDownwind advection based on local wind speed\nCrosswind deflection using wake centerline calculations\nCoordinate transformation to world coordinates\nTemporal advancement through circular shifting\nSpatial reordering to maintain downstream position order\n\nUse Cases\n\nRecommended for:\n\nStandard wind farm simulations\nPerformance-critical applications\nValidation studies against reference data\nInitial model development and testing\n\nMathematical Foundation\n\nUses explicit time-stepping with:\n\nΔx = U × Δt × advection_factor\n\nwhere operational points move downstream based on local wind conditions.\n\nNotes\n\nThis model serves as the reference implementation and baseline for  comparison with other iteration strategies. See iterateOPs! for detailed implementation.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_buffer","page":"Exported Types","title":"FLORIDyn.IterateOPs_buffer","text":"IterateOPs_buffer <: IterateOPs_model\n\nOperational point iteration model with buffered memory management.\n\nThis iteration strategy implements buffering techniques to optimize memory  usage and computational efficiency during operational point advancement,  particularly beneficial for large-scale wind farm simulations.\n\nAlgorithm Characteristics\n\nMemory Efficiency: Optimized memory access patterns\nScalability: Better performance for large numbers of operational points\nCaching: Intelligent buffering of frequently accessed data\nComputational Cost: Reduced overhead for memory-intensive operations\n\nUse Cases\n\nRecommended for:\n\nLarge wind farms with many turbines\nMemory-constrained computing environments\nHigh-resolution simulations with dense operational point grids\nProduction simulations requiring optimal resource utilization\n\nImplementation Strategy\n\nThe buffering approach manages operational point data through:\n\nEfficient memory allocation patterns\nReduced data copying operations\nOptimized access to state matrices\nStrategic caching of intermediate results\n\nPerformance Benefits\n\nImproved cache locality for better CPU performance\nReduced memory bandwidth requirements\nBetter scaling with problem size\nLower memory fragmentation\n\nNotes\n\nThis model is particularly effective when computational resources are  limited or when dealing with very large simulation domains.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_maximum","page":"Exported Types","title":"FLORIDyn.IterateOPs_maximum","text":"IterateOPs_maximum <: IterateOPs_model\n\nOperational point iteration model using maximum value selection.\n\nThis iteration strategy employs maximum value-based decision making during  operational point advancement, potentially useful for conservative estimates  or worst-case scenario analysis in wind farm simulations.\n\nAlgorithm Characteristics\n\nConservative Approach: Tends toward maximum/conservative values\nRobustness: Provides bounds on simulation behavior\nSpecial Cases: Handles extreme conditions effectively\nAnalysis: Useful for sensitivity and worst-case studies\n\nUse Cases\n\nRecommended for:\n\nConservative design analysis\nWorst-case scenario evaluation\nRisk assessment studies\nValidation of simulation bounds\nResearch on extreme wind conditions\n\nMathematical Approach\n\nThe maximum selection process applies maximum operators to relevant  quantities during the iteration step, which may include:\n\nMaximum wind speeds in the vicinity\nMaximum deflection values\nMaximum turbulence intensities\nConservative time step selection\n\nApplications\n\nParticularly useful in:\n\nSafety factor determination\nConservative power estimation\nExtreme load analysis\nUncertainty quantification studies\n\nNotes\n\nThis model may produce more conservative results compared to other  iteration strategies and should be used when understanding bounds  on simulation behavior is important.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_weighted","page":"Exported Types","title":"FLORIDyn.IterateOPs_weighted","text":"IterateOPs_weighted <: IterateOPs_model\n\nOperational point iteration model using weighted interpolation.\n\nThis iteration strategy employs sophisticated weighted interpolation  techniques to advance operational points, providing enhanced accuracy  through spatial and temporal weighting of relevant physical quantities.\n\nAlgorithm Characteristics\n\nHigh Accuracy: Superior interpolation accuracy\nSmoothness: Smooth transitions between operational points\nComputational Cost: Higher due to interpolation calculations\nFlexibility: Adaptable weighting schemes\n\nUse Cases\n\nRecommended for:\n\nHigh-accuracy research simulations\nDetailed wake interaction studies\nValidation against experimental data\nApplications requiring smooth field representations\nAdvanced control algorithm development\n\nInterpolation Strategy\n\nThe weighted approach typically involves:\n\nDistance-based spatial weighting\nTemporal interpolation of quantities\nMulti-point interpolation schemes\nAdaptive weight calculation based on local conditions\n\nMathematical Foundation\n\nUses interpolation weights w_i such that:\n\nquantity_interpolated = Σ w_i × quantity_i\n\nwhere weights satisfy Σ w_i = 1 and are computed based on distance,  time, or other relevant metrics.\n\nAccuracy Benefits\n\nReduced numerical diffusion\nBetter preservation of wake structures\nImproved representation of turbulence effects\nEnhanced spatial resolution\n\nNotes\n\nThis model provides the highest accuracy among available iteration  strategies but requires additional computational resources. Best suited  for applications where accuracy is prioritized over computational speed.\n\n\n\n\n\n","category":"type"},{"location":"types/#Types-for-storing-wind-field-params","page":"Exported Types","title":"Types for storing wind field params","text":"","category":"section"},{"location":"types/#FLORIDyn.WindDirType","page":"Exported Types","title":"FLORIDyn.WindDirType","text":" WindDirType\n\nFields\n\nData::Float64: wind direction value\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindDirMatrix","page":"Exported Types","title":"FLORIDyn.WindDirMatrix","text":"struct WindDirMatrix\n\nFields\n\nData::Matrix{Float64}:    Columns [time, phi] or [time, phi_T0, phi_T1, ... phi_Tn]\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindDirTriple","page":"Exported Types","title":"FLORIDyn.WindDirTriple","text":"WindDirTriple\n\nA structure representing a wind direction triple. \n\nFields\n\nInit::Vector{Float64}:    Mean direction (vector or scalar)\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\nMeanPull::Float64:        Scalar mean reversion factor\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindVelType","page":"Exported Types","title":"FLORIDyn.WindVelType","text":" WindVelType\n\nFields\n\nData::Float64: wind speed\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindVelMatrix","page":"Exported Types","title":"FLORIDyn.WindVelMatrix","text":"struct WindVelMatrix\n\nFields\n\nData::Matrix{Float64}:    Nx2 matrix: column 1 = time, column 2 = wind speed\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindShear","page":"Exported Types","title":"FLORIDyn.WindShear","text":"WindShear\n\nA struct representing the wind shear profile. This type is used to model the variation of wind speed with height,  which is important in atmospheric and wind energy simulations.\n\nFields\n\nz0::Float64: Reference height (not used in the getWindShearT)\nalpha::Float64: WindShear coefficient\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindPerturbation","page":"Exported Types","title":"FLORIDyn.WindPerturbation","text":"WindPerturbation\n\nA mutable struct for configuring stochastic wind perturbations in wind farm simulations.\n\nThis struct controls whether perturbations are applied to different wind parameters and defines the magnitude of these perturbations using standard deviations. Wind perturbations are used to  model uncertainty in wind measurements or to perform sensitivity analysis.\n\nFields\n\nvel::Bool: Enable/disable velocity perturbations. When true, random perturbations are applied to wind velocity.\nvel_sigma::Float64: Standard deviation for velocity perturbations [m/s]. Determines the magnitude of random variations added to the wind velocity.\ndir::Bool: Enable/disable direction perturbations. When true, random perturbations are applied to wind direction.\ndir_sigma::Float64: Standard deviation for direction perturbations [degrees]. Determines the magnitude of random variations added to the wind direction.\nti::Bool: Enable/disable turbulence intensity perturbations. When true, random perturbations are applied to turbulence intensity.\nti_sigma::Float64: Standard deviation for turbulence intensity perturbations [-]. Determines the magnitude of random variations added to the turbulence intensity.\n\nNotes\n\nPerturbations are typically applied as additive Gaussian noise with zero mean and the specified standard deviation\nThe perturbation flags (vel, dir, ti) act as switches to enable or disable specific types of perturbations\nSetting a flag to false will disable perturbations for that parameter regardless of the sigma value\nStandard deviations should be positive values.\n\n\n\n\n\n","category":"type"},{"location":"types/#Other-types","page":"Exported Types","title":"Other types","text":"","category":"section"},{"location":"types/#FLORIDyn.States","page":"Exported Types","title":"FLORIDyn.States","text":"States\n\nA mutable struct representing the state variables used in the Gaussian wake model.  This struct is intended to store and update the dynamic properties of the wake during simulation.\n\nFields\n\nT_names::Vector{String}: Names of turbine state variables (e.g., \"a\", \"yaw\", \"TI\" for axial induction factor, yaw angle, and turbulence intensity)\nTurbine::Int: Number of turbine state variables (length of T_names)\nOP_names::Vector{String}: Names of observation point state variables (e.g., \"x0\", \"y0\", \"z0\", \"x1\", \"y1\", \"z1\" for 3D coordinates)\nOP::Int: Number of observation point state variables (length of OP_names)\nWF_names::Vector{String}: Names of wind field state variables (e.g., \"windvel\", \"winddir\", \"TI0\" for velocity, direction, and ambient turbulence)\nWF::Int: Number of wind field state variables (length of WF_names)\n\nDescription\n\nThis struct organizes the naming and counting of different types of state variables used in wind farm simulations:\n\nTurbine states represent individual turbine properties and control settings\nObservation point states track spatial coordinates for wake calculations\nWind field states capture environmental conditions affecting the entire wind farm\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPsBuffers","page":"Exported Types","title":"FLORIDyn.IterateOPsBuffers","text":"IterateOPsBuffers\n\nA struct containing pre-allocated buffers for allocation-free execution of iterateOPs!.\n\nThis struct eliminates all allocations during the operational point iteration by  pre-allocating all necessary temporary arrays. It should be created once and reused across multiple calls to iterateOPs! for maximum performance.\n\nFields\n\ntmpOPStates::Matrix{Float64}: Buffer for saving turbine operational point states  \ntmpTStates::Matrix{Float64}: Buffer for saving turbine states\ntmpWFStates::Matrix{Float64}: Buffer for saving wind farm states\nstep_dw::Vector{Float64}: Buffer for downwind step calculations\ndeflection::Matrix{Float64}: Buffer for centerline deflection calculations  \nstep_cw::Matrix{Float64}: Buffer for crosswind step calculations\ntemp_states_op::Matrix{Float64}: Temporary buffer for States_OP circular shifting\ntemp_states_t::Matrix{Float64}: Temporary buffer for States_T circular shifting  \ntemp_states_wf::Matrix{Float64}: Temporary buffer for States_WF circular shifting\nsort_buffer::Vector{Int}: Buffer for sorting operational points\n\nConstructor\n\nIterateOPsBuffers(wf::WindFarm)\n\nCreates buffers appropriately sized for the given WindFarm object.\n\n\n\n\n\n","category":"type"}]
}
