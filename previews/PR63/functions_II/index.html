<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High-Level Functions · FLORIDyn.jl</title><meta name="title" content="High-Level Functions · FLORIDyn.jl"/><meta property="og:title" content="High-Level Functions · FLORIDyn.jl"/><meta property="twitter:title" content="High-Level Functions · FLORIDyn.jl"/><meta name="description" content="Documentation for FLORIDyn.jl."/><meta property="og:description" content="Documentation for FLORIDyn.jl."/><meta property="twitter:description" content="Documentation for FLORIDyn.jl."/><meta property="og:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><meta property="twitter:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><link rel="canonical" href="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><meta property="og:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FLORIDyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLORIDyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">Exported Types</a></li><li><a class="tocitem" href="../functions/">Low-Level Functions</a></li><li class="is-active"><a class="tocitem" href>High-Level Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#FLORIS"><span>FLORIS</span></a></li><li class="toplevel"><a class="tocitem" href="#FLORIDyn"><span>FLORIDyn</span></a></li><li class="toplevel"><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li class="toplevel"><a class="tocitem" href="#Video-Creation"><span>Video Creation</span></a></li></ul></li><li><a class="tocitem" href="../settings/">Settings</a></li><li><a class="tocitem" href="../video_creation/">Video Creation</a></li><li><a class="tocitem" href="../user_guide/">User Guide</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../developer/">Developer notes</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>High-Level Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High-Level Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl/blob/main/docs/src/functions_II.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="High-Level-Functions"><a class="docs-heading-anchor" href="#High-Level-Functions">High-Level Functions</a><a id="High-Level-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Functions" title="Permalink"></a></h1><h1 id="FLORIS"><a class="docs-heading-anchor" href="#FLORIS">FLORIS</a><a id="FLORIS-1"></a><a class="docs-heading-anchor-permalink" href="#FLORIS" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.calcCt" href="#FLORIDyn.calcCt"><code>FLORIDyn.calcCt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcCt(a::Number, _) -&gt; Float64
calcCt(a::AbstractVector, _) -&gt; AbstractVector</code></pre><p>Calculate the thrust coefficient ct = 4a(1-a).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floris/gaussian.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.centerline!" href="#FLORIDyn.centerline!"><code>FLORIDyn.centerline!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centerline!(deflection::AbstractMatrix,
            states_op, states_t, states_wf, floris::Floris, d_rotor)</code></pre><p>Compute the cross-wind wake deflection at the observation points in-place using the Gaussian wake model.</p><p>This function calculates the lateral (y) and vertical (z) deflection of the wake centerline  due to yaw misalignment and other effects. The results are written directly into the provided  deflection matrix without allocating temporary arrays.</p><p><strong>Output Arguments</strong></p><ul><li><code>deflection::AbstractMatrix</code> (size n×2): Wake deflection components filled in-place<ul><li>Column 1: Lateral deflection Δy <code>[m]</code>  </li><li>Column 2: Vertical deflection Δz <code>[m]</code> (always zero in current implementation)</li></ul></li></ul><p><strong>Input Arguments</strong></p><ul><li><code>states_op::AbstractMatrix</code> (size n×k): Operational point states where n is number of points<ul><li>Column 4 contains downstream distance in wake-aligned coordinates <code>[m]</code></li></ul></li><li><code>states_t::AbstractMatrix</code>: Turbine state matrix containing:<ul><li>Column 1: Axial induction factor a <code>[-]</code></li><li>Column 2: Yaw angle <code>[degrees]</code></li><li>Column 3: Local turbulence intensity TI <code>[-]</code></li></ul></li><li><code>states_wf::AbstractMatrix</code>: Wind field state matrix containing:<ul><li>Column 3: Ambient turbulence intensity TI₀ <code>[-]</code></li></ul></li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>d_rotor::Real</code>: Rotor diameter D <code>[m]</code></li></ul><p><strong>Notes</strong></p><ul><li>Only <code>states_op[:, 4]</code> (downstream distance) is used from the operational points</li><li>The function internally converts yaw angles from degrees to radians with sign correction</li><li>Thrust coefficient is calculated from axial induction factor using <code>calcCt</code></li></ul><p>See also: <a href="#FLORIDyn.getVars!"><code>getVars!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floris/gaussian.jl#L194-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.discretizeRotor" href="#FLORIDyn.discretizeRotor"><code>FLORIDyn.discretizeRotor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretizeRotor(n_rp::Int) -&gt; Tuple{Matrix{Float64}, Vector{Float64}}</code></pre><p>Discretizes the rotor into <code>n_rp</code> segments using the isocell algorithm.</p><p>Memoization: results are cached per thread. Repeated calls with the same <code>n_rp</code> on the same thread reuse the cached arrays (no lock needed). Do not mutate the returned arrays, as they are shared within the thread.</p><p><strong>Arguments</strong></p><ul><li><code>n_rp::Int</code>: The number of radial points to discretize the rotor into.</li></ul><p><strong>Returns</strong></p><ul><li><code>(m_rp, w)</code> where:<ul><li><code>m_rp::Matrix{Float64}</code>: Size <code>(nC, 3)</code>; first column zeros, columns 2–3 are normalized coordinates in <code>[-0.5, 0.5]</code>.</li><li><code>w::Vector{Float64}</code>: Weights per cell that sum to approximately 1.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Per-thread cache avoids contention; different threads may compute and hold their own cached copies for the same <code>n_rp</code>.</li><li>The isocell algorithm may not yield exactly <code>n_rp</code> cells but aims for a similar number.</li><li>For details, see: Masset et al. (2009) https://orbi.uliege.be/bitstream/2268/91953/1/masset<em>isocell</em>orbi.pdf</li><li>The choice <code>N1 = 3</code> is used here; values of 4 or 5 are also viable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floris/discretization.jl#L4-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.init_states" href="#FLORIDyn.init_states"><code>FLORIDyn.init_states</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_states(set::Settings, wf::WindFarm, wind::Wind, init_turb, 
            floris::Floris, sim::Sim) -&gt; Tuple{Matrix, Matrix, Matrix}</code></pre><p>Initialize the state arrays for wind farm simulation using the Gaussian wake model.</p><p>This function sets up the initial conditions for turbines, observation points, and wind field  states based on the provided configuration parameters. It computes initial positions, wind  conditions, and wake properties for each turbine in the wind farm.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options for velocity, direction, and turbulence models</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, dimensions, and state arrays (see <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>)</li><li><code>wind::Wind</code>: Wind conditions including velocity, direction, and turbulence intensity data (see <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>)</li><li><code>init_turb</code>: Initial turbine state parameters (axial induction factor, yaw angle, turbulence intensity)</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>sim::Sim</code>: Simulation parameters including time step and start time (see <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a>)</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(states_op, states_t, states_wf)</code> containing:</p><ul><li><code>states_op::Matrix</code>: Observation point states with 3D coordinates and wake positions</li><li><code>states_t::Matrix</code>: Turbine states including control parameters and operational conditions  </li><li><code>states_wf::Matrix</code>: Wind field states with velocity, direction, and turbulence data</li></ul><p><strong>Description</strong></p><p>The function performs the following initialization steps for each turbine:</p><ol><li>Retrieves wind field data (velocity, direction, turbulence intensity) based on the specified input methods</li><li>Initializes wind field states at all observation points for the turbine</li><li>Calculates downwind distances for wake coordinate system</li><li>Sets initial turbine states from provided parameters</li><li>Computes crosswind wake deflections using the centerline function</li><li>Transforms coordinates from wake-relative to world coordinate system</li><li>Updates observation point positions including turbine base and nacelle offsets</li></ol><p><strong>Notes</strong></p><ul><li>Supports multiple wind input methods including interpolation, constant values, and random walk models</li><li>Handles both 3D and 4D wind field configurations (with optional orientation data)</li><li>Uses SOWFA coordinate system conventions for angle transformations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floris/gaussian.jl#L285-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getVars!" href="#FLORIDyn.getVars!"><code>FLORIDyn.getVars!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    getVars!(sig_y, sig_z, x_0, delta, pc_y, pc_z, rps, c_t, yaw, ti, ti0, floris::Floris, d_rotor)</code></pre><p>Compute Gaussian wake widths, deflection, potential-core radii, and onset distance at observation points, in-place.</p><p><strong>Output Arguments</strong></p><ul><li><code>sig_y::AbstractVector{&lt;:Real}</code> (length n): Lateral Gaussian width σ_y at each point [m]</li><li><code>sig_z::AbstractVector{&lt;:Real}</code> (length n): Vertical Gaussian width σ_z at each point [m]</li><li><code>x_0::AbstractVector{&lt;:Real}</code> (length n): Onset distance of the far-wake x₀ [m]</li><li><code>delta::AbstractMatrix{&lt;:Real}</code> (length n×2): Deflection components <code>[Δy, Δz]</code> [m]</li><li><code>pc_y::AbstractVector{&lt;:Real}</code> (length n): Potential-core radius in y at each point [m]</li><li><code>pc_z::AbstractVector{&lt;:Real}</code> (length n): Potential-core radius in z at each point [m]</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>rps::AbstractMatrix</code> (n×3): Observation points in wake-aligned frame; columns are <code>[x_downstream, y_cross, z_cross]</code> [m]</li><li><code>c_t::Union{Number,AbstractVector}</code>: Thrust coefficient Ct (scalar or length n) [-]</li><li><code>yaw::Union{Number,AbstractVector}</code>: Yaw misalignment (scalar or length n) [rad]</li><li><code>ti::Union{Number,AbstractVector}</code>: Local turbulence intensity TI at turbine (scalar or length n) [-]</li><li><code>ti0::Union{Number,AbstractVector}</code>: Ambient turbulence intensity TI₀ (scalar or length n) [-]</li><li><code>floris::Floris</code>: FLORIS Gaussian model parameters; see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>d_rotor::Real</code>: Rotor diameter D [m]</li></ul><p><strong>Behavior</strong></p><ul><li>Supports scalar or per-point values for <code>c_t</code>, <code>yaw</code>, <code>ti</code>, <code>ti0</code>; scalars are broadcast to all points.</li><li>Uses <code>floris.k_a</code>, <code>floris.k_b</code>, <code>floris.alpha</code>, <code>floris.beta</code> to compute per-point   <code>x₀</code>, <code>σ_y</code>, <code>σ_z</code>, deflection <code>Δy</code> (here <code>Δz</code> is set to 0), and potential-core radii <code>pc_y</code>, <code>pc_z</code>.</li><li>No heap allocations beyond the provided outputs; results are written in-place and the function returns <code>nothing</code>.</li></ul><p><strong>Notes</strong></p><ul><li>Only <code>rps[:, 1]</code> (downstream distance) is used by this implementation; <code>rps[:, 2:3]</code> are ignored.</li><li><code>delta</code> must have at least 2 columns; only columns 1:2 are written.</li><li>Units: distances in meters, angles in radians, intensities and <code>Ct</code> are dimensionless.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">n = size(RPs, 1)
sig_y = similar(RPs[:, 1])
sig_z = similar(RPs[:, 1])
x0    = similar(RPs[:, 1])
delta = zeros(n, 2)
pc_y  = similar(RPs[:, 1])
pc_z  = similar(RPs[:, 1])
getVars!(sig_y, sig_z, x0, delta, pc_y, pc_z, RPs, Ct, yaw, TI, TI0, floris, D)</code></pre><p>Returns</p><ul><li><code>nothing</code> — all results are written into the provided arrays.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floris/gaussian.jl#L49-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getPower" href="#FLORIDyn.getPower"><code>FLORIDyn.getPower</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getPower(wf::WindFarm, m::AbstractMatrix, floris::Floris, con::Con)</code></pre><p>Calculate the power output of wind turbines in a wind farm simulation.</p><p>This function computes the power generated by wind turbines based on their operational states, wind conditions, and control settings. It accounts for yaw angle effects and optional yaw range constraints using hyperbolic tangent functions for smooth operational limits.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine states, dimensions, and operational data with current axial induction factors and yaw angles (see <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>)</li><li><code>m::Matrix</code>: Measurement or simulation data matrix where column 3 contains effective wind speeds at turbine locations [m/s]</li><li><code>floris::Floris</code>: FLORIS model parameters containing air density, drivetrain efficiency, and power curve parameters (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>con::Con</code>: Controller configuration object with yaw control settings and operational constraints (see <a href="../settings/#FLORIDyn.Con"><code>Con</code></a>)</li></ul><p><strong>Returns</strong></p><ul><li><code>P::Vector{Float64}</code>: Power output for each turbine in the wind farm [W]</li></ul><p><strong>Description</strong></p><p>The function calculates power using the standard wind turbine power equation with yaw corrections:</p><pre><code class="language-julia hljs">P = 0.5 × ρ × A × Cp × U³ × η × cos(γ)^p_p × f_yaw_constraints</code></pre><p>Where:</p><ul><li><code>ρ</code> is air density [<code>floris.airDen</code>] [kg/m³]</li><li><code>A</code> is rotor swept area <code>π × (D/2)²</code> [m²]</li><li><code>Cp</code> is power coefficient calculated as <code>4a(1-a)²</code> [-]</li><li><code>U</code> is effective wind speed from column 3 of matrix <code>m</code> [m/s]</li><li><code>η</code> is drivetrain efficiency [<code>floris.eta</code>] [-]</li><li><code>γ</code> is yaw angle [rad]</li><li><code>p_p</code> is yaw power exponent [<code>floris.p_p</code>] [-]</li><li><code>f_yaw_constraints</code> is optional yaw range constraint factor [-]</li></ul><p>The yaw constraint factor is applied when <code>con.tanh_yaw</code> is true:</p><pre><code class="language-julia hljs">f_yaw_constraints = [0.5 × tanh((γ_max - γ) × 50) + 0.5] × 
                           [-0.5 × tanh((γ_min - γ) × 50) + 0.5]</code></pre><p><strong>Notes</strong></p><ul><li>Power coefficient is calculated from axial induction factor: <code>Cp = 4a(1-a)²</code></li><li>Yaw effects reduce power output according to <code>cos(γ)^p_p</code> where <code>p_p</code> is typically 1.88</li><li>Optional yaw range constraints use hyperbolic tangent functions with slope factor 50 for smooth transitions</li><li>When <code>con.tanh_yaw</code> is enabled, power is smoothly constrained within [<code>con.yawRangeMin</code>, <code>con.yawRangeMax</code>]</li><li>The constraint functions approach step functions but provide smooth gradients for optimization</li><li>Axial induction factors are extracted from <code>wf.States_T[wf.StartI, 1]</code> for current time step</li><li>Yaw angles are converted from degrees to radians internally</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floris/gaussian.jl#L778-L827">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.runFLORIS!" href="#FLORIDyn.runFLORIS!"><code>FLORIDyn.runFLORIS!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    runFLORIS!(buffers::FLORISBuffers, set::Settings, location_t, states_wf, states_t, d_rotor, 
                        floris::Floris, windshear::Union{Matrix, WindShear})</code></pre><p>Execute the FLORIS (FLOw Redirection and Induction in Steady State) wake model simulation for wind farm analysis.</p><p>This function performs a comprehensive wake analysis using the Gaussian wake model to calculate velocity reductions, turbulence intensity additions, and effective wind speeds at turbine locations. It accounts for wake interactions, rotor discretization, wind shear effects, and turbulence propagation.</p><p><strong>Output Arguments</strong></p><ul><li><code>buffers::FLORISBuffers</code>: Pre-allocated buffer arrays and outputs (see <a href="../types/#FLORIDyn.FLORISBuffers"><code>FLORISBuffers</code></a>)</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options for wind shear modeling</li><li><code>location_t</code>: Matrix of turbine positions [x, y, z] coordinates for each turbine [m]</li><li><code>states_wf</code>: Wind field state matrix containing velocity, direction, and turbulence data</li><li><code>states_t</code>: Turbine state matrix with axial induction factors, yaw angles, and turbulence intensities</li><li><code>d_rotor</code>: Vector of rotor diameters for each turbine [m]</li><li><code>floris::Floris</code>: FLORIS model parameters containing wake model coefficients and rotor discretization settings (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>windshear</code>: Wind shear profile data for vertical wind speed variation modeling, either a matrix or of type <a href="../types/#FLORIDyn.WindShear"><code>WindShear</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>. Results are written into fields of <code>buffers</code>:<ul><li><code>buffers.T_red_arr</code></li><li><code>buffers.T_aTI_arr</code></li><li><code>buffers.T_Ueff</code></li><li><code>buffers.T_weight</code></li></ul></li></ul><p><strong>Description</strong></p><p>The function performs the following computational steps:</p><p><strong>1. Rotor Discretization</strong></p><ul><li>Discretizes rotor planes into radial points using the isocell algorithm</li><li>Applies yaw rotation transformations to rotor point coordinates</li><li>Handles both active turbines (d_rotor &gt; 0) and placeholder turbines</li></ul><p><strong>2. Single Turbine Case</strong></p><p>For single turbine simulations, only wind shear effects are calculated without wake interactions.</p><p><strong>3. Multi-Turbine Wake Analysis</strong></p><p>For each upstream turbine affecting downstream turbines:</p><p><strong>Coordinate Transformations</strong></p><ul><li>Transforms rotor points to wake coordinate system aligned with wind direction</li><li>Applies rotational matrices for wind direction and turbine yaw angles</li><li>Filters turbines based on minimum downstream distance (10 rotor diameters)</li></ul><p><strong>Wake Variable Calculations</strong></p><ul><li>Computes wake expansion coefficients, potential core dimensions, and deflection using <code>getVars</code></li><li>Calculates crosswind wake positions and radial distances from wake centerline</li><li>Determines core region boundaries and near/far wake transitions</li></ul><p><strong>Velocity Reduction Modeling</strong></p><ul><li>Applies different deficit models for core region vs. Gaussian wake regions</li><li>Uses velocity deficit superposition for multiple wake interactions</li><li>Accounts for yaw-induced wake deflection and asymmetry</li></ul><p><strong>Turbulence Intensity Enhancement</strong></p><ul><li>Calculates added turbulence intensity using empirical correlations</li><li>Applies Gaussian weighting for spatial distribution of turbulence enhancement</li><li>Uses parameters k<em>fa, k</em>fb, k<em>fc, k</em>fd for turbulence intensity modeling</li></ul><p><strong>4. Wind Shear Integration</strong></p><ul><li>Applies vertical wind shear corrections to the downstream turbine</li><li>Uses wind shear profile data for realistic boundary layer effects</li></ul><p><strong>Mathematical Models</strong></p><p>The function implements several key wake modeling equations:</p><p><strong>Velocity Deficit</strong>: Based on Gaussian wake theory with yaw corrections <strong>Deflection</strong>: Uses analytical wake deflection models for yawed turbines   <strong>Turbulence</strong>: Empirical correlations for wake-added turbulence intensity <strong>Superposition</strong>: Linear superposition of velocity deficits from multiple wakes</p><p><strong>Notes</strong></p><ul><li>Uses SOWFA (Simulator for Offshore Wind Farm Applications) coordinate conventions</li><li>Implements state-of-the-art Gaussian wake model with yaw considerations</li><li>Supports both research and engineering applications for wind farm optimization</li><li>Computational complexity scales as O(N²) for N turbines due to wake interactions</li><li>Requires proper initialization of turbine states and wind field conditions</li></ul><p><strong>References</strong></p><ul><li>Bastankhah, M. and Porté-Agel, F. (2016). Experimental and theoretical study of wind turbine wakes in yawed conditions</li><li>Niayifar, A. and Porté-Agel, F. (2016). Analytical modeling of wind farms: A new approach for power prediction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floris/gaussian.jl#L392-L477">source</a></section></article><h1 id="FLORIDyn"><a class="docs-heading-anchor" href="#FLORIDyn">FLORIDyn</a><a id="FLORIDyn-1"></a><a class="docs-heading-anchor-permalink" href="#FLORIDyn" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.initSimulation" href="#FLORIDyn.initSimulation"><code>FLORIDyn.initSimulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initSimulation(wf::Union{Nothing, WindFarm}, sim::Sim) -&gt; Union{Nothing, WindFarm}</code></pre><p>Initialize or load a wind farm simulation state based on simulation settings.</p><p>This function handles the initialization phase of a wind farm simulation by either saving  the current initialized state to disk or loading a previously saved state, depending on  the simulation configuration.</p><p><strong>Arguments</strong></p><ul><li><code>wf::Union{Nothing, WindFarm}</code>: Wind farm object containing the initialized simulation state, or <code>Nothing</code> if no state is available. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>sim::Sim</code>: Simulation configuration object containing initialization settings and file paths. See <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>wf::Union{Nothing, WindFarm}</code>: The wind farm state, either the original input state (for &quot;init&quot; mode) or a loaded state from disk (for &quot;load&quot; mode)</li></ul><p><strong>Behavior</strong></p><p>The function operates in two modes based on <code>sim.init</code>:</p><p><strong>&quot;init&quot; Mode</strong></p><ul><li>Uses the provided wind farm state as-is</li><li>If <code>sim.save_init_state</code> is <code>true</code>, saves the current state to <code>&quot;T_init.jld2&quot;</code> in the specified data directory</li><li>Logs the save operation for user feedback</li></ul><p><strong>&quot;load&quot; Mode</strong></p><ul><li>Attempts to load a previously saved wind farm state from <code>&quot;T_init.jld2&quot;</code></li><li>Falls back to the provided state if loading fails (with warning)</li><li>Handles file I/O errors gracefully</li></ul><p><strong>File Operations</strong></p><ul><li><strong>Save path</strong>: <code>$(sim.path_to_data)/T_init.jld2</code></li><li><strong>Format</strong>: JLD2 binary format for efficient Julia object serialization</li><li><strong>Error handling</strong>: Loading failures produce warnings but do not halt execution</li></ul><p><strong>Notes</strong></p><ul><li>The function is case-insensitive for the initialization mode string</li><li>File operations use the path specified in <code>sim.path_to_data</code></li><li>Loading errors are caught and logged as warnings, allowing simulation to proceed with the original state</li><li>This mechanism enables reproducible simulations by preserving and reusing initial conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/floridyn_cl.jl#L61-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.findTurbineGroups" href="#FLORIDyn.findTurbineGroups"><code>FLORIDyn.findTurbineGroups</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findTurbineGroups(wf::WindFarm, floridyn::FloriDyn) -&gt; Vector{Vector{Int64}}</code></pre><p>Determine wake interaction dependencies between turbines in a wind farm.</p><p>This function analyzes the spatial relationships between turbines to identify which turbines  are affected by the wakes of upstream turbines. It uses coordinate transformations to the  wind-aligned reference frame and geometric criteria to determine wake interactions.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, operational points, and wind field states. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters containing wake interaction thresholds. See <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>vv_dep::Vector{Vector{Int64}}</code>: A vector of vectors where <code>vv_dep[i]</code> contains the indices of all turbines  that affect turbine <code>i</code> through wake interactions. Each inner vector lists the upstream turbine indices  that influence the wake conditions at the corresponding turbine.</li></ul><p><strong>Algorithm</strong></p><ol><li><strong>Coordinate Transformation</strong>: For each turbine pair, transforms coordinates to a wind-aligned frame using the closest operational point</li><li><strong>Wake Zone Detection</strong>: Applies geometric criteria to determine if a downstream turbine lies within the wake zone:<ul><li>Upstream extent: <code>r₁[1] ≥ -uw × D[iT]</code> (allowing for slight upstream influence)</li><li>Downstream extent: <code>r₁[1] ≤ dw × D[iT]</code> (wake extends downstream)  </li><li>Lateral extent: <code>|r₁[2]| ≤ cw × D[iT]</code> (wake width constraint)</li></ul></li><li><strong>Dependency Matrix</strong>: Constructs a boolean dependency matrix and extracts indices for each turbine</li></ol><p><strong>Mathematical Description</strong></p><p>The wake interaction criteria are evaluated in the wind-aligned coordinate system:</p><pre><code class="nohighlight hljs">r₁ = R(φ) × (rₒₚ - rₜᵤᵣᵦ)</code></pre><p>where:</p><ul><li><code>R(φ)</code> is the rotation matrix for wind direction angle <code>φ</code></li><li><code>rₒₚ</code> is the position of the closest operational point from the upstream turbine</li><li><code>rₜᵤᵣᵦ</code> is the position of the downstream turbine being evaluated</li></ul><p><strong>Notes</strong></p><ul><li>The function uses the closest operational point from each upstream turbine to determine wind direction</li><li>Wake zones are defined as multiples of rotor diameter using the FLORIDyn parameters</li><li>Self-interaction (turbine affecting itself) is explicitly excluded</li><li>The coordinate transformation accounts for the SOWFA wind direction convention</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/floridyn_cl.jl#L198-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.prepareSimulation" href="#FLORIDyn.prepareSimulation"><code>FLORIDyn.prepareSimulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepareSimulation(set::Settings, wind::Wind, con::Con, floridyn::FloriDyn, 
                  floris::Floris, turbProp, sim::Sim) -&gt; (WindFarm, Wind, Sim, Con, Floris)</code></pre><p>Prepares the simulation environment for a wind farm analysis using the provided settings and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options.</li><li><code>wind::Wind</code>: Wind conditions or wind field data. See: <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a> </li><li><code>con::Con</code>: Controller parameters of the turbines.  See: <a href="../settings/#FLORIDyn.Con"><code>Con</code></a></li><li><code>floridyn::FloriDyn</code>: Parameters specific to the FLORIDyn model. See: <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li><li><code>floris::Floris</code>: Parameters specific to the FLORIS model. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>turbProp</code>: Properties of the turbines involved in the simulation.</li><li><code>sim::Sim</code>: Simulation-specific parameters or state. See: <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li></ul><p><strong>Arguments that get modified</strong></p><ul><li><code>wind</code>: Updated with wind velocity, direction, turbulence intensity, and shear profile.</li><li><code>con</code>: Updated with yaw data.</li><li><code>sim</code>: Updated with the number of simulation steps.</li><li><code>floris</code>: May include additional parameters for the FLORIS model.</li></ul><p><strong>Returns</strong></p><ul><li>Returns the tuple <code>(wf, wind, sim, con, floris)</code> where:<ul><li><code>wf</code>: Wind farm struct containing turbine states and positions. See: <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>wind</code>: Updated wind conditions.</li><li><code>sim</code>: Updated simulation parameters.</li><li><code>con</code>: Updated controller parameters.</li><li><code>floris</code>: Parameters for the FLORIS model.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/prepare_simulation.jl#L103-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.perturbationOfTheWF!" href="#FLORIDyn.perturbationOfTheWF!"><code>FLORIDyn.perturbationOfTheWF!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">perturbationOfTheWF!(wf::WindFarm, wind::Wind) -&gt; Nothing</code></pre><p>Apply stochastic perturbations to the wind field states in-place.</p><p>This function adds Gaussian noise to the wind field parameters to model measurement  uncertainty or natural variability in wind conditions. The perturbations are applied  conditionally based on the wind perturbation configuration and are added directly  to the wind farm state matrix.</p><p><strong>Input/ Output Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm struct containing the state matrix <code>States_WF</code> to be perturbed</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>wind::Wind</code>: Wind configuration struct containing perturbation settings. See <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: The function modifies the wind farm state in-place</li></ul><p><strong>Behavior</strong></p><p>The function applies independent Gaussian perturbations to three wind field parameters:</p><p><strong>Velocity Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.vel == true</code></li><li><strong>Target</strong>: Column 1 of <code>wf.States_WF</code> (wind velocity [m/s])</li><li><strong>Noise</strong>: <code>wind.perturbation.vel_sigma * randn(nOP × nT)</code></li></ul><p><strong>Direction Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.dir == true</code></li><li><strong>Target</strong>: Column 2 of <code>wf.States_WF</code> (wind direction [degrees])</li><li><strong>Noise</strong>: <code>wind.perturbation.dir_sigma * randn(nOP × nT)</code></li></ul><p><strong>Turbulence Intensity Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.ti == true</code>  </li><li><strong>Target</strong>: Column 3 of <code>wf.States_WF</code> (turbulence intensity [-])</li><li><strong>Noise</strong>: <code>wind.perturbation.ti_sigma * randn(nOP × nT)</code></li></ul><p><strong>Mathematical Description</strong></p><p>For each enabled perturbation type, the function applies:</p><pre><code class="nohighlight hljs">States_WF[:, col] += σ × N(0,1)</code></pre><p>where:</p><ul><li><code>σ</code> is the standard deviation for the specific parameter</li><li><code>N(0,1)</code> is standard normal random noise with dimensions <code>(nOP × nT)</code></li><li><code>nOP</code> is the number of operational points per turbine</li><li><code>nT</code> is the total number of turbines</li></ul><p><strong>Notes</strong></p><ul><li>The function uses in-place modification (indicated by the <code>!</code> suffix)</li><li>Perturbations are applied independently to each operational point and turbine</li><li>The random noise follows a standard normal distribution scaled by the respective sigma values</li><li>Only enabled perturbation types (based on boolean flags) are applied</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/floridyn_cl.jl#L123-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.setUpTmpWFAndRun!" href="#FLORIDyn.setUpTmpWFAndRun!"><code>FLORIDyn.setUpTmpWFAndRun!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setUpTmpWFAndRun!(ub::UnifiedBuffers, wf::WindFarm, set::Settings, floris::Floris, 
                  wind::Wind) -&gt; Nothing</code></pre><p>Non-allocating version that uses a unified buffer struct for wind farm calculations.</p><p>This function performs wind farm wake calculations while avoiding memory allocations by reusing pre-allocated buffer arrays from a <a href="../types/#FLORIDyn.UnifiedBuffers"><code>UnifiedBuffers</code></a> struct. This is particularly  important for parallel execution and performance-critical loops where garbage collection overhead  needs to be minimized.</p><p><strong>Buffer Arguments</strong></p><ul><li><code>ub::UnifiedBuffers</code>: Unified buffer struct containing all pre-allocated arrays<ul><li><code>ub.M_buffer</code>: Pre-allocated buffer for results matrix (size: nT × 3)</li><li><code>ub.iTWFState_buffer</code>: Buffer for turbine wind field state</li><li><code>ub.tmp_Tpos_buffer</code>: Buffer for temporary turbine positions</li><li><code>ub.tmp_WF_buffer</code>: Buffer for temporary wind field states</li><li><code>ub.tmp_Tst_buffer</code>: Buffer for temporary turbine states</li><li><code>ub.dists_buffer</code>: Buffer for distance calculations</li><li><code>ub.plot_WF_buffer</code>: Buffer for plotting wind field data</li><li><code>ub.plot_OP_buffer</code>: Buffer for plotting operating point data</li></ul></li></ul><p><strong>Output Arguments</strong></p><ul><li><code>ub.M_buffer</code>: Pre-allocated buffer for results matrix (size: nT × 3)</li><li><code>wf.Weight</code>: Sets wake weight factors for each turbine from FLORIS calculations</li><li><code>wf.red_arr</code>: Updates wake reduction factors between turbines (wake interference matrix)</li></ul><p><strong>Input/ Output Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine data</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>set::Settings</code>: Settings object containing simulation parameters</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations</li><li><code>wind::Wind</code>: Wind field configuration</li></ul><p><strong>Returns</strong></p><ul><li>nothing: The function modifies <code>ub.M_buffer</code>, <code>wf.Weight</code>, and <code>wf.red_arr</code> in-place,  storing the results of the wind farm calculations</li></ul><p><strong>Performance Notes</strong></p><ul><li>Uses in-place operations to minimize memory allocations</li><li>Buffers must be pre-sized correctly for the specific wind farm configuration</li><li>Thread-safe when each thread uses its own set of buffers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/floridyn_cl.jl#L428-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.interpolateOPs!" href="#FLORIDyn.interpolateOPs!"><code>FLORIDyn.interpolateOPs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolateOPs!(unified_buffers::UnifiedBuffers, intOPs::Vector{Matrix{Float64}}, 
                wf::WindFarm) -&gt; Nothing</code></pre><p>Compute interpolation weights and indices for operational points affecting each turbine using a unified buffer.</p><p>This function performs interpolation calculations while avoiding  memory allocations by reusing pre-allocated buffer arrays from a unified buffer struct.  This is critical for performance when called repeatedly in loops, such as in flow field calculations.</p><p><strong>Buffer Arguments</strong></p><ul><li><code>unified_buffers::UnifiedBuffers</code>: Unified buffer struct containing pre-allocated arrays including:<ul><li><code>dist_buffer</code>: Buffer for distance calculations (length ≥ wf.nOP)</li><li><code>sorted_indices_buffer</code>: Buffer for sorting indices (length ≥ wf.nOP)</li></ul></li></ul><p><strong>Output Arguments</strong></p><ul><li><code>intOPs::Vector{Matrix{Float64}}</code>: Pre-allocated vector of matrices to store interpolation results</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions and operational point data</li></ul><p><strong>Returns</strong></p><ul><li>nothing: The function modifies <code>intOPs</code> in-place, storing the interpolation results for each turbine</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create unified buffers
unified_buffers = create_unified_buffers(wf)

# Pre-allocate interpolation matrices
intOPs = [zeros(length(wf.dep[iT]), 4) for iT in 1:wf.nT]

# Non-allocating interpolation
interpolateOPs!(unified_buffers, intOPs, wf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/floridyn_cl.jl#L319-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.iterateOPs!" href="#FLORIDyn.iterateOPs!"><code>FLORIDyn.iterateOPs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterateOPs!(iterate_mode::IterateOPs_model, wf::WindFarm, sim::Sim, floris::Floris, 
            floridyn::FloriDyn, buffers::IterateOPsBuffers) -&gt; Nothing</code></pre><p>Advance operational points through the wind field using the specified iteration strategy.</p><p>This function family implements different algorithms for moving operational points (OPs)  through space and time, which is essential for accurate wake propagation modeling in  wind farm simulations. The choice of iteration method affects computational efficiency,  numerical stability, and physical accuracy.</p><p><strong>Summary</strong></p><p>The function modifies the following WindFarm fields:</p><ul><li><code>wf.States_OP</code>: Updates operational point positions and states through temporal advancement</li><li><code>wf.States_T</code>: Updates turbine states through circular shifting and temporal evolution  </li><li><code>wf.States_WF</code>: Updates wind field states through circular shifting and temporal evolution</li></ul><p><strong>Input/ Output Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine and operational point data</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>iterate_mode::IterateOPs_model</code>: Iteration strategy (e.g., <a href="../types/#FLORIDyn.IterateOPs_basic"><code>IterateOPs_basic</code></a>, <a href="../types/#FLORIDyn.IterateOPs_average"><code>IterateOPs_average</code></a>)</li><li><code>sim::Sim</code>: Simulation configuration with time-stepping parameters</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations</li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters for wake dynamics</li><li><code>buffers::IterateOPsBuffers</code>: Pre-allocated buffers for allocation-free execution</li></ul><p><strong>Algorithm Overview</strong></p><ol><li><strong>State Preservation</strong>: Save initial turbine operational point states</li><li><strong>Downwind Advection</strong>: Move OPs downstream based on local wind velocity</li><li><strong>Crosswind Deflection</strong>: Apply wake-induced lateral deflection using centerline calculations</li><li><strong>Coordinate Transformation</strong>: Convert to world coordinates using wind direction</li><li><strong>Temporal Advancement</strong>: Perform circular shifting to advance time steps</li><li><strong>Spatial Reordering</strong>: Maintain downstream position ordering of operational points</li></ol><p><strong>Available Methods</strong></p><ul><li><code>iterateOPs!(::IterateOPs_basic, ...)</code>: Basic time-stepping with simple advection</li></ul><p><strong>Notes</strong></p><ul><li>Different iteration strategies provide trade-offs between accuracy and computational cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/iterate.jl#L64-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.angSOWFA2world" href="#FLORIDyn.angSOWFA2world"><code>FLORIDyn.angSOWFA2world</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angSOWFA2world(deg_SOWFA) -&gt; Float64</code></pre><p>Convert wind direction angle from SOWFA convention to world coordinate system.</p><p>This function performs coordinate transformation between different wind direction conventions used in wind farm simulations. SOWFA (Simulator fOr Wind Farm Applications) uses a different angular reference system than the standard world coordinate system used in calculations.</p><p><strong>Arguments</strong></p><ul><li><code>deg_SOWFA::Real</code>: Wind direction angle in SOWFA convention [degrees]</li></ul><p><strong>Returns</strong></p><ul><li><code>rad_World</code>: Wind direction angle in world coordinate system [radians]</li></ul><p><strong>Coordinate System Conversion</strong></p><p>The transformation follows the relationship:</p><pre><code class="nohighlight hljs">θ_world = 270° - θ_SOWFA</code></pre><p><strong>SOWFA Convention</strong></p><ul><li>Wind direction angles are defined clockwise from a reference direction</li></ul><p><strong>World Convention</strong></p><ul><li>Wind direction angles are defined counterclockwise for mathematical calculations</li><li>Standard convention used in wake models and analytical computations</li></ul><p><strong>Mathematical Description</strong></p><p>The conversion process:</p><ol><li><strong>Angular transformation</strong>: <code>deg_World = 270 - deg_SOWFA</code></li><li><strong>Unit conversion</strong>: <code>rad_World = deg2rad(deg_World)</code></li></ol><p>The 270° offset accounts for the difference between clockwise (SOWFA) and  counterclockwise (world) angular conventions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Convert 90° SOWFA direction to world coordinates
world_angle = angSOWFA2world(90.0)  # Returns 3.141592... (180° in radians)

# Convert 0° SOWFA direction  
world_angle = angSOWFA2world(0.0)   # Returns 4.712388... (270° in radians)</code></pre><p><strong>Notes</strong></p><ul><li>The function handles the sign convention difference between coordinate systems</li><li>Output is always in radians for use in trigonometric calculations</li><li>This transformation is essential for proper wake modeling in wind farm simulations</li><li>The 270° offset ensures proper alignment between SOWFA and mathematical conventions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/floridyn_cl.jl#L4-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.runFLORIDyn" href="#FLORIDyn.runFLORIDyn"><code>FLORIDyn.runFLORIDyn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runFLORIDyn(plt, set::Settings, wf::WindFarm, wind::Wind, sim::Sim, con::Con, vis::Vis,
            floridyn::FloriDyn, floris::Floris; rmt_plot_fn=nothing, msr=VelReduction) -&gt; (WindFarm, DataFrame, Matrix)</code></pre><p>Main entry point for the FLORIDyn closed-loop simulation.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plot object for live visualization during simulation</li><li><code>set::Settings</code>: Simulation settings and configuration parameters.</li><li><code>wf::WindFarm</code>: See: <a href="../types/#FLORIDyn.WindFarm">WindFarm</a> simulation state, including turbine and wind farm states.</li><li><code>wind::Wind</code>: See: <a href="../settings/#FLORIDyn.Wind">Wind</a> field settings.</li><li><code>sim::Sim</code>: Simulation state or configuration object. See: <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li><li><code>con::Con</code>: Controller object or control parameters. See: <a href="../settings/#FLORIDyn.Con"><code>Con</code></a></li><li><code>vis::Vis</code>: Visualization settings controlling online plotting and animation. See: <a href="../settings/#FLORIDyn.Vis"><code>Vis</code></a></li><li><code>floridyn::FloriDyn</code>: Parameters specific to the FLORIDyn model. See: <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li><li><code>floris::Floris</code>: Parameters specific to the FLORIS model. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rmt_plot_fn</code>: Optional remote plotting function for intermediate simulation results. When provided, this function  is called remotely (using <code>@spawnat 2</code>) to plot flow field visualization on a separate worker process. The function should accept parameters <code>(wf, X, Y, Z, vis, t_rel; msr=VelReduction)</code> where <code>wf</code> is the wind farm state, <code>X</code>, <code>Y</code>, <code>Z</code> are flow field coordinates and velocities, <code>vis</code> contains visualization settings, and <code>t_rel</code>  is the relative simulation time. Defaults to <code>nothing</code> for local plotting.</li><li><code>msr</code>: Measurement type for velocity reduction calculations. Defaults to <code>VelReduction</code>.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(wf, md, mi)</code> containing:</p><ul><li><code>wf::WindFarm</code>: Updated simulation state with final turbine positions, wind field states, and operational point data</li><li><code>md::DataFrame</code>: Measurement data with columns:<ul><li><code>:Time</code>: Simulation time steps</li><li><code>:ForeignReduction</code>: Wind speed reduction factors (%) due to wake effects from other turbines</li><li><code>:AddedTurbulence</code>: Additional turbulence intensity (%) induced by upstream turbines</li><li><code>:EffWindSpeed</code>: Effective wind speed (m/s) at each turbine after wake effects</li><li><code>:FreeWindSpeed</code>: Free-stream wind speed (m/s) without wake interference</li><li><code>:PowerGen</code>: Generated electrical power (MW) for each turbine</li></ul></li><li><code>mi::Matrix</code>: Interaction matrix combining time data with turbine-to-turbine wake interaction coefficients                for each simulation step</li></ul><p><strong>Description</strong></p><p>Runs a closed-loop wind farm simulation using the FLORIDyn and FLORIS models,  applying control strategies and updating turbine states over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/floridyn_cl/floridyn_cl.jl#L700-L742">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.run_floridyn" href="#FLORIDyn.run_floridyn"><code>FLORIDyn.run_floridyn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_floridyn(plt, set, wf, wind, sim, con, vis, 
             floridyn, floris; msr=VelReduction) -&gt; (WindFarm, DataFrame, Matrix)</code></pre><p>Unified function that automatically handles both multi-threading and single-threading modes for running FLORIDyn simulations with appropriate plotting callbacks.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: PyPlot instance, usually provided by ControlPlots</li><li><code>set</code>: Settings object. See: <a href="../settings/#Settings">Settings</a></li><li><code>wf</code>: WindFarm struct. These are work arrays, not persistent objects. See: <a href="../types/#FLORIDyn.WindFarm">WindFarm</a></li><li><code>wind</code>: Wind field input settings. See: <a href="../settings/#FLORIDyn.Wind">Wind</a></li><li><code>sim</code>: Simulation settings. See: <a href="../settings/#FLORIDyn.Sim">Sim</a></li><li><code>con</code>: Controller settings. See: <a href="../settings/#FLORIDyn.Con">Con</a></li><li><code>vis</code>: Visualization settings. See: <a href="../settings/#FLORIDyn.Vis">Vis</a></li><li><code>floridyn</code>: FLORIDyn model struct. See: <a href="../settings/#FLORIDyn.FloriDyn">FloriDyn</a></li><li><code>floris</code>: Floris model struct. See: <a href="../settings/#FLORIDyn.Floris">Floris</a></li><li><code>msr</code>: Measurement index for online flow field plotting (VelReduction, AddedTurbulence or EffWind).         Default VelReduction. See: <a href="../types/#FLORIDyn.MSR">MSR</a></li></ul><p><strong>Returns</strong></p><ul><li>Tuple (wf, md, mi): WindFarm, measurement data, and interaction matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/FLORIDyn.jl#L402-L424">source</a></section></article><h1 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.create_thread_buffers" href="#FLORIDyn.create_thread_buffers"><code>FLORIDyn.create_thread_buffers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_thread_buffers(wf::WindFarm, nth::Int, floris::Floris) -&gt; ThreadBuffers</code></pre><p>Create thread-local buffers for parallel flow field computation with FLORIS parameters.</p><p>This function pre-allocates all necessary data structures for each thread to avoid race conditions and memory allocations during the parallel computation loop.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Original wind farm object to use as template</li><li><code>nth::Int</code>: Number of threads to create buffers for</li><li><code>floris::Floris</code>: FLORIS parameters for creating proper FLORIS buffers</li></ul><p><strong>Returns</strong></p><ul><li><code>ThreadBuffers</code>: Struct containing all thread-local buffers</li></ul><p><strong>Performance Notes</strong></p><ul><li>Each thread gets its own copy of the WindFarm structure</li><li>Pre-allocates all arrays to minimize allocations during computation</li><li>Sets up dependency structure for virtual turbines at grid points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/calc_flowfield.jl#L22-L42">source</a></section><section><div><pre><code class="language-julia hljs">create_thread_buffers(wf::WindFarm, nth::Int) -&gt; ThreadBuffers</code></pre><p>Create thread-local buffers for parallel flow field computation.</p><p>This function pre-allocates all necessary data structures for each thread to avoid race conditions and memory allocations during the parallel computation loop.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Original wind farm object to use as template</li><li><code>nth::Int</code>: Number of threads to create buffers for</li></ul><p><strong>Returns</strong></p><ul><li><code>ThreadBuffers</code>: Struct containing all thread-local buffers</li></ul><p><strong>Performance Notes</strong></p><ul><li>Each thread gets its own copy of the WindFarm structure</li><li>Pre-allocates all arrays to minimize allocations during computation</li><li>Sets up dependency structure for virtual turbines at grid points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/calc_flowfield.jl#L59-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getMeasurements" href="#FLORIDyn.getMeasurements"><code>FLORIDyn.getMeasurements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getMeasurements(buffers::ThreadBuffers, mx::Matrix, my::Matrix, nM::Int, zh::Real,
                wf::WindFarm, set::Settings, floris::Floris, wind::Wind) -&gt; Array{Float64,3}</code></pre><p>Calculate flow field measurements at specified grid points by treating them as virtual turbines.</p><p>This function computes flow field properties (velocity reduction, added turbulence, effective wind speed) at grid points by creating virtual turbines at each location and running the FLORIS wake model. Each grid point is treated as a turbine that depends on all real turbines in the wind farm, allowing wake effects to be captured in the flow field visualization.</p><p><strong>Arguments</strong></p><ul><li><code>buffers::ThreadBuffers</code>: Pre-allocated thread-local buffers created with <a href="#FLORIDyn.create_thread_buffers"><code>create_thread_buffers</code></a>;   for Julia 1.12 use <code>create_thread_buffers(wf, nthreads() + 1, floris)</code>; for single-thread use <code>create_thread_buffers(wf, 1, floris)</code></li><li><code>mx::Matrix</code>: X-coordinates of grid points (m)</li><li><code>my::Matrix</code>: Y-coordinates of grid points (m)  </li><li><code>nM::Int</code>: Number of measurements to compute (typically 3)</li><li><code>zh::Real</code>: Hub height for measurements (m)</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine data. See: <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a><ul><li><code>wf.nT</code>: Number of real turbines</li><li><code>wf.StartI</code>: Starting indices for turbine data</li><li><code>wf.posBase</code>, <code>wf.posNac</code>: Turbine positions</li><li><code>wf.States_*</code>: Turbine state matrices</li></ul></li><li><code>set::Settings</code>: Settings object containing simulation parameters. See: <a href="../settings/#Settings"><code>Settings</code></a></li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>wind::Wind</code>: Wind field configuration. See: <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions <code>(size(mx,1), size(mx,2), nM)</code><ul><li><code>mz[:,:,1]</code>: Velocity reduction</li><li><code>mz[:,:,2]</code>: Added turbulence intensity</li><li><code>mz[:,:,3]</code>: Effective wind speed</li></ul></li></ul><p><strong>Algorithm</strong></p><p>For each grid point:</p><ol><li>Creates a temporary wind farm with all original turbines plus one virtual turbine at the grid point</li><li>Sets the virtual turbine to depend on all real turbines (to capture wake effects)</li><li>Runs the FLORIS simulation to compute wake-affected flow properties</li><li>Extracts the result for the virtual turbine position</li></ol><p><strong>Performance Notes</strong></p><ul><li>Multi-threaded implementation using <code>@threads</code> for parallel processing of grid points when more than one buffer is provided</li><li>With a single buffer (<code>length(buffers.thread_buffers) == 1</code>), runs in a single-threaded loop</li><li>Each grid point requires a full wind farm simulation, so computation time scales with grid size</li><li>Uses thread-local buffers created by <a href="#FLORIDyn.create_thread_buffers"><code>create_thread_buffers</code></a> to avoid race conditions</li><li>On Julia 1.12 create <code>nthreads() + 1</code> buffers to accommodate thread indexing</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a 10x10 grid from 0 to 1000m
x_range = 0:100:1000
y_range = 0:100:1000
mx = repeat(collect(x_range)&#39;, length(y_range), 1)
my = repeat(collect(y_range), 1, length(x_range))

# Calculate 3 measurements at 90m hub height (single-thread)
buffers = create_thread_buffers(wind_farm, 1, floris_model)
mz = getMeasurements(buffers, mx, my, 3, 90.0, wind_farm, settings, floris_model, wind_config)

# Extract effective wind speed field
wind_speed_field = mz[:, :, 3]</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.calcFlowField"><code>calcFlowField</code></a>: Higher-level function that uses this to create complete flow field data</li><li><a href="#FLORIDyn.setUpTmpWFAndRun!"><code>setUpTmpWFAndRun!</code></a>: Underlying simulation function used for each grid point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/calc_flowfield.jl#L171-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.calcFlowField" href="#FLORIDyn.calcFlowField"><code>FLORIDyn.calcFlowField</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcFlowField(set::Settings, wf::WindFarm, wind::Wind, floris::Floris; plt=nothing)</code></pre><p>Generate full flow field plot data by calculating measurements across a grid.</p><p>This function creates a rectangular grid over the wind farm domain and calculates flow field properties at each grid point by treating them as virtual turbines. The computation can be performed in parallel if <code>set.threading</code> is true.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Settings object containing simulation parameters<ul><li><code>set.threading</code>: If true, uses multi-threaded computation with <code>@threads</code></li><li><code>set.parallel</code>: If true, enables parallel-specific optimizations</li></ul></li><li><code>wf::WindFarm</code>: Wind farm object containing turbine data</li><li><code>wind::Wind</code>: Wind field configuration  </li><li><code>floris::Floris</code>: FLORIS model parameters</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>plt=nothing</code>: Plot object for garbage collection control. If provided and <code>set.parallel</code> is true, automatically calls <code>plt.GC.enable(false)</code> before multithreading and <code>plt.GC.enable(true)</code>  after completion to prevent PyCall-related segmentation faults during parallel execution with ControlPlots loaded. To take full advantage of multithreading, executed the plotting in a separate process.</li><li><code>vis=nothing</code>: Visualization configuration object containing field limits and resolution settings. If provided, uses <code>vis.field_limits_min</code>, <code>vis.field_limits_max</code>, and <code>vis.field_resolution</code>  to define the computational grid. If not provided, defaults to domain [0,0,0] to [3000,3000,400]  meters with 20m resolution.</li></ul><p><strong>Returns</strong></p><ul><li><code>Z::Array{Float64,3}</code>: 3D array of flow field measurements with dimensions <code>(ny, nx, 3)</code><ul><li><code>Z[:,:,1]</code>: Velocity reduction factor</li><li><code>Z[:,:,2]</code>: Added turbulence intensity  </li><li><code>Z[:,:,3]</code>: Effective wind speed (m/s)</li></ul></li><li><code>X::Matrix{Float64}</code>: X-coordinate grid (m)</li><li><code>Y::Matrix{Float64}</code>: Y-coordinate grid (m)</li></ul><p><strong>Notes</strong></p><ul><li>Grid resolution and domain are configurable via the <code>vis</code> parameter, or use default values for backward compatibility</li><li>Hub height is taken from the first turbine in the wind farm</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Calculate flow field with threading and GC control
set.threading = true
Z, X, Y = calcFlowField(set, wf, wind, floris; plt)

# Extract velocity reduction field
velocity_reduction = Z[:, :, 1]

# Extract effective wind speed field  
wind_speed = Z[:, :, 3]</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.getMeasurements"><code>getMeasurements</code></a>: Function used internally to compute the flow field</li><li><a href="#FLORIDyn.plotFlowField"><code>plotFlowField</code></a>: Visualization function for the generated data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/calc_flowfield.jl#L326-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.plotFlowField" href="#FLORIDyn.plotFlowField"><code>FLORIDyn.plotFlowField</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plotFlowField(state::Union{Nothing, PlotState}, plt, wf, mx, my, mz, vis::Vis, t=nothing; msr::MSR=EffWind, fig=nothing)</code></pre><p>Plot a 2D contour of the flow field data with support for animation.</p><p><strong>Arguments</strong></p><ul><li><code>state::Union{Nothing, PlotState}</code>: Animation state object. Pass <code>nothing</code> for the first call,  then pass the returned state for subsequent calls to maintain the same figure and layout.</li><li><code>plt</code>: Plotting package (e.g., ControlPlots.plt)</li><li><code>wf</code>: Wind farm object containing turbine data</li><li><code>mx::Matrix</code>: X-coordinate grid</li><li><code>my::Matrix</code>: Y-coordinate grid  </li><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions (rows, cols, nM)</li><li><code>vis::Vis</code>: Visualization settings including save options and color scale parameters</li><li><code>t</code>: Time value for display in the plot title or annotations</li><li><code>msr::MSR</code>: Which measurement to plot. See: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>vis.unit_test::Bool</code>: Whether to automatically close plots for testing.</li></ul><p><strong>Returns</strong></p><ul><li><code>state::PlotState</code>: Updated or newly created plot state for use in subsequent calls</li></ul><p><strong>Description</strong></p><p>This function supports creating animations by maintaining plot state across multiple calls:</p><p><strong>First Call (state = nothing)</strong></p><ul><li>Creates new figure, axes, colorbar, and all plot elements</li><li>Initializes and returns a PlotState object</li></ul><p><strong>Subsequent Calls (state = PlotState)</strong></p><ul><li>Updates existing contour data, turbine positions, and operational points</li><li>Reuses the same figure and layout for smooth animation</li></ul><p><strong>Animation Example</strong></p><pre><code class="language-julia hljs">using ControlPlots

# Initialize state (first frame)
state = nothing
vis = Vis(online=true, save=true)  # Enable saving to video folder
for t in time_steps
    Z, X, Y = calcFlowField(settings, wind_farm, wind, floris)
    state = plotFlowField(state, plt, wind_farm, X, Y, Z, vis, t; msr=EffWind)
    plt.pause(0.01)  # Small delay for animation
end</code></pre><p><strong>Notes</strong></p><ul><li>The function automatically handles coordinate system transformations for turbine orientations</li><li>Operational points are displayed as white scatter points for reference</li><li>Color scales are kept consistent across animation frames when using the same measurement type</li><li>The time parameter <code>t</code> can be used for title updates or time annotations</li><li>When <code>vis.save=true</code>, plots are saved as PNG files to the <code>video/</code> directory</li><li>Saved filenames include measurement type and time information (e.g., <code>velocity_reduction_t0120s.png</code>)</li><li>The <code>video/</code> directory is automatically created if it doesn&#39;t exist</li><li>This function requires a plotting package like ControlPlots.jl to be loaded and available as <code>plt</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/plot_flowfield.jl#L40-L95">source</a></section><section><div><pre><code class="language-julia hljs">plotFlowField(plt, wf, mx, my, mz, vis, t=nothing; msr=EffWind, fig=nothing)</code></pre><p>Compatibility method for the original plotFlowField interface.</p><p>This method provides backward compatibility by calling the new state-based version  with <code>state=nothing</code>, effectively creating a single plot without animation support.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plotting package (e.g., ControlPlots.plt)</li><li><code>wf</code>: Wind farm object containing turbine data</li><li><code>mx::Matrix</code>: X-coordinate grid</li><li><code>my::Matrix</code>: Y-coordinate grid  </li><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions (rows, cols, nM)</li><li><code>vis::Vis</code>: Visualization settings including save options and color scale parameters</li><li><code>t</code>: Time value for display in the plot title or annotations</li><li><code>msr::MSR</code>: Which measurement to plot. See: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>vis.unit_test::Bool</code>: Whether to automatically close plots for testing.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: For compatibility with the original interface</li></ul><p><strong>Note</strong></p><p>This method is provided for backward compatibility. For animation support,  use the new interface with explicit state management.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/plot_flowfield.jl#L355-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.plot_flow_field" href="#FLORIDyn.plot_flow_field"><code>FLORIDyn.plot_flow_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_flow_field(wf, X, Y, Z, vis; msr=VelReduction, plt=nothing, fig=nothing) -&gt; Nothing</code></pre><p>High-level plotting function that automatically dispatches to either parallel or  sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>wf</code>: WindFarm object</li><li><code>X</code>, <code>Y</code>, <code>Z</code>: Flow field coordinate arrays</li><li><code>vis</code>: Visualization settings</li><li><code>msr</code>: Measurement type, see: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li><li><code>fig</code>: Figure name (optional)</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/smart_plotting.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.plotMeasurements" href="#FLORIDyn.plotMeasurements"><code>FLORIDyn.plotMeasurements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plotMeasurements(plt, wf::WindFarm, md::DataFrame, vis::Vis; separated=false, msr=VelReduction) -&gt; Nothing</code></pre><p>Plot foreign reduction measurements from FLORIDyn simulation data.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plotting package (e.g., PyPlot, which is exported from ControlPlots)</li><li><code>wf::WindFarm</code>: Wind farm object with field <code>nT</code> (number of turbines). See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>md::DataFrame</code>: Measurements DataFrame containing time series data with columns:<ul><li><code>Time</code>: Simulation time [s]</li><li><code>ForeignReduction</code>: Foreign reduction  [%]</li></ul></li><li><code>vis::Vis</code>: Visualization settings including unit_test parameter. See <a href="../settings/#FLORIDyn.Vis"><code>Vis</code></a></li><li><code>separated::Bool</code>: Whether to use separated subplot layout (default: false)</li><li><code>msr::MSR</code>: Measurement type to plot, see: <a href="../types/#FLORIDyn.MSR">MSR</a> </li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Description</strong></p><p>This function creates time series plots of foreign reduction measurements from FLORIDyn simulations. It handles:</p><ol><li>Time normalization by subtracting the start time</li><li>Foreign reduction plots in either separated (subplot) or combined layout</li><li>Different measurement types based on the <code>msr</code> parameter</li></ol><p><strong>Plotting Modes</strong></p><ul><li><strong>Separated mode</strong> (<code>separated=true</code>): Creates individual subplots for each turbine</li><li><strong>Combined mode</strong> (<code>separated=false</code>): Plots all turbines on a single figure with different colors</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ControlPlots

# Plot velocity reduction for all turbines in combined mode
plotMeasurements(plt, wind_farm, measurements_df, vis; msr=VelReduction)

# Plot added turbulence with separated subplots
plotMeasurements(plt, wind_farm, measurements_df, vis; separated=true, msr=AddedTurbulence)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.plotFlowField"><code>plotFlowField</code></a>: For flow field visualization</li><li><a href="#FLORIDyn.getMeasurements"><code>getMeasurements</code></a>: For generating measurement data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/plot_measurements.jl#L4-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.plot_measurements" href="#FLORIDyn.plot_measurements"><code>FLORIDyn.plot_measurements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_measurements(wf, md, vis; separated=true, msr=VelReduction, plt=nothing) -&gt; Nothing</code></pre><p>High-level measurements plotting function that automatically dispatches to either  parallel or sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>wf</code>: WindFarm object</li><li><code>md</code>: Measurement data</li><li><code>vis</code>: Visualization settings</li><li><code>separated</code>: Whether to use separated subplots</li><li><code>msr</code>: Measurement type, see: <a href="../types/#FLORIDyn.MSR">MSR</a> </li><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.plotMeasurements"><code>plotMeasurements</code></a>: The underlying plotting function used in sequential mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/smart_plotting.jl#L35-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.close_all" href="#FLORIDyn.close_all"><code>FLORIDyn.close_all</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">close_all(plt)</code></pre><p>Close all matplotlib figure windows.</p><p>This function automatically dispatches to either parallel or sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li></ul><p><strong>Description</strong></p><p>When running with multiple threads and processes, it uses remote plotting  capabilities to close all figures on the remote worker. Otherwise, it directly calls <code>plt.close(&quot;all&quot;)</code> to close all figures in the current process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/smart_plotting.jl#L124-L139">source</a></section></article><h1 id="Video-Creation"><a class="docs-heading-anchor" href="#Video-Creation">Video Creation</a><a id="Video-Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Video-Creation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.cleanup_video_folder" href="#FLORIDyn.cleanup_video_folder"><code>FLORIDyn.cleanup_video_folder</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cleanup_video_folder() -&gt; Nothing</code></pre><p>Clean up existing PNG files in the video folder before creating new videos.</p><p><strong>Description</strong></p><p>This function removes all PNG files from the &quot;video&quot; directory to ensure a clean slate  before generating new video frames. It is typically called before running simulations  that create video output to prevent mixing old frames with new ones.</p><p><strong>Behavior</strong></p><ul><li>Checks if the &quot;video&quot; directory exists</li><li>Scans the directory for files with &quot;.png&quot; extension</li><li>Attempts to delete each PNG file found</li><li>Reports the number of files deleted</li><li>Issues warnings for any files that cannot be deleted</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Clean up before creating new video frames
cleanup_video_folder()

# Run simulation that generates PNG frames
# ...

# Create video from frames
createVideo()</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.createVideo"><code>createVideo</code></a>: Create MP4 video from PNG frames</li><li><a href="#FLORIDyn.createAllVideos"><code>createAllVideos</code></a>: Create videos for all measurement types</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/plot_flowfield.jl#L386-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.createVideo" href="#FLORIDyn.createVideo"><code>FLORIDyn.createVideo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createVideo(prefix::String; video_dir=&quot;video&quot;, output_dir=&quot;video&quot;, fps=2, delete_frames=false)</code></pre><p>Convert PNG files in a directory starting with a given prefix into an MP4 video.</p><p><strong>Arguments</strong></p><ul><li><code>prefix::String</code>: The prefix string that PNG files must start with (e.g., &quot;velocity<em>reduction&quot;, &quot;wind</em>speed&quot;)</li><li><code>video_dir::String</code>: Directory containing the PNG files (default: &quot;video&quot;)</li><li><code>output_dir::String</code>: Directory where the output video will be saved (default: &quot;video&quot;)</li><li><code>fps::Int</code>: Frames per second for the output video (default: 2)</li><li><code>delete_frames::Bool</code>: Whether to delete the PNG files after creating the video (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the created video file, or empty string if creation failed</li></ul><p><strong>Description</strong></p><p>This function searches for PNG files in the specified directory that start with the given prefix, sorts them naturally (handling numeric sequences correctly), and combines them into an MP4 video using FFmpeg. The function requires FFmpeg to be installed on the system.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create video from velocity reduction frames
video_path = createVideo(&quot;velocity_reduction&quot;; fps=4)

# Create video from wind speed frames and delete source frames
video_path = createVideo(&quot;wind_speed&quot;; fps=6, delete_frames=true)

# Create video from custom directory
video_path = createVideo(&quot;added_turbulence&quot;; video_dir=&quot;custom_plots&quot;, output_dir=&quot;videos&quot;)</code></pre><p><strong>Requirements</strong></p><ul><li>FFmpeg must be installed and available in the system PATH</li><li>PNG files should follow a consistent naming pattern with the prefix</li><li>Recommended naming: &quot;prefix<em>t0000s.png&quot;, &quot;prefix</em>t0012s.png&quot;, etc.</li></ul><p><strong>Notes</strong></p><ul><li>Files are sorted naturally to handle numeric sequences correctly (e.g., t0001s, t0010s, t0100s)</li><li>The output video filename will be &quot;prefix_animation.mp4&quot;</li><li>If no matching files are found, the function returns an empty string</li><li>FFmpeg parameters are optimized for good quality and reasonable file size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/create_video.jl#L6-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.createAllVideos" href="#FLORIDyn.createAllVideos"><code>FLORIDyn.createAllVideos</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createAllVideos(; video_dir=&quot;video&quot;, output_dir=&quot;video&quot;, fps=2, delete_frames=false)</code></pre><p>Create videos for all common measurement types found in the video directory.</p><p><strong>Arguments</strong></p><ul><li><code>video_dir::String</code>: Directory containing the PNG files (default: &quot;video&quot;)</li><li><code>output_dir::String</code>: Directory where output videos will be saved (default: &quot;video&quot;)</li><li><code>fps::Int</code>: Frames per second for output videos (default: 2)</li><li><code>delete_frames::Bool</code>: Whether to delete PNG files after creating videos (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Paths to created video files</li></ul><p><strong>Description</strong></p><p>This convenience function automatically detects common measurement type prefixes in the video directory and creates videos for each type found. It looks for the following prefixes:</p><ul><li>&quot;velocity_reduction&quot;</li><li>&quot;added_turbulence&quot; </li><li>&quot;wind_speed&quot;</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create videos for all measurement types found
video_paths = createAllVideos(fps=4, delete_frames=true)
println(&quot;Created videos: &quot;, video_paths)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/create_video.jl#L244-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.natural_sort_key" href="#FLORIDyn.natural_sort_key"><code>FLORIDyn.natural_sort_key</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">natural_sort_key(filename::String)</code></pre><p>Generate a sort key for natural sorting of filenames containing numbers.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: The filename to generate a sort key for</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Sort key that handles numeric sequences naturally</li></ul><p><strong>Description</strong></p><p>This function creates a sort key that handles numeric sequences in filenames correctly. For example, it will sort [&quot;file1.png&quot;, &quot;file10.png&quot;, &quot;file2.png&quot;] as  [&quot;file1.png&quot;, &quot;file2.png&quot;, &quot;file10.png&quot;] rather than alphabetically.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">files = [&quot;velocity_reduction_t0001s.png&quot;, &quot;velocity_reduction_t0010s.png&quot;, &quot;velocity_reduction_t0002s.png&quot;]
sorted_files = sort(files, by=natural_sort_key)
# Result: [&quot;velocity_reduction_t0001s.png&quot;, &quot;velocity_reduction_t0002s.png&quot;, &quot;velocity_reduction_t0010s.png&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/a46658c25254d160d656fb2e2af993423c588311/src/visualisation/create_video.jl#L175-L197">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Low-Level Functions</a><a class="docs-footer-nextpage" href="../settings/">Settings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 22 August 2025 01:23">Friday 22 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
