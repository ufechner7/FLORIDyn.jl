<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exported Types · FLORIDyn.jl</title><meta name="title" content="Exported Types · FLORIDyn.jl"/><meta property="og:title" content="Exported Types · FLORIDyn.jl"/><meta property="twitter:title" content="Exported Types · FLORIDyn.jl"/><meta name="description" content="Documentation for FLORIDyn.jl."/><meta property="og:description" content="Documentation for FLORIDyn.jl."/><meta property="twitter:description" content="Documentation for FLORIDyn.jl."/><meta property="og:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/types/"/><meta property="twitter:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/types/"/><link rel="canonical" href="https://ufechner7.github.io/FLORIDyn.jl/dev/types/"/><meta property="og:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FLORIDyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLORIDyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Exported Types</a><ul class="internal"><li><a class="tocitem" href="#The-Wind-Farm-Simulation-struct"><span>The Wind Farm Simulation struct</span></a></li><li><a class="tocitem" href="#Abstract-types"><span>Abstract types</span></a></li><li><a class="tocitem" href="#Defining-the-wind-velocity-model"><span>Defining the wind velocity model</span></a></li><li><a class="tocitem" href="#Defining-the-wind-direction-model"><span>Defining the wind direction model</span></a></li><li><a class="tocitem" href="#Defining-the-wind-shear-model"><span>Defining the wind shear model</span></a></li><li><a class="tocitem" href="#Defining-the-wind-turbulence-model"><span>Defining the wind turbulence model</span></a></li><li><a class="tocitem" href="#Defining-the-velocity-correction"><span>Defining the velocity correction</span></a></li><li><a class="tocitem" href="#Defining-the-direction-correction"><span>Defining the direction correction</span></a></li><li><a class="tocitem" href="#Defining-the-turbulence-correction"><span>Defining the turbulence correction</span></a></li><li><a class="tocitem" href="#Defining-the-controller"><span>Defining the controller</span></a></li><li><a class="tocitem" href="#Defining-the-OP-iteration-model"><span>Defining the OP iteration model</span></a></li><li><a class="tocitem" href="#Types-for-storing-wind-field-params"><span>Types for storing wind field params</span></a></li><li><a class="tocitem" href="#Other-types"><span>Other types</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Low-Level Functions</a></li><li><a class="tocitem" href="../functions_II/">High-Level Functions</a></li><li><a class="tocitem" href="../settings/">Settings</a></li><li><a class="tocitem" href="../video_creation/">Video Creation</a></li><li><a class="tocitem" href="../user_guide/">User Guide</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../developer/">Developer notes</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Exported Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Exported Types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl/blob/main/docs/src/types.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-Types"><a class="docs-heading-anchor" href="#Exported-Types">Exported Types</a><a id="Exported-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Types" title="Permalink"></a></h1><h2 id="The-Wind-Farm-Simulation-struct"><a class="docs-heading-anchor" href="#The-Wind-Farm-Simulation-struct">The Wind Farm Simulation struct</a><a id="The-Wind-Farm-Simulation-struct-1"></a><a class="docs-heading-anchor-permalink" href="#The-Wind-Farm-Simulation-struct" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="FLORIDyn.WindFarm"><a class="docstring-binding" href="#FLORIDyn.WindFarm"><code>FLORIDyn.WindFarm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WindFarm</code></pre><p>A mutable struct representing a wind farm. Fields can be specified using keyword arguments.</p><p>This struct supports convenient DataFrame access through property syntax:</p><ul><li><code>wf.turbines</code>: Returns a <a href="https://dataframes.juliadata.org/stable/lib/types/#DataFrames.DataFrame">DataFrame</a> with turbine state data (columns: turbine state names)</li><li><code>wf.windfield</code>: Returns a <a href="https://dataframes.juliadata.org/stable/lib/types/#DataFrames.DataFrame">DataFrame</a> with wind field data (columns: wind field variables)  </li><li><code>wf.ops</code>: Returns a <a href="https://dataframes.juliadata.org/stable/lib/types/#DataFrames.DataFrame">DataFrame</a> with operating point data (columns: operating point variables)</li></ul><p><strong>Fields</strong></p><ul><li><code>nT::Int64</code>: Number of turbines</li><li><code>nOP::Int64</code>: Number of operating points</li><li><code>States_WF::Matrix{Float64}</code>: States of the wind farm (states × wind field variables)</li><li><code>States_OP::Matrix{Float64}</code>: States of the operating points (states × operating point variables)</li><li><code>States_T::Matrix{Float64}</code>: States of the turbines (states × turbines variables)</li><li><code>posBase::Matrix{Float64}</code>: Base positions of the turbines (2 × nT matrix: [x-coords; y-coords])</li><li><code>posNac::Matrix{Float64}</code>: Positions of the nacelles</li><li><code>D::Vector{Float64}</code>: Diameters of the turbines</li><li><code>StartI::Matrix{Int}</code>: Start indices for each turbine</li><li><code>intOPs::Vector{Matrix{Float64}}</code>: Interpolated operating points</li><li><code>Weight::Vector{Vector{Float64}}</code>: Weights for the operating points</li><li><code>dep::Vector{Vector{Int}}</code>: Dependencies between turbines</li><li><code>red_arr::Matrix{Float64}</code>: Reduced array for each turbine</li><li><code>Names_T::Vector{String}</code>: Names of the turbine state variables</li><li><code>Names_WF::Vector{String}</code>: Names of the wind field variables</li><li><code>Names_OP::Vector{String}</code>: Names of the operating point variables</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create a wind farm
wf = WindFarm(nT=3, nOP=100, ...)

# Access data as DataFrames
turbine_data = wf.turbines      # DataFrame with turbine states
windfield_data = wf.windfield   # DataFrame with wind field states
ops_data = wf.ops               # DataFrame with operating point states</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/structs.jl#L264-L302">source</a></section></details></article><h2 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="FLORIDyn.VelModel"><a class="docstring-binding" href="#FLORIDyn.VelModel"><code>FLORIDyn.VelModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VelModel</code></pre><p>Abstract type representing a velocity model in the wind field module. Subtypes of <code>VelModel</code> implement specific velocity field representations or models.</p><p>See also: </p><ul><li><a href="#Defining-the-wind-velocity-model">Defining the wind velocity model</a> for more details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L6-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.DirModel"><a class="docstring-binding" href="#FLORIDyn.DirModel"><code>FLORIDyn.DirModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DirModel</code></pre><p>An abstract type representing a directional wind field model.  Subtypes of <code>DirModel</code> should implement specific models for wind directionality.</p><p>See: <a href="#Defining-the-wind-direction-model">Defining the wind direction model</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.ShearModel"><a class="docstring-binding" href="#FLORIDyn.ShearModel"><code>FLORIDyn.ShearModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ShearModel</code></pre><p>An abstract type representing a wind shear model for vertical wind profiles. Subtypes of <code>ShearModel</code> should implement specific models for wind shear calculations.</p><p>See: <a href="#Defining-the-wind-shear-model">Defining the wind shear model</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_shear.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.TurbulenceModel"><a class="docstring-binding" href="#FLORIDyn.TurbulenceModel"><code>FLORIDyn.TurbulenceModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TurbulenceModel</code></pre><p>An abstract type representing a turbulence model for wind field calculations. Subtypes of <code>TurbulenceModel</code> should implement specific models for wind turbulence intensity.</p><p>See: <a href="#Defining-the-wind-turbulence-model">Defining the wind turbulence model</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_turb.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.VelCorrection"><a class="docstring-binding" href="#FLORIDyn.VelCorrection"><code>FLORIDyn.VelCorrection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VelCorrection</code></pre><p>An abstract type representing a velocity correction model for wind field adjustments. Subtypes of <code>VelCorrection</code> should implement specific correction methods for wind velocity.</p><p>See: <a href="#Defining-the-velocity-correction">Defining the velocity correction</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_vel.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.DirCorrection"><a class="docstring-binding" href="#FLORIDyn.DirCorrection"><code>FLORIDyn.DirCorrection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DirCorrection</code></pre><p>An abstract type representing a direction correction model for wind field adjustments. Subtypes of <code>DirCorrection</code> should implement specific correction methods for wind direction.</p><p>See: <a href="#Defining-the-direction-correction">Defining the direction correction</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_dir.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.TurbulenceCorrection"><a class="docstring-binding" href="#FLORIDyn.TurbulenceCorrection"><code>FLORIDyn.TurbulenceCorrection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TurbulenceCorrection</code></pre><p>An abstract type representing a turbulence correction model for wind field adjustments. Subtypes of <code>TurbulenceCorrection</code> should implement specific correction methods for turbulence intensity.</p><p>See: <a href="#Defining-the-turbulence-correction">Defining the turbulence correction</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_turb.jl#L6-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.IterateOPs_model"><a class="docstring-binding" href="#FLORIDyn.IterateOPs_model"><code>FLORIDyn.IterateOPs_model</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterateOPs_model</code></pre><p>Abstract supertype for all observation point iteration algorithms in FLORIDyn.</p><p>This abstract type defines the interface for different strategies used to advance  observation points through the wind field during time-stepping simulations. All  concrete iteration models must be subtypes of this abstract type.</p><p><strong>Purpose</strong></p><p>The iteration models determine how observation points (OPs) move through space  and time, affecting:</p><ul><li>Wake propagation dynamics</li><li>Spatial discretization accuracy</li><li>Computational efficiency</li><li>Physical representation of wind farm interactions</li></ul><p><strong>Implementation</strong></p><p>Concrete subtypes implement specific iteration strategies through method dispatch  on functions like <a href="../functions_II/#FLORIDyn.iterateOPs!"><code>iterateOPs!</code></a>. Each model represents a different  approach to handling the temporal and spatial evolution of observation points.</p><p><strong>Available Models</strong></p><ul><li><a href="#FLORIDyn.IterateOPs_basic"><code>IterateOPs_basic</code></a>: Basic time-stepping with simple advection</li><li><a href="#FLORIDyn.IterateOPs_average"><code>IterateOPs_average</code></a>: Averaged dynamics for stability</li><li><a href="#FLORIDyn.IterateOPs_buffer"><code>IterateOPs_buffer</code></a>: Buffered approach for memory efficiency</li><li><a href="#FLORIDyn.IterateOPs_maximum"><code>IterateOPs_maximum</code></a>: Maximum value-based iteration</li><li><a href="#FLORIDyn.IterateOPs_weighted"><code>IterateOPs_weighted</code></a>: Weighted interpolation method</li></ul><p><strong>WARNING</strong></p><p>Currently, only <a href="#FLORIDyn.IterateOPs_basic"><code>IterateOPs_basic</code></a> is fully implemented and tested.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/structs.jl#L4-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.ControllerModel"><a class="docstring-binding" href="#FLORIDyn.ControllerModel"><code>FLORIDyn.ControllerModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ControllerModel</code></pre><p>An abstract type representing a controller model for wind turbines. Subtypes of <code>ControllerModel</code> should implement specific control strategies for turbine operation.</p><p>See: <a href="#Defining-the-controller">Defining the controller</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/controller/structs_controller.jl#L6-L13">source</a></section></details></article><h2 id="Defining-the-wind-velocity-model"><a class="docs-heading-anchor" href="#Defining-the-wind-velocity-model">Defining the wind velocity model</a><a id="Defining-the-wind-velocity-model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-wind-velocity-model" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that calculate the wind velocity. They are all subtypes of <a href="#FLORIDyn.VelModel"><code>VelModel</code></a></p><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_Constant"><a class="docstring-binding" href="#FLORIDyn.Velocity_Constant"><code>FLORIDyn.Velocity_Constant</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_Constant &lt;: VelModel</code></pre><p>A velocity model representing a constant wind velocity field. This struct is used as a type marker  to indicate that the wind velocity does not vary in space or time.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L17-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_Constant_wErrorCov"><a class="docstring-binding" href="#FLORIDyn.Velocity_Constant_wErrorCov"><code>FLORIDyn.Velocity_Constant_wErrorCov</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_Constant_wErrorCov &lt;: VelModel</code></pre><p>A velocity model representing a constant wind field with associated  error covariance. This struct is a subtype of <code>VelModel</code> and is used  to model wind velocity with an constant value and an error covariance  for uncertainty quantification.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L28-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_EnKF_InterpTurbine"><a class="docstring-binding" href="#FLORIDyn.Velocity_EnKF_InterpTurbine"><code>FLORIDyn.Velocity_EnKF_InterpTurbine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_EnKF_InterpTurbine &lt;: VelModel</code></pre><p>A velocity model type representing an interpolated turbine velocity field using the  Ensemble Kalman Filter (EnKF) approach.</p><p><strong>Description</strong></p><p>This struct is used within the wind field modeling framework to represent the velocity at a turbine location,  where the velocity is estimated or interpolated using EnKF-based techniques.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L41-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_I_and_I"><a class="docstring-binding" href="#FLORIDyn.Velocity_I_and_I"><code>FLORIDyn.Velocity_I_and_I</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_I_and_I &lt;: VelModel</code></pre><p>A velocity model implementing an interpolation and integration approach for wind velocity estimation.</p><p><strong>Description</strong></p><p>This struct represents a velocity model that combines interpolation techniques with integration methods  to estimate wind velocity fields, typically used for advanced wind field reconstruction scenarios.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul><p><strong>WARNING</strong></p><p>This model is <strong>not yet implemented</strong>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L56-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_Interpolation"><a class="docstring-binding" href="#FLORIDyn.Velocity_Interpolation"><code>FLORIDyn.Velocity_Interpolation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_Interpolation &lt;: VelModel</code></pre><p>A velocity model that uses spatial interpolation techniques to estimate wind velocity fields.</p><p><strong>Description</strong></p><p>This struct represents a velocity model that employs interpolation methods to determine wind velocities  at arbitrary spatial locations based on available measurement data or model predictions.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L73-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_Interpolation_wErrorCov"><a class="docstring-binding" href="#FLORIDyn.Velocity_Interpolation_wErrorCov"><code>FLORIDyn.Velocity_Interpolation_wErrorCov</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_Interpolation_wErrorCov &lt;: VelModel</code></pre><p>A velocity model that uses spatial interpolation with associated error covariance information.</p><p><strong>Description</strong></p><p>This struct represents a velocity model that employs interpolation methods to determine wind velocities  and includes error covariance matrices for uncertainty quantification and probabilistic analysis.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L87-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_InterpTurbine"><a class="docstring-binding" href="#FLORIDyn.Velocity_InterpTurbine"><code>FLORIDyn.Velocity_InterpTurbine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_InterpTurbine &lt;: VelModel</code></pre><p>A velocity model for interpolating wind velocities specifically at turbine locations.</p><p><strong>Description</strong></p><p>This struct represents a velocity model that focuses on estimating wind velocities at turbine hub heights  and rotor positions using interpolation techniques from surrounding measurement points or model data.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L101-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_InterpTurbine_wErrorCov"><a class="docstring-binding" href="#FLORIDyn.Velocity_InterpTurbine_wErrorCov"><code>FLORIDyn.Velocity_InterpTurbine_wErrorCov</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_InterpTurbine_wErrorCov &lt;: VelModel</code></pre><p>A velocity model for interpolating wind velocities at turbine locations with error covariance information.</p><p><strong>Description</strong></p><p>This struct represents a velocity model that estimates wind velocities at turbine positions using  interpolation techniques and includes associated error covariance matrices for uncertainty analysis  and robust wind farm control applications.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L115-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_RW_with_Mean"><a class="docstring-binding" href="#FLORIDyn.Velocity_RW_with_Mean"><code>FLORIDyn.Velocity_RW_with_Mean</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_RW_with_Mean &lt;: VelModel</code></pre><p>A velocity model implementing a random walk process with a mean trend component.</p><p><strong>Description</strong></p><p>This struct represents a velocity model that combines a random walk stochastic process with a  deterministic mean component, typically used for modeling wind velocity evolution over time  with both predictable trends and random fluctuations.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul><p><strong>WARNING</strong></p><p>This model is <strong>not yet implemented</strong>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L130-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_ZOH_wErrorCov"><a class="docstring-binding" href="#FLORIDyn.Velocity_ZOH_wErrorCov"><code>FLORIDyn.Velocity_ZOH_wErrorCov</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_ZOH_wErrorCov &lt;: VelModel</code></pre><p>A velocity model using Zero-Order Hold (ZOH) interpolation with error covariance information.</p><p><strong>Description</strong></p><p>This struct represents a velocity model that employs zero-order hold interpolation (piecewise constant)  for wind velocity estimation between measurement points, and includes error covariance matrices for  uncertainty quantification and statistical analysis.</p><p><strong>See also:</strong></p><ul><li><a href="#FLORIDyn.VelModel"><code>VelModel</code></a>: Abstract supertype for velocity models.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_vel.jl#L148-L160">source</a></section></details></article><h2 id="Defining-the-wind-direction-model"><a class="docs-heading-anchor" href="#Defining-the-wind-direction-model">Defining the wind direction model</a><a id="Defining-the-wind-direction-model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-wind-direction-model" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that calculate the wind direction. They are all subtypes of <a href="#FLORIDyn.DirModel"><code>DirModel</code></a></p><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_Constant"><a class="docstring-binding" href="#FLORIDyn.Direction_Constant"><code>FLORIDyn.Direction_Constant</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_Constant &lt;: DirModel</code></pre><p>A marker struct used to represent a constant wind direction.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">dir_mode = Direction_constant()
phi = getWindDirT(dir_mode, 270, [1,2,3], nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L16-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_Constant_wErrorCov"><a class="docstring-binding" href="#FLORIDyn.Direction_Constant_wErrorCov"><code>FLORIDyn.Direction_Constant_wErrorCov</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_Constant_wErrorCov &lt;: DirModel</code></pre><p>A marker struct used to indicate a wind direction that is constant with associated error covariance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L28-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_EnKF_InterpTurbine"><a class="docstring-binding" href="#FLORIDyn.Direction_EnKF_InterpTurbine"><code>FLORIDyn.Direction_EnKF_InterpTurbine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_EnKF_InterpTurbine &lt;: DirModel</code></pre><p>A marker struct used to indicate the use of direction-aware Ensemble Kalman Filter (EnKF) interpolation for turbine modeling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L34-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_Interpolation"><a class="docstring-binding" href="#FLORIDyn.Direction_Interpolation"><code>FLORIDyn.Direction_Interpolation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_Interpolation &lt;: DirModel</code></pre><p>A marker struct used to represent direction interpolation functionality within the FLORIDyn framework.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_Interpolation_wErrorCov"><a class="docstring-binding" href="#FLORIDyn.Direction_Interpolation_wErrorCov"><code>FLORIDyn.Direction_Interpolation_wErrorCov</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_Interpolation_wErrorCov &lt;: DirModel</code></pre><p>A marker struct representing a direction interpolation method with associated error covariance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L46-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_InterpTurbine"><a class="docstring-binding" href="#FLORIDyn.Direction_InterpTurbine"><code>FLORIDyn.Direction_InterpTurbine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_InterpTurbine &lt;: DirModel</code></pre><p>A marker struct used to indicate direction interpolation for turbines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L52-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_InterpTurbine_wErrorCov"><a class="docstring-binding" href="#FLORIDyn.Direction_InterpTurbine_wErrorCov"><code>FLORIDyn.Direction_InterpTurbine_wErrorCov</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_InterpTurbine_wErrorCov &lt;: DirModel</code></pre><p>A marker struct used to indicate the use of direction interpolation for turbines with associated error covariance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L58-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_RW_with_Mean"><a class="docstring-binding" href="#FLORIDyn.Direction_RW_with_Mean"><code>FLORIDyn.Direction_RW_with_Mean</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_RW_with_Mean &lt;: DirModel</code></pre><p>A marker struct used to indicate the use of a random walk direction model with a mean component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_dir.jl#L64-L68">source</a></section></details></article><h2 id="Defining-the-wind-shear-model"><a class="docs-heading-anchor" href="#Defining-the-wind-shear-model">Defining the wind shear model</a><a id="Defining-the-wind-shear-model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-wind-shear-model" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that calculate the wind shear.</p><article><details class="docstring" open="true"><summary id="FLORIDyn.Shear_Interpolation"><a class="docstring-binding" href="#FLORIDyn.Shear_Interpolation"><code>FLORIDyn.Shear_Interpolation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Shear_Interpolation &lt;: ShearModel</code></pre><p>A marker struct used to represent the linear interpolation for wind shear profiles.</p><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.Shear_PowerLaw"><code>Shear_PowerLaw</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_shear.jl#L16-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Shear_PowerLaw"><a class="docstring-binding" href="#FLORIDyn.Shear_PowerLaw"><code>FLORIDyn.Shear_PowerLaw</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Shear_PowerLaw &lt;: ShearModel</code></pre><p>A marker struct representing the logarithmic law for modeling wind shear profiles.</p><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.Shear_Interpolation"><code>Shear_Interpolation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_shear.jl#L37-L44">source</a></section></details></article><h2 id="Defining-the-wind-turbulence-model"><a class="docs-heading-anchor" href="#Defining-the-wind-turbulence-model">Defining the wind turbulence model</a><a id="Defining-the-wind-turbulence-model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-wind-turbulence-model" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that calculate the wind turbulence.</p><article><details class="docstring" open="true"><summary id="FLORIDyn.TI_Constant"><a class="docstring-binding" href="#FLORIDyn.TI_Constant"><code>FLORIDyn.TI_Constant</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TI_Constant &lt;: TurbulenceModel</code></pre><p>A marker struct representing a constant turbulence intensity. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_turb.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.TI_EnKF_InterpTurbine"><a class="docstring-binding" href="#FLORIDyn.TI_EnKF_InterpTurbine"><code>FLORIDyn.TI_EnKF_InterpTurbine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TI_EnKF_InterpTurbine &lt;: TurbulenceModel</code></pre><p>A marker struct representing the Turbulence Intensity (TI) Ensemble Kalman Filter (EnKF) interpolation model.</p><p><strong>WARNING</strong></p><p>This model is <strong>not yet implemented</strong>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_turb.jl#L23-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.TI_Interpolation"><a class="docstring-binding" href="#FLORIDyn.TI_Interpolation"><code>FLORIDyn.TI_Interpolation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TI_Interpolation &lt;: TurbulenceModel</code></pre><p>A marker struct representing the interpolation method for modeling the turbulence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_turb.jl#L33-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.TI_InterpTurbine"><a class="docstring-binding" href="#FLORIDyn.TI_InterpTurbine"><code>FLORIDyn.TI_InterpTurbine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TI_InterpTurbine &lt;: TurbulenceModel</code></pre><p>A marker struct representing an interpolated turbine model for turbulence intensity calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/windfield/structs_turb.jl#L41-L45">source</a></section></details></article><h2 id="Defining-the-velocity-correction"><a class="docs-heading-anchor" href="#Defining-the-velocity-correction">Defining the velocity correction</a><a id="Defining-the-velocity-correction-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-velocity-correction" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that correct wind velocity. They are all subtypes of <a href="#FLORIDyn.VelCorrection"><code>VelCorrection</code></a></p><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_Influence"><a class="docstring-binding" href="#FLORIDyn.Velocity_Influence"><code>FLORIDyn.Velocity_Influence</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_Influence &lt;: VelCorrection</code></pre><p>Marker struct selecting the influence-based free-stream velocity correction implemented in <code>correctVel!(::Velocity_Influence, ...)</code>. See that function&#39;s docstring for algorithm details.</p><p><strong>WARNING:</strong></p><p>This correction method is not properly tested. Use at your own risk!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_vel.jl#L16-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Velocity_None"><a class="docstring-binding" href="#FLORIDyn.Velocity_None"><code>FLORIDyn.Velocity_None</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velocity_None &lt;: VelCorrection</code></pre><p>A marker struct used to indicate that no velocity corrections should be applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_vel.jl#L27-L31">source</a></section></details></article><h2 id="Defining-the-direction-correction"><a class="docs-heading-anchor" href="#Defining-the-direction-correction">Defining the direction correction</a><a id="Defining-the-direction-correction-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-direction-correction" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that correct wind direction. They are all subtypes of <a href="#FLORIDyn.DirCorrection"><code>DirCorrection</code></a></p><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_All"><a class="docstring-binding" href="#FLORIDyn.Direction_All"><code>FLORIDyn.Direction_All</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_All &lt;: DirCorrection</code></pre><p>A marker struct used to indicate that all direction corrections should be applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_dir.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_Influence"><a class="docstring-binding" href="#FLORIDyn.Direction_Influence"><code>FLORIDyn.Direction_Influence</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_Influence &lt;: DirCorrection</code></pre><p>A marker struct used to represent direction correction based on influence modeling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_dir.jl#L23-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Direction_None"><a class="docstring-binding" href="#FLORIDyn.Direction_None"><code>FLORIDyn.Direction_None</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Direction_None &lt;: DirCorrection</code></pre><p>A marker struct used to indicate that no direction corrections should be applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_dir.jl#L30-L34">source</a></section></details></article><h2 id="Defining-the-turbulence-correction"><a class="docs-heading-anchor" href="#Defining-the-turbulence-correction">Defining the turbulence correction</a><a id="Defining-the-turbulence-correction-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-turbulence-correction" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that correct turbulence intensity. They are all subtypes of <a href="#FLORIDyn.TurbulenceCorrection"><code>TurbulenceCorrection</code></a></p><article><details class="docstring" open="true"><summary id="FLORIDyn.TI_Influence"><a class="docstring-binding" href="#FLORIDyn.TI_Influence"><code>FLORIDyn.TI_Influence</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TI_Influence &lt;: TurbulenceCorrection</code></pre><p>A marker struct used to represent turbulence intensity correction based on influence modeling.</p><p><strong>WARNING:</strong></p><p>This correction method is not properly tested. Use at your own risk!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_turb.jl#L16-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.TI_None"><a class="docstring-binding" href="#FLORIDyn.TI_None"><code>FLORIDyn.TI_None</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TI_None &lt;: TurbulenceCorrection</code></pre><p>A marker struct used to indicate that no turbulence intensity corrections should be applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/correction/structs_turb.jl#L26-L30">source</a></section></details></article><h2 id="Defining-the-controller"><a class="docs-heading-anchor" href="#Defining-the-controller">Defining the controller</a><a id="Defining-the-controller-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-controller" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that control turbine behavior. They are all subtypes of <a href="#FLORIDyn.ControllerModel"><code>ControllerModel</code></a></p><article><details class="docstring" open="true"><summary id="FLORIDyn.Yaw_Constant"><a class="docstring-binding" href="#FLORIDyn.Yaw_Constant"><code>FLORIDyn.Yaw_Constant</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Yaw_Constant &lt;: ControllerModel</code></pre><p>A marker struct used to represent a constant yaw control strategy. In this mode, turbines maintain a fixed yaw angle throughout the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/controller/structs_controller.jl#L16-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Yaw_InterpTurbine"><a class="docstring-binding" href="#FLORIDyn.Yaw_InterpTurbine"><code>FLORIDyn.Yaw_InterpTurbine</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Yaw_InterpTurbine &lt;: ControllerModel</code></pre><p>A marker struct used to indicate yaw control with turbine interpolation. This mode allows for interpolated yaw angles across different turbine positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/controller/structs_controller.jl#L24-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Yaw_SOWFA"><a class="docstring-binding" href="#FLORIDyn.Yaw_SOWFA"><code>FLORIDyn.Yaw_SOWFA</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Yaw_SOWFA &lt;: ControllerModel</code></pre><p>A marker struct used to represent yaw control compatible with SOWFA (Simulator fOr Wind Farm Applications). This mode is specifically designed for integration with SOWFA simulation data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/controller/structs_controller.jl#L32-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Induction_Constant"><a class="docstring-binding" href="#FLORIDyn.Induction_Constant"><code>FLORIDyn.Induction_Constant</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Induction_Constant &lt;: InductionModel</code></pre><p>A marker struct used to represent a constant induction factor control strategy. In this mode, all turbines maintain a fixed induction factor throughout the simulation. The constant induction value is typically provided via the control data matrix, where only the first element <code>con_induction_data[1,1]</code> is used for all turbines and time steps.</p><p><strong>Usage</strong></p><p>This controller type is used with the <code>getInduction</code> function to provide constant induction factors for wind farm control strategies.</p><p><strong>See Also</strong></p><ul><li><a href="../functions/#FLORIDyn.getInduction"><code>getInduction</code></a>: Function for retrieving induction factors</li><li><a href="#FLORIDyn.Induction_TGC"><code>Induction_TGC</code></a>: Alternative controller for time-varying induction control</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/controller/structs_controller.jl#L42-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.Induction_TGC"><a class="docstring-binding" href="#FLORIDyn.Induction_TGC"><code>FLORIDyn.Induction_TGC</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Induction_TGC &lt;: InductionModel</code></pre><p>A marker struct used to represent a time-varying induction factor control strategy compatible with  Model Predictive Control (TGC) approaches. In this mode, turbines can have different induction  factors that vary over time according to a predefined control schedule.</p><p>The induction factors are provided via a control data matrix where:</p><ul><li>First column contains time values (in seconds)</li><li>Subsequent columns contain induction factors for each turbine (dimensionless, typically 0.0-0.5)</li></ul><p>The controller uses linear interpolation between time points with flat extrapolation for  out-of-bounds time values.</p><p><strong>Usage</strong></p><p>This controller type is used with the <code>getInduction</code> function to provide time-varying induction factors for advanced wind farm control strategies, such as wake steering and power optimization through axial induction control.</p><p><strong>Data Format</strong></p><p>The control data matrix should have the structure:</p><pre><code class="language-julia hljs">[time₁  induction₁₁  induction₁₂  ...  induction₁ₙ]
[time₂  induction₂₁  induction₂₂  ...  induction₂ₙ]
[  ⋮        ⋮            ⋮        ⋱       ⋮     ]
[timeₘ  inductionₘ₁  inductionₘ₂  ...  inductionₘₙ]</code></pre><p>where <code>m</code> is the number of time steps and <code>n</code> is the number of turbines.</p><p><strong>See Also</strong></p><ul><li><a href="../functions/#FLORIDyn.getInduction"><code>getInduction</code></a>: Function for retrieving induction factors with interpolation</li><li><a href="#FLORIDyn.Induction_Constant"><code>Induction_Constant</code></a>: Alternative controller for constant induction control</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/controller/structs_controller.jl#L60-L92">source</a></section></details></article><h2 id="Defining-the-OP-iteration-model"><a class="docs-heading-anchor" href="#Defining-the-OP-iteration-model">Defining the OP iteration model</a><a id="Defining-the-OP-iteration-model-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-OP-iteration-model" title="Permalink"></a></h2><p>An instance of these structs needs to be passed to the functions that iterate observation points (OPs) through the wind field. They are all subtypes of <a href="#FLORIDyn.IterateOPs_model"><code>IterateOPs_model</code></a></p><article><details class="docstring" open="true"><summary id="FLORIDyn.IterateOPs_average"><a class="docstring-binding" href="#FLORIDyn.IterateOPs_average"><code>FLORIDyn.IterateOPs_average</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterateOPs_average &lt;: IterateOPs_model</code></pre><p>Observation point iteration model using averaged dynamics.</p><p>This iteration strategy employs averaging techniques to advance observation  points through the wind field, providing enhanced numerical stability and  smoother wake evolution compared to basic methods.</p><p><strong>Algorithm Characteristics</strong></p><ul><li><strong>Stability</strong>: Improved numerical stability through temporal averaging</li><li><strong>Smoothness</strong>: Reduces oscillations in wake dynamics</li><li><strong>Computational Cost</strong>: Moderate overhead due to averaging operations</li><li><strong>Accuracy</strong>: Good balance between stability and physical representation</li></ul><p><strong>Use Cases</strong></p><p>Recommended for:</p><ul><li>Simulations requiring smooth wake evolution</li><li>Cases with high turbulence or complex wind conditions</li><li>Long-duration simulations where stability is critical</li><li>Research applications focusing on ensemble statistics</li></ul><p><strong>Mathematical Approach</strong></p><p>The averaging process involves temporal or spatial averaging of  relevant quantities (velocities, deflections, turbulence) before applying  the advancement step, resulting in more stable observation point trajectories.</p><p><strong>Notes</strong></p><p>This model may require additional computational resources compared to basic  methods but provides better stability characteristics for challenging  simulation scenarios.</p><p><strong>WARNING</strong></p><p><strong>Not yet implemented</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/structs.jl#L38-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.IterateOPs_basic"><a class="docstring-binding" href="#FLORIDyn.IterateOPs_basic"><code>FLORIDyn.IterateOPs_basic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterateOPs_basic &lt;: IterateOPs_model</code></pre><p>Basic observation point iteration model with simple time-stepping.</p><p>This is the fundamental iteration strategy that advances observation points  using direct time-stepping based on local wind velocities and wake deflection  effects. It provides the core functionality for FLORIDyn simulations.</p><p><strong>Algorithm Characteristics</strong></p><ul><li><strong>Simplicity</strong>: Straightforward implementation with minimal overhead</li><li><strong>Performance</strong>: Fastest execution among available iteration models</li><li><strong>Accuracy</strong>: Direct physical representation of wake advection</li><li><strong>Memory</strong>: Minimal memory requirements</li></ul><p><strong>Implementation</strong></p><p>The basic algorithm performs:</p><ol><li>Downwind advection based on local wind speed</li><li>Crosswind deflection using wake centerline calculations</li><li>Coordinate transformation to world coordinates</li><li>Temporal advancement through circular shifting</li><li>Spatial reordering to maintain downstream position order</li></ol><p><strong>Use Cases</strong></p><p>Recommended for:</p><ul><li>Standard wind farm simulations</li><li>Performance-critical applications</li><li>Validation studies against reference data</li><li>Initial model development and testing</li></ul><p><strong>Mathematical Foundation</strong></p><p>Uses explicit time-stepping with:</p><pre><code class="language-julia hljs">Δx = U × Δt × advection_factor</code></pre><p>where observation points move downstream based on local wind conditions.</p><p><strong>Notes</strong></p><p>This model serves as the reference implementation and baseline for  comparison with other iteration strategies. See <a href="../functions_II/#FLORIDyn.iterateOPs!"><code>iterateOPs!</code></a> for detailed implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/structs.jl#L75-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.IterateOPs_buffer"><a class="docstring-binding" href="#FLORIDyn.IterateOPs_buffer"><code>FLORIDyn.IterateOPs_buffer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterateOPs_buffer &lt;: IterateOPs_model</code></pre><p>Observation point iteration model with buffered memory management.</p><p>This iteration strategy implements buffering techniques to optimize memory  usage and computational efficiency during observation point advancement,  particularly beneficial for large-scale wind farm simulations.</p><p><strong>Algorithm Characteristics</strong></p><ul><li><strong>Memory Efficiency</strong>: Optimized memory access patterns</li><li><strong>Scalability</strong>: Better performance for large numbers of observation points</li><li><strong>Caching</strong>: Intelligent buffering of frequently accessed data</li><li><strong>Computational Cost</strong>: Reduced overhead for memory-intensive operations</li></ul><p><strong>Use Cases</strong></p><p>Recommended for:</p><ul><li>Large wind farms with many turbines</li><li>Memory-constrained computing environments</li><li>High-resolution simulations with dense observation point grids</li><li>Production simulations requiring optimal resource utilization</li></ul><p><strong>Implementation Strategy</strong></p><p>The buffering approach manages observation point data through:</p><ul><li>Efficient memory allocation patterns</li><li>Reduced data copying operations</li><li>Optimized access to state matrices</li><li>Strategic caching of intermediate results</li></ul><p><strong>Performance Benefits</strong></p><ul><li>Improved cache locality for better CPU performance</li><li>Reduced memory bandwidth requirements</li><li>Better scaling with problem size</li><li>Lower memory fragmentation</li></ul><p><strong>Notes</strong></p><p>This model is particularly effective when computational resources are  limited or when dealing with very large simulation domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/structs.jl#L119-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.IterateOPs_maximum"><a class="docstring-binding" href="#FLORIDyn.IterateOPs_maximum"><code>FLORIDyn.IterateOPs_maximum</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterateOPs_maximum &lt;: IterateOPs_model</code></pre><p>Observation point iteration model using maximum value selection.</p><p>This iteration strategy employs maximum value-based decision making during  observation point advancement, potentially useful for conservative estimates  or worst-case scenario analysis in wind farm simulations.</p><p><strong>Algorithm Characteristics</strong></p><ul><li><strong>Conservative Approach</strong>: Tends toward maximum/conservative values</li><li><strong>Robustness</strong>: Provides bounds on simulation behavior</li><li><strong>Special Cases</strong>: Handles extreme conditions effectively</li><li><strong>Analysis</strong>: Useful for sensitivity and worst-case studies</li></ul><p><strong>Use Cases</strong></p><p>Recommended for:</p><ul><li>Conservative design analysis</li><li>Worst-case scenario evaluation</li><li>Risk assessment studies</li><li>Validation of simulation bounds</li><li>Research on extreme wind conditions</li></ul><p><strong>Mathematical Approach</strong></p><p>The maximum selection process applies maximum operators to relevant  quantities during the iteration step, which may include:</p><ul><li>Maximum wind speeds in the vicinity</li><li>Maximum deflection values</li><li>Maximum turbulence intensities</li><li>Conservative time step selection</li></ul><p><strong>Applications</strong></p><p>Particularly useful in:</p><ul><li>Safety factor determination</li><li>Conservative power estimation</li><li>Extreme load analysis</li><li>Uncertainty quantification studies</li></ul><p><strong>Notes</strong></p><p>This model may produce more conservative results compared to other  iteration strategies and should be used when understanding bounds  on simulation behavior is important.</p><p><strong>WARNING</strong></p><p><strong>Not yet implemented</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/structs.jl#L160-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.IterateOPs_weighted"><a class="docstring-binding" href="#FLORIDyn.IterateOPs_weighted"><code>FLORIDyn.IterateOPs_weighted</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterateOPs_weighted &lt;: IterateOPs_model</code></pre><p>Observation point iteration model using weighted interpolation.</p><p>This iteration strategy employs sophisticated weighted interpolation  techniques to advance observation points, providing enhanced accuracy  through spatial and temporal weighting of relevant physical quantities.</p><p><strong>Algorithm Characteristics</strong></p><ul><li><strong>High Accuracy</strong>: Superior interpolation accuracy</li><li><strong>Smoothness</strong>: Smooth transitions between observation points</li><li><strong>Computational Cost</strong>: Higher due to interpolation calculations</li><li><strong>Flexibility</strong>: Adaptable weighting schemes</li></ul><p><strong>Use Cases</strong></p><p>Recommended for:</p><ul><li>High-accuracy research simulations</li><li>Detailed wake interaction studies</li><li>Validation against experimental data</li><li>Applications requiring smooth field representations</li><li>Advanced control algorithm development</li></ul><p><strong>Interpolation Strategy</strong></p><p>The weighted approach typically involves:</p><ul><li>Distance-based spatial weighting</li><li>Temporal interpolation of quantities</li><li>Multi-point interpolation schemes</li><li>Adaptive weight calculation based on local conditions</li></ul><p><strong>Mathematical Foundation</strong></p><p>Uses interpolation weights w_i such that:</p><pre><code class="language-julia hljs">quantity_interpolated = Σ w_i × quantity_i</code></pre><p>where weights satisfy Σ w_i = 1 and are computed based on distance,  time, or other relevant metrics.</p><p><strong>Accuracy Benefits</strong></p><ul><li>Reduced numerical diffusion</li><li>Better preservation of wake structures</li><li>Improved representation of turbulence effects</li><li>Enhanced spatial resolution</li></ul><p><strong>Notes</strong></p><p>This model provides the highest accuracy among available iteration  strategies but requires additional computational resources. Best suited  for applications where accuracy is prioritized over computational speed.</p><p><strong>WARNING</strong></p><p><strong>Not yet implemented</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/structs.jl#L208-L259">source</a></section></details></article><h2 id="Types-for-storing-wind-field-params"><a class="docs-heading-anchor" href="#Types-for-storing-wind-field-params">Types for storing wind field params</a><a id="Types-for-storing-wind-field-params-1"></a><a class="docs-heading-anchor-permalink" href="#Types-for-storing-wind-field-params" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="FLORIDyn.WindDirType"><a class="docstring-binding" href="#FLORIDyn.WindDirType"><code>FLORIDyn.WindDirType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs"> WindDirType</code></pre><p><strong>Fields</strong></p><ul><li>Data::Float64: wind direction value</li><li>CholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/FLORIDyn.jl#L231-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.WindDirMatrix"><a class="docstring-binding" href="#FLORIDyn.WindDirMatrix"><code>FLORIDyn.WindDirMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct WindDirMatrix</code></pre><p><strong>Fields</strong></p><ul><li><code>Data</code>::Matrix{Float64}:    Columns [time, phi] or [time, <code>phi_T0</code>, <code>phi_T1</code>, ... <code>phi_Tn</code>]</li><li><code>CholSig</code>::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/FLORIDyn.jl#L255-L261">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.WindDirTriple"><a class="docstring-binding" href="#FLORIDyn.WindDirTriple"><code>FLORIDyn.WindDirTriple</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WindDirTriple</code></pre><p>A structure containing the three key parameters for wind direction modeling with mean reversion.</p><p>This struct is specifically designed for the <code>Direction_RW_with_Mean</code> wind direction mode,  which implements a random walk with mean reversion model. The model captures both  stochastic wind direction variability and the tendency for wind to return to prevailing  climatological directions over time.</p><p><strong>Fields</strong></p><ul><li><code>Init::Vector{Float64}</code>: Target/equilibrium wind directions for each turbine [°]. These represent the long-term average or expected wind directions  that the system tends to revert toward. Each element corresponds to one turbine.</li><li><code>CholSig::Matrix{Float64}</code>: Cholesky decomposition of the covariance matrix (nT × nT). This matrix encodes both the magnitude of random fluctuations and the spatial  correlations between turbines. It allows for:<ul><li>Different noise levels for different turbines (diagonal elements)</li><li>Cross-correlations between nearby turbines (off-diagonal elements)</li></ul></li><li><code>MeanPull::Float64</code>: Mean reversion strength parameter [0, 1]. Controls how strongly wind directions are pulled back toward their target values:<ul><li><code>0.0</code>: No mean reversion (pure random walk)</li><li><code>1.0</code>: Maximum reversion (immediate return to target)</li><li>Typical values: <code>0.1</code> to <code>0.3</code> for realistic wind behavior</li></ul></li></ul><p><strong>Mathematical Model</strong></p><p>The wind direction evolves according to:     φ(t+1) = φ(t) + CholSig × ε + MeanPull × (Init - φ(t)) where <code>ε</code> is a vector of independent standard normal random variables.</p><p><strong>Physical Interpretation</strong></p><ul><li><strong>Meteorological realism</strong>: <code>Init</code> represents seasonal/geographic wind patterns</li><li><strong>Spatial correlation</strong>: <code>CholSig</code> models how wind direction changes are correlated across the wind farm</li><li><strong>Temporal persistence</strong>: <code>MeanPull</code> controls how quickly wind returns to prevailing patterns</li></ul><p><strong>Constructor Example</strong></p><pre><code class="language-julia hljs"># Three turbines with westerly prevailing winds
wind_triple = WindDirTriple(
    Init=[270.0, 275.0, 270.0],           # Slightly different targets per turbine
    CholSig=0.5 * I(3) + 0.2 * ones(3,3), # 0.5° individual + 0.2° shared noise
    MeanPull=0.15                         # 15% reversion per time step
)</code></pre><p><strong>Usage</strong></p><p>This struct is used with the <code>Direction_RW_with_Mean</code> mode in wind field configurations:     wind = Wind(         input_dir=&quot;RW_with_Mean&quot;,         dir=wind_triple     )</p><p>See also: <a href="#FLORIDyn.Direction_RW_with_Mean"><code>Direction_RW_with_Mean</code></a>, <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/FLORIDyn.jl#L279-L332">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.WindVelType"><a class="docstring-binding" href="#FLORIDyn.WindVelType"><code>FLORIDyn.WindVelType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs"> WindVelType</code></pre><p><strong>Fields</strong></p><ul><li>Data::Float64: wind speed</li><li>CholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/FLORIDyn.jl#L243-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.WindVelMatrix"><a class="docstring-binding" href="#FLORIDyn.WindVelMatrix"><code>FLORIDyn.WindVelMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct WindVelMatrix</code></pre><p><strong>Fields</strong></p><ul><li>Data::Matrix{Float64}:    Nx2 matrix: column 1 = time, column 2 = wind speed</li><li>CholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/FLORIDyn.jl#L267-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.WindShear"><a class="docstring-binding" href="#FLORIDyn.WindShear"><code>FLORIDyn.WindShear</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WindShear</code></pre><p>A struct representing the wind shear profile. This type is used to model the variation of wind speed with height,  which is important in atmospheric and wind energy simulations.</p><p><strong>Fields</strong></p><ul><li>z0::Float64: Reference height (not used in the <a href="../functions/#FLORIDyn.getWindShearT"><code>getWindShearT</code></a>)</li><li>alpha::Float64: WindShear coefficient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/FLORIDyn.jl#L216-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.WindCorrection"><a class="docstring-binding" href="#FLORIDyn.WindCorrection"><code>FLORIDyn.WindCorrection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WindCorrection</code></pre><p>A struct defining wind field correction options for wind farm simulations.</p><p>Wind corrections modify how wind conditions are applied across the wind farm, allowing for  different strategies to handle spatial and temporal variations in wind fields.</p><p><strong>Fields</strong></p><ul><li><code>vel::String</code>: Velocity correction method. Options:<ul><li><code>&quot;None&quot;</code>: No velocity correction applied (default)</li><li><code>&quot;Influence&quot;</code>: Apply velocity corrections based on wake influence</li></ul></li><li><code>dir::String</code>: Wind direction correction method. Options:<ul><li><code>&quot;None&quot;</code>: No direction correction applied</li><li><code>&quot;All&quot;</code>: All operating points (OPs) assigned the same wind direction (default) The value is based on the first returned value of the wind direction input</li><li><code>&quot;Influence&quot;</code>: Apply direction corrections based on wake influence</li></ul></li><li><code>ti::String</code>: Turbulence intensity correction method. Options:<ul><li><code>&quot;None&quot;</code>: No turbulence intensity correction applied (default)</li><li><code>&quot;Influence&quot;</code>: Apply turbulence intensity corrections based on wake influence</li></ul></li></ul><p><strong>Constructor</strong></p><p>The struct uses <code>@with_kw</code> macro, allowing keyword-only construction.</p><p><strong>Notes</strong></p><ul><li>The <code>&quot;All&quot;</code> option for direction correction ensures spatial consistency across the wind farm</li><li>The <code>&quot;Influence&quot;</code> option allows for more sophisticated wake-based corrections</li><li>Corrections are applied during the simulation to modify local wind conditions</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Default configuration
correction = WindCorrection(vel=&quot;None&quot;, dir=&quot;All&quot;, ti=&quot;None&quot;)

# With influence-based corrections
correction = WindCorrection(vel=&quot;Influence&quot;, dir=&quot;Influence&quot;, ti=&quot;Influence&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/settings.jl#L78-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.WindPerturbation"><a class="docstring-binding" href="#FLORIDyn.WindPerturbation"><code>FLORIDyn.WindPerturbation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WindPerturbation</code></pre><p>A mutable struct for configuring stochastic wind perturbations in wind farm simulations.</p><p>This struct controls whether perturbations are applied to different wind parameters and defines the magnitude of these perturbations using standard deviations. Wind perturbations are used to  model uncertainty in wind measurements or to perform sensitivity analysis.</p><p><strong>Fields</strong></p><ul><li><code>vel::Bool</code>: Enable/disable velocity perturbations. When <code>true</code>, random perturbations are applied to wind velocity.</li><li><code>vel_sigma::Float64</code>: Standard deviation for velocity perturbations [m/s]. Determines the magnitude of random variations added to the wind velocity.</li><li><code>dir::Bool</code>: Enable/disable direction perturbations. When <code>true</code>, random perturbations are applied to wind direction.</li><li><code>dir_sigma::Float64</code>: Standard deviation for direction perturbations [degrees]. Determines the magnitude of random variations added to the wind direction.</li><li><code>ti::Bool</code>: Enable/disable turbulence intensity perturbations. When <code>true</code>, random perturbations are applied to turbulence intensity.</li><li><code>ti_sigma::Float64</code>: Standard deviation for turbulence intensity perturbations [-]. Determines the magnitude of random variations added to the turbulence intensity.</li></ul><p><strong>Notes</strong></p><ul><li>Perturbations are typically applied as additive Gaussian noise with zero mean and the specified standard deviation</li><li>The perturbation flags (<code>vel</code>, <code>dir</code>, <code>ti</code>) act as switches to enable or disable specific types of perturbations</li><li>Setting a flag to <code>false</code> will disable perturbations for that parameter regardless of the sigma value</li><li>Standard deviations should be positive values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/settings.jl#L46-L68">source</a></section></details></article><h2 id="Other-types"><a class="docs-heading-anchor" href="#Other-types">Other types</a><a id="Other-types-1"></a><a class="docs-heading-anchor-permalink" href="#Other-types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="FLORIDyn.MSR"><a class="docstring-binding" href="#FLORIDyn.MSR"><code>FLORIDyn.MSR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MSR `VelReduction` `AddedTurbulence` `EffWind`</code></pre><p>Enumeration that selects which (scalar) quantity is visualised / stored when plotting or saving flow field measurements. The acronym stands for Measurement System Representation. Passed via the <code>msr</code> keyword to <a href="../functions_II/#FLORIDyn.run_floridyn"><code>run_floridyn</code></a> and the plotting helpers <a href="../functions_II/#FLORIDyn.plot_flow_field"><code>plot_flow_field</code></a>, <a href="../functions_II/#FLORIDyn.plot_measurements"><code>plot_measurements</code></a>.</p><p><strong>Elements</strong></p><ul><li><code>VelReduction</code>    (1): Velocity reduction (1 - u / u_ref) downstream of turbines.</li><li><code>AddedTurbulence</code> (2): Added turbulence intensity contributed by wakes (ΔTI component).</li><li><code>EffWind</code>         (3): Effective wind speed at turbine locations (including wake effects).</li></ul><p><strong>Usage</strong></p><pre><code class="language-julia hljs"># Use default (VelReduction)
run_floridyn(plt, set, wf, wind, sim, con, vis, floridyn, floris)

# Explicitly request added turbulence visualisation
run_floridyn(plt, set, wf, wind, sim, con, vis, floridyn, floris; msr=AddedTurbulence)

# Convert from a user string (e.g. parsed CLI / YAML value)
msr = toMSR(&quot;EffWind&quot;)
run_floridyn(plt, set, wf, wind, sim, con, vis, floridyn, floris; msr)</code></pre><p>See also: <a href="../functions/#FLORIDyn.toMSR"><code>toMSR</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/FLORIDyn.jl#L68-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.States"><a class="docstring-binding" href="#FLORIDyn.States"><code>FLORIDyn.States</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">States</code></pre><p>Lightweight container for state variable names and counts used in wind farm simulations.</p><p>This mutable struct organizes the state variables into three categories: turbine states, observation point (OP) states, and wind field (WF) states. It provides both the variable names and their counts for efficient memory allocation and state management.</p><p><strong>Fields</strong></p><ul><li><code>T_names::Vector{String}</code>: Names of turbine state variables [&quot;a&quot;, &quot;yaw&quot;, &quot;TI&quot;]</li><li><code>Turbine::Int</code>: Number of turbine state variables (3)</li><li><code>OP_names::Vector{String}</code>: Names of observation point variables [&quot;x0&quot;, &quot;y0&quot;, &quot;z0&quot;, &quot;x1&quot;, &quot;y1&quot;, &quot;z1&quot;]</li><li><code>OP::Int</code>: Number of observation point variables (6)</li><li><code>WF_names::Vector{String}</code>: Names of wind field variables [&quot;wind<em>vel&quot;, &quot;wind</em>dir&quot;, &quot;TI0&quot;]</li><li><code>WF::Int</code>: Number of wind field variables (3)</li></ul><p><strong>Constructor</strong></p><p>Use the default constructor <a href="#FLORIDyn.States"><code>States()</code></a> to create an instance with predefined variable names and counts currently used by FLORIDyn.jl.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">states = States()
println(&quot;Turbine states: &quot;, states.T_names)
println(&quot;Number of turbine states: &quot;, states.Turbine)</code></pre><p><strong>State Variable Definitions</strong></p><p><strong>Turbine States (T_names)</strong></p><ul><li><code>&quot;a&quot;</code>: Axial induction factor [-]</li><li><code>&quot;yaw&quot;</code>: Yaw angle [degrees]</li><li><code>&quot;TI&quot;</code>: Local turbulence intensity [-]</li></ul><p><strong>Observation Point States (OP_names)</strong></p><ul><li><code>&quot;x0&quot;, &quot;y0&quot;, &quot;z0&quot;</code>: Initial position coordinates [m]</li><li><code>&quot;x1&quot;, &quot;y1&quot;, &quot;z1&quot;</code>: Final position coordinates [m]</li></ul><p><strong>Wind Field States (WF_names)</strong></p><ul><li><code>&quot;wind_vel&quot;</code>: Wind velocity [m/s]</li><li><code>&quot;wind_dir&quot;</code>: Wind direction [degrees]</li><li><code>&quot;TI0&quot;</code>: Ambient turbulence intensity [-]</li></ul><p>See also: <a href="#FLORIDyn.States"><code>States()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floris/gaussian.jl#L247-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.UnifiedBuffers"><a class="docstring-binding" href="#FLORIDyn.UnifiedBuffers"><code>FLORIDyn.UnifiedBuffers</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnifiedBuffers</code></pre><p>Unified buffer struct containing all arrays needed by interpolateOPs! and setUpTmpWFAndRun!.</p><p><strong>Fields</strong></p><ul><li><code>dist_buffer::Vector{Float64}</code>: Distance calculations for interpolateOPs!</li><li><code>sorted_indices_buffer::Vector{Int}</code>: Sorted indices for interpolateOPs!</li><li><code>M_buffer::Matrix{Float64}</code>: Main result buffer for setUpTmpWFAndRun!</li><li><code>iTWFState_buffer::Vector{Float64}</code>: Turbine wind field state buffer</li><li><code>tmp_Tpos_buffer::Matrix{Float64}</code>: Temporary turbine position buffer</li><li><code>tmp_WF_buffer::Matrix{Float64}</code>: Temporary wind field buffer</li><li><code>tmp_Tst_buffer::Matrix{Float64}</code>: Temporary turbine state buffer</li><li><code>dists_buffer::Vector{Float64}</code>: Distance buffer for setUpTmpWFAndRun!</li><li><code>plot_WF_buffer::Matrix{Float64}</code>: Wind field plotting buffer</li><li><code>plot_OP_buffer::Matrix{Float64}</code>: Observation point plotting buffer</li><li><code>floris_buffers</code>: Pre-allocated FLORIS computation buffers for wind wake calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/structs.jl#L322-L339">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.IterateOPsBuffers"><a class="docstring-binding" href="#FLORIDyn.IterateOPsBuffers"><code>FLORIDyn.IterateOPsBuffers</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IterateOPsBuffers</code></pre><p>A struct containing pre-allocated buffers for allocation-free execution of iterateOPs!.</p><p>This struct eliminates all allocations during the observation point iteration by  pre-allocating all necessary temporary arrays. It should be created once and reused across multiple calls to iterateOPs! for maximum performance.</p><p><strong>Fields</strong></p><ul><li><code>tmpOPStates::Matrix{Float64}</code>: Buffer for saving turbine observation point states  </li><li><code>tmpTStates::Matrix{Float64}</code>: Buffer for saving turbine states</li><li><code>tmpWFStates::Matrix{Float64}</code>: Buffer for saving wind farm states</li><li><code>step_dw::Vector{Float64}</code>: Buffer for downwind step calculations</li><li><code>deflection::Matrix{Float64}</code>: Buffer for centerline deflection calculations  </li><li><code>step_cw::Matrix{Float64}</code>: Buffer for crosswind step calculations</li><li><code>temp_states_op::Matrix{Float64}</code>: Temporary buffer for States_OP circular shifting</li><li><code>temp_states_t::Matrix{Float64}</code>: Temporary buffer for States_T circular shifting  </li><li><code>temp_states_wf::Matrix{Float64}</code>: Temporary buffer for States_WF circular shifting</li><li><code>sort_buffer::Vector{Int}</code>: Buffer for sorting observation points</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">IterateOPsBuffers(wf::WindFarm)</code></pre><p>Creates buffers appropriately sized for the given WindFarm object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floridyn_cl/iterate.jl#L30-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.FLORISBuffers"><a class="docstring-binding" href="#FLORIDyn.FLORISBuffers"><code>FLORIDyn.FLORISBuffers</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FLORISBuffers</code></pre><p>Pre-allocated buffers for the runFLORIS! computation to minimize allocations.</p><p>This struct also persists result arrays so callers can read outputs without allocations. After calling <code>runFLORIS!</code>, the following fields contain results:</p><p><strong>Output Fields</strong></p><ul><li><code>T_red_arr::Vector{Float64}</code>: Per-turbine velocity reduction factors. For a   single-turbine run, length is 1 and <code>T_red_arr[1]</code> is the scalar reduction.</li><li><code>T_aTI_arr::Vector{Float64}</code>: Added turbulence intensity from upstream wakes.   For N turbines, length is <code>max(N-1, 0)</code>. Empty for single-turbine runs.</li><li><code>T_Ueff::Vector{Float64}</code>: Effective wind speed at the last turbine as a   length-1 vector (multi-turbine case). Empty for single-turbine runs.</li><li><code>T_weight::Vector{Float64}</code>: Gaussian weight factors used for wake overlap.   For N turbines, length is <code>max(N-1, 0)</code>. Empty for single-turbine runs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/2f1bea0325c39f8b88b8bb01eefe54b9c900f216/src/floris/structs_floris.jl#L4-L21">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../functions/">Low-Level Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 16 December 2025 14:20">Tuesday 16 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
