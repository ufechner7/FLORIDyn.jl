<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High-Level Functions · FLORIDyn.jl</title><meta name="title" content="High-Level Functions · FLORIDyn.jl"/><meta property="og:title" content="High-Level Functions · FLORIDyn.jl"/><meta property="twitter:title" content="High-Level Functions · FLORIDyn.jl"/><meta name="description" content="Documentation for FLORIDyn.jl."/><meta property="og:description" content="Documentation for FLORIDyn.jl."/><meta property="twitter:description" content="Documentation for FLORIDyn.jl."/><meta property="og:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><meta property="twitter:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><link rel="canonical" href="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><meta property="og:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FLORIDyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLORIDyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">Exported Types</a></li><li><a class="tocitem" href="../functions/">Low-Level Functions</a></li><li class="is-active"><a class="tocitem" href>High-Level Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#FLORIS"><span>FLORIS</span></a></li><li class="toplevel"><a class="tocitem" href="#FLORIDyn"><span>FLORIDyn</span></a></li><li class="toplevel"><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li class="toplevel"><a class="tocitem" href="#Video-Creation"><span>Video Creation</span></a></li></ul></li><li><a class="tocitem" href="../settings/">Settings</a></li><li><a class="tocitem" href="../video_creation/">Video Creation</a></li><li><a class="tocitem" href="../user_guide/">User Guide</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../developer/">Developer notes</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>High-Level Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High-Level Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl/blob/main/docs/src/functions_II.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="High-Level-Functions"><a class="docs-heading-anchor" href="#High-Level-Functions">High-Level Functions</a><a id="High-Level-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Functions" title="Permalink"></a></h1><h1 id="FLORIS"><a class="docs-heading-anchor" href="#FLORIS">FLORIS</a><a id="FLORIS-1"></a><a class="docs-heading-anchor-permalink" href="#FLORIS" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.calcCt"><a class="docstring-binding" href="#FLORIDyn.calcCt"><code>FLORIDyn.calcCt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calcCt(a::Number, _) -&gt; Float64
calcCt(a::AbstractVector, _) -&gt; AbstractVector</code></pre><p>Calculate the thrust coefficient ct = 4a(1-a).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/gaussian.jl#L23-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.centerline!"><a class="docstring-binding" href="#FLORIDyn.centerline!"><code>FLORIDyn.centerline!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">centerline!(deflection::AbstractMatrix,
            states_op, states_t, states_wf, floris::Floris, d_rotor)</code></pre><p>Compute the cross-wind wake deflection at the observation points in-place using the Gaussian wake model.</p><p>This function calculates the lateral (y) and vertical (z) deflection of the wake centerline  due to yaw misalignment and other effects. The results are written directly into the provided  deflection matrix without allocating temporary arrays.</p><p><strong>Output Arguments</strong></p><ul><li><code>deflection::AbstractMatrix</code> (size n×2): Wake deflection components filled in-place<ul><li>Column 1: Lateral deflection Δy <code>[m]</code>  </li><li>Column 2: Vertical deflection Δz <code>[m]</code> (always zero in current implementation)</li></ul></li></ul><p><strong>Input Arguments</strong></p><ul><li><code>states_op::AbstractMatrix</code> (size n×k): Observation point states where n is number of points<ul><li>Column 4 contains downstream distance in wake-aligned coordinates <code>[m]</code></li></ul></li><li><code>states_t::AbstractMatrix</code>: Turbine state matrix containing:<ul><li>Column 1: Axial induction factor a <code>[-]</code></li><li>Column 2: Yaw angle <code>[degrees]</code></li><li>Column 3: Local turbulence intensity TI <code>[-]</code></li></ul></li><li><code>states_wf::AbstractMatrix</code>: Wind field state matrix containing:<ul><li>Column 3: Ambient turbulence intensity TI₀ <code>[-]</code></li></ul></li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>d_rotor::Real</code>: Rotor diameter D <code>[m]</code></li></ul><p><strong>Notes</strong></p><ul><li>Only <code>states_op[:, 4]</code> (downstream distance) is used from the observation points</li><li>The function internally converts yaw angles from degrees to radians with sign correction</li><li>Thrust coefficient is calculated from axial induction factor using <code>calcCt</code></li></ul><p>See also: <a href="#FLORIDyn.getVars!"><code>getVars!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/gaussian.jl#L182-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.discretizeRotor"><a class="docstring-binding" href="#FLORIDyn.discretizeRotor"><code>FLORIDyn.discretizeRotor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">discretizeRotor(n_rp::Int) -&gt; Tuple{Matrix{Float64}, Vector{Float64}}</code></pre><p>Discretizes the rotor into <code>n_rp</code> segments using the isocell algorithm.</p><p>Memoization: results are cached per thread. Repeated calls with the same <code>n_rp</code> on the same thread reuse the cached arrays (no lock needed). Do not mutate the returned arrays, as they are shared within the thread.</p><p><strong>Arguments</strong></p><ul><li><code>n_rp::Int</code>: The number of radial points to discretize the rotor into.</li></ul><p><strong>Returns</strong></p><ul><li><code>(m_rp, w)</code> where:<ul><li><code>m_rp::Matrix{Float64}</code>: Size <code>(nC, 3)</code>; first column zeros, columns 2–3 are normalized coordinates in <code>[-0.5, 0.5]</code>.</li><li><code>w::Vector{Float64}</code>: Weights per cell that sum to approximately 1.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Per-thread cache avoids contention; different threads may compute and hold their own cached copies for the same <code>n_rp</code>.</li><li>The isocell algorithm may not yield exactly <code>n_rp</code> cells but aims for a similar number.</li><li>For details, see: Masset et al. (2009) https://orbi.uliege.be/bitstream/2268/91953/1/masset<em>isocell</em>orbi.pdf</li><li>The choice <code>N1 = 3</code> is used here; values of 4 or 5 are also viable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/discretization.jl#L22-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.init_states"><a class="docstring-binding" href="#FLORIDyn.init_states"><code>FLORIDyn.init_states</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init_states(set::Settings, wf::WindFarm, wind::Wind, init_turb, 
            floris::Floris, sim::Sim) -&gt; Tuple{Matrix, Matrix, Matrix}</code></pre><p>Initialize the state arrays for wind farm simulation using the Gaussian wake model.</p><p>This function sets up the initial conditions for turbines, observation points, and wind field  states based on the provided configuration parameters. It computes initial positions, wind  conditions, and wake properties for each turbine in the wind farm.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options for velocity, direction, and turbulence models</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, dimensions, and state arrays (see <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>)</li><li><code>wind::Wind</code>: Wind conditions including velocity, direction, and turbulence intensity data (see <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>)</li><li><code>init_turb</code>: Initial turbine state parameters (axial induction factor, yaw angle, turbulence intensity)</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>sim::Sim</code>: Simulation parameters including time step and start time (see <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a>)</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(states_op, states_t, states_wf)</code> containing:</p><ul><li><code>states_op::Matrix</code>: Observation point states with 3D coordinates and wake positions</li><li><code>states_t::Matrix</code>: Turbine states including control parameters and operational conditions  </li><li><code>states_wf::Matrix</code>: Wind field states with velocity, direction, and turbulence data</li></ul><p><strong>Description</strong></p><p>The function performs the following initialization steps for each turbine:</p><ol><li>Retrieves wind field data (velocity, direction, turbulence intensity) based on the specified input methods</li><li>Initializes wind field states at all observation points for the turbine</li><li>Calculates downwind distances for wake coordinate system</li><li>Sets initial turbine states from provided parameters</li><li>Computes crosswind wake deflections using the centerline function</li><li>Transforms coordinates from wake-relative to world coordinate system</li><li>Updates observation point positions including turbine base and nacelle offsets</li></ol><p><strong>Notes</strong></p><ul><li>Supports multiple wind input methods including interpolation, constant values, and random walk models</li><li>Handles both 3D and 4D wind field configurations (with optional orientation data)</li><li>Uses SOWFA coordinate system conventions for angle transformations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/gaussian.jl#L334-L372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.getVars!"><a class="docstring-binding" href="#FLORIDyn.getVars!"><code>FLORIDyn.getVars!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">    getVars!(sig_y, sig_z, x_0, delta, pc_y, pc_z, rps, c_t, yaw, ti, ti0, floris::Floris, d_rotor)</code></pre><p>Compute Gaussian wake widths, deflection, potential-core radii, and onset distance at observation points, in-place.</p><p><strong>Output Arguments</strong></p><ul><li><code>sig_y::AbstractVector{&lt;:Real}</code> (length n): Lateral Gaussian width σ_y at each point [m]</li><li><code>sig_z::AbstractVector{&lt;:Real}</code> (length n): Vertical Gaussian width σ_z at each point [m]</li><li><code>x_0::AbstractVector{&lt;:Real}</code> (length n): Onset distance of the far-wake x₀ [m]</li><li><code>delta::AbstractMatrix{&lt;:Real}</code> (length n×2): Deflection components <code>[Δy, Δz]</code> [m]</li><li><code>pc_y::AbstractVector{&lt;:Real}</code> (length n): Potential-core radius in y at each point [m]</li><li><code>pc_z::AbstractVector{&lt;:Real}</code> (length n): Potential-core radius in z at each point [m]</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>rps::AbstractMatrix</code> (n×3): Observation points in wake-aligned frame; columns are <code>[x_downstream, y_cross, z_cross]</code> [m]</li><li><code>c_t::Union{Number,AbstractVector}</code>: Thrust coefficient Ct (scalar or length n) [-]</li><li><code>yaw::Union{Number,AbstractVector}</code>: Yaw misalignment (scalar or length n) [rad]</li><li><code>ti::Union{Number,AbstractVector}</code>: Local turbulence intensity TI at turbine (scalar or length n) [-]</li><li><code>ti0::Union{Number,AbstractVector}</code>: Ambient turbulence intensity TI₀ (scalar or length n) [-]</li><li><code>floris::Floris</code>: FLORIS Gaussian model parameters; see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>d_rotor::Real</code>: Rotor diameter D [m]</li></ul><p><strong>Behavior</strong></p><ul><li>Supports scalar or per-point values for <code>c_t</code>, <code>yaw</code>, <code>ti</code>, <code>ti0</code>; scalars are broadcast to all points.</li><li>Uses <code>floris.k_a</code>, <code>floris.k_b</code>, <code>floris.alpha</code>, <code>floris.beta</code> to compute per-point   <code>x₀</code>, <code>σ_y</code>, <code>σ_z</code>, deflection <code>Δy</code> (here <code>Δz</code> is set to 0), and potential-core radii <code>pc_y</code>, <code>pc_z</code>.</li><li>No heap allocations beyond the provided outputs; results are written in-place and the function returns <code>nothing</code>.</li></ul><p><strong>Notes</strong></p><ul><li>Only <code>rps[:, 1]</code> (downstream distance) is used by this implementation; <code>rps[:, 2:3]</code> are ignored.</li><li><code>delta</code> must have at least 2 columns; only columns 1:2 are written.</li><li>Units: distances in meters, angles in radians, intensities and <code>Ct</code> are dimensionless.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">n = size(RPs, 1)
sig_y = similar(RPs[:, 1])
sig_z = similar(RPs[:, 1])
x0    = similar(RPs[:, 1])
delta = zeros(n, 2)
pc_y  = similar(RPs[:, 1])
pc_z  = similar(RPs[:, 1])
getVars!(sig_y, sig_z, x0, delta, pc_y, pc_z, RPs, Ct, yaw, TI, TI0, floris, D)</code></pre><p>Returns</p><ul><li><code>nothing</code> — all results are written into the provided arrays.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/gaussian.jl#L37-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.getPower"><a class="docstring-binding" href="#FLORIDyn.getPower"><code>FLORIDyn.getPower</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getPower(wf::WindFarm, m::AbstractMatrix, floris::Floris, con::Con)</code></pre><p>Calculate the power output of wind turbines in a wind farm simulation.</p><p>This function computes the power generated by wind turbines based on their operational states, wind conditions, and control settings. It accounts for yaw angle effects and optional yaw range constraints using hyperbolic tangent functions for smooth operational limits.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine states, dimensions, and operational data with current axial induction factors and yaw angles (see <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>)</li><li><code>m::Matrix</code>: Measurement or simulation data matrix where column 3 contains effective wind speeds at turbine locations [m/s]</li><li><code>floris::Floris</code>: FLORIS model parameters containing air density, drivetrain efficiency, and power curve parameters (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>con::Con</code>: Controller configuration object with yaw control settings and operational constraints (see <a href="../settings/#FLORIDyn.Con"><code>Con</code></a>)</li></ul><p><strong>Returns</strong></p><ul><li><code>P::Vector{Float64}</code>: Power output for each turbine in the wind farm [W]</li></ul><p><strong>Description</strong></p><p>The function calculates power using the standard wind turbine power equation with yaw corrections:</p><pre><code class="language-julia hljs">P = 0.5 × ρ × A × Cp × U³ × η × cos(γ)^p_p × f_yaw_constraints</code></pre><p>Where:</p><ul><li><code>ρ</code> is air density [<code>floris.airDen</code>] [kg/m³]</li><li><code>A</code> is rotor swept area <code>π × (D/2)²</code> [m²]</li><li><code>Cp</code> is power coefficient calculated as <code>4a(1-a)²</code> [-]</li><li><code>U</code> is effective wind speed from column 3 of matrix <code>m</code> [m/s]</li><li><code>η</code> is drivetrain efficiency [<code>floris.eta</code>] [-]</li><li><code>γ</code> is yaw angle [rad]</li><li><code>p_p</code> is yaw power exponent [<code>floris.p_p</code>] [-]</li><li><code>f_yaw_constraints</code> is optional yaw range constraint factor [-]</li></ul><p>The yaw constraint factor is applied when <code>con.tanh_yaw</code> is true:</p><pre><code class="language-julia hljs">f_yaw_constraints = [0.5 × tanh((γ_max - γ) × 50) + 0.5] × 
                           [-0.5 × tanh((γ_min - γ) × 50) + 0.5]</code></pre><p><strong>Notes</strong></p><ul><li>Power coefficient is calculated from axial induction factor: <code>Cp = 4a(1-a)²</code></li><li>Yaw effects reduce power output according to <code>cos(γ)^p_p</code> where <code>p_p</code> is typically 1.88</li><li>Optional yaw range constraints use hyperbolic tangent functions with slope factor 50 for smooth transitions</li><li>When <code>con.tanh_yaw</code> is enabled, power is smoothly constrained within [<code>con.yawRangeMin</code>, <code>con.yawRangeMax</code>]</li><li>The constraint functions approach step functions but provide smooth gradients for optimization</li><li>Axial induction factors are extracted from <code>wf.States_T[wf.StartI, 1]</code> for current time step</li><li>Yaw angles are converted from degrees to radians internally</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/gaussian.jl#L441-L490">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.runFLORIS!"><a class="docstring-binding" href="#FLORIDyn.runFLORIS!"><code>FLORIDyn.runFLORIS!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">runFLORIS!(buffers::FLORISBuffers, set::Settings, location_t, states_wf, states_t, d_rotor, 
           floris, windshear::Union{Matrix, WindShear})</code></pre><p>Execute the FLORIS (FLOw Redirection and Induction in Steady State) wake model simulation for wind farm analysis.</p><p>This is the main orchestrating function that coordinates the FLORIS wake model execution through  a series of specialized sub-functions. It performs wake analysis using the Gaussian wake model to  calculate velocity reductions, turbulence intensity additions, and effective wind speeds at turbine  locations, accounting for wake interactions, rotor discretization, wind shear effects, and turbulence propagation.</p><p><strong>Arguments</strong></p><ul><li><code>buffers::FLORISBuffers</code>: Pre-allocated buffer arrays for computation and output storage (see <a href="../types/#FLORIDyn.FLORISBuffers"><code>FLORISBuffers</code></a>)</li><li><code>set::Settings</code>: Simulation settings containing configuration options for wind shear modeling</li><li><code>location_t</code>: Matrix of turbine positions [x, y, z] coordinates for each turbine [m]</li><li><code>states_wf</code>: Wind field state matrix containing velocity, direction, and turbulence data</li><li><code>states_t</code>: Turbine state matrix with axial induction factors, yaw angles, and turbulence intensities</li><li><code>d_rotor</code>: Vector of rotor diameters for each turbine [m]</li><li><code>floris</code>: FLORIS model parameters containing wake model coefficients and rotor discretization settings (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>windshear</code>: Wind shear profile data for vertical wind speed variation modeling, either a matrix or of type <a href="../types/#FLORIDyn.WindShear"><code>WindShear</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>. Results are written into fields of <code>buffers</code>:<ul><li><code>buffers.T_red_arr</code>: Velocity reduction factors for each turbine</li><li><code>buffers.T_aTI_arr</code>: Added turbulence intensity values</li><li><code>buffers.T_Ueff</code>: Effective wind speeds  </li><li><code>buffers.T_weight</code>: Wake weighting factors</li></ul></li></ul><p><strong>Implementation Structure</strong></p><p>The function is implemented as a high-level orchestrator that calls specialized sub-functions:</p><ol><li><strong><a href="#FLORIDyn.prepare_rotor_points!"><code>prepare_rotor_points!</code></a></strong>: Handles rotor discretization, scaling, rotation, and translation</li><li><strong><a href="#FLORIDyn.handle_single_turbine!"><code>handle_single_turbine!</code></a></strong>: Optimized path for single turbine simulations (wind shear only)</li><li><strong><a href="#FLORIDyn.setup_computation_buffers!"><code>setup_computation_buffers!</code></a></strong>: Initializes and configures computation buffers and views</li><li><strong><a href="#FLORIDyn.compute_wake_effects!"><code>compute_wake_effects!</code></a></strong>: Core wake computation loop for each upstream turbine</li><li><strong><a href="#FLORIDyn.compute_final_wind_shear!"><code>compute_final_wind_shear!</code></a></strong>: Final wind shear and effective wind speed calculation</li></ol><p><strong>Computational Process</strong></p><p><strong>Single Turbine Case</strong></p><p>For single turbine simulations, the function uses an optimized path that only calculates  wind shear effects without wake interactions, providing significant performance benefits.</p><p><strong>Multi-Turbine Wake Analysis</strong></p><p>For multi-turbine wind farms, the function performs:</p><p><strong>Rotor Point Preparation</strong></p><ul><li>Discretizes rotor planes using the isocell algorithm</li><li>Applies yaw rotation transformations and coordinate translations</li><li>Handles both active turbines (d_rotor &gt; 0) and placeholder turbines</li></ul><p><strong>Wake Interaction Calculations</strong></p><p>For each upstream turbine affecting downstream turbines:</p><ul><li><strong>Coordinate Transformations</strong>: Aligns coordinates with wind direction and turbine yaw</li><li><strong>Wake Variable Calculations</strong>: Computes wake expansion, deflection, and potential core dimensions</li><li><strong>Velocity Deficit Modeling</strong>: Applies Gaussian wake theory with yaw corrections</li><li><strong>Turbulence Enhancement</strong>: Calculates added turbulence using empirical correlations</li><li><strong>Superposition</strong>: Combines effects from multiple upstream turbines</li></ul><p><strong>Final Integration</strong></p><ul><li>Applies vertical wind shear corrections to the downstream turbine</li><li>Combines all wake effects with wind shear for final effective wind speed</li></ul><p><strong>Mathematical Models</strong></p><p>The function implements state-of-the-art wake modeling based on:</p><ul><li><strong>Gaussian Wake Theory</strong>: For velocity deficit calculations with yaw corrections</li><li><strong>Analytical Deflection Models</strong>: For wake steering in yawed conditions</li><li><strong>Empirical Turbulence Models</strong>: For wake-added turbulence intensity</li><li><strong>Linear Superposition</strong>: For combining multiple wake interactions</li></ul><p><strong>Performance Characteristics</strong></p><ul><li><strong>Computational Complexity</strong>: O(N²) for N turbines due to wake interactions</li><li><strong>Memory Efficiency</strong>: Uses pre-allocated buffers to avoid runtime allocations</li><li><strong>Optimization</strong>: Single turbine case bypasses multi-turbine calculations</li><li><strong>Vectorization</strong>: Leverages SIMD operations where possible</li></ul><p><strong>Notes</strong></p><ul><li>Uses SOWFA (Simulator for Offshore Wind Farm Applications) coordinate conventions</li><li>Supports both research and engineering applications for wind farm optimization</li><li>Requires proper initialization of turbine states and wind field conditions</li><li>Buffer sizes must be compatible with rotor discretization settings</li></ul><p><strong>References</strong></p><ul><li>Bastankhah, M. and Porté-Agel, F. (2016). Experimental and theoretical study of wind turbine wakes in yawed conditions</li><li>Niayifar, A. and Porté-Agel, F. (2016). Analytical modeling of wind farms: A new approach for power prediction</li></ul><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.prepare_rotor_points!"><code>prepare_rotor_points!</code></a>: Rotor point preparation and transformation</li><li><a href="#FLORIDyn.handle_single_turbine!"><code>handle_single_turbine!</code></a>: Single turbine optimization path</li><li><a href="#FLORIDyn.setup_computation_buffers!"><code>setup_computation_buffers!</code></a>: Buffer initialization and setup</li><li><a href="#FLORIDyn.compute_wake_effects!"><code>compute_wake_effects!</code></a>: Core wake interaction calculations</li><li><a href="#FLORIDyn.compute_final_wind_shear!"><code>compute_final_wind_shear!</code></a>: Final wind shear integration</li><li><a href="../types/#FLORIDyn.FLORISBuffers"><code>FLORISBuffers</code></a>: Buffer structure documentation</li><li><a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>: FLORIS model parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/runfloris.jl#L506-L599">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.prepare_rotor_points!"><a class="docstring-binding" href="#FLORIDyn.prepare_rotor_points!"><code>FLORIDyn.prepare_rotor_points!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prepare_rotor_points!(buffers::FLORISBuffers, location_t, states_t, d_rotor, floris::Floris)</code></pre><p>Prepare rotor discretization points with scaling, rotation, and translation for the last turbine.</p><p>This function handles the rotor point discretization, scales them by the rotor diameter, applies yaw rotation, and translates them to the turbine location. The results are stored in the buffers to avoid allocations.</p><p><strong>Arguments</strong></p><ul><li><code>buffers::FLORISBuffers</code>: Pre-allocated computation buffers</li><li><code>location_t</code>: Turbine locations matrix</li><li><code>states_t</code>: Turbine states matrix (includes yaw angles)</li><li><code>d_rotor</code>: Rotor diameter array</li><li><code>floris::Floris</code>: FLORIS model parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>RPl</code>: View of transformed rotor points</li><li><code>RPw</code>: Rotor point weights</li></ul><p><strong>Note</strong></p><p>This function is <strong>private</strong> and intended for internal use only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/runfloris.jl#L65-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.handle_single_turbine!"><a class="docstring-binding" href="#FLORIDyn.handle_single_turbine!"><code>FLORIDyn.handle_single_turbine!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">handle_single_turbine!(buffers::FLORISBuffers, RPl, RPw, location_t, set::Settings, windshear, d_rotor)</code></pre><p>Handle the special case when there is only one turbine in the simulation.</p><p>This function computes the wind shear reduction for a single turbine case and populates the appropriate buffer arrays. It returns early to avoid the multi-turbine wake calculations.</p><p><strong>Arguments</strong></p><ul><li><code>buffers::FLORISBuffers</code>: Pre-allocated computation buffers</li><li><code>RPl</code>: Rotor discretization points</li><li><code>RPw</code>: Rotor point weights</li><li><code>location_t</code>: Turbine locations matrix</li><li><code>set::Settings</code>: Simulation settings</li><li><code>windshear</code>: Wind shear data</li><li><code>d_rotor</code>: Rotor diameter array</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code> (results stored in buffers)</li></ul><p><strong>Note</strong></p><p>This function is <strong>private</strong> and intended for internal use only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/runfloris.jl#L140-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.setup_computation_buffers!"><a class="docstring-binding" href="#FLORIDyn.setup_computation_buffers!"><code>FLORIDyn.setup_computation_buffers!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setup_computation_buffers!(buffers::FLORISBuffers, nRP::Int, nT::Int)</code></pre><p>Initialize and setup computation buffers for multi-turbine wake calculations.</p><p>This function resizes output arrays and creates views of pre-allocated buffers to match the current rotor discretization size. It ensures all buffers are properly sized before the main computation loop.</p><p><strong>Arguments</strong></p><ul><li><code>buffers::FLORISBuffers</code>: Pre-allocated computation buffers</li><li><code>nRP::Int</code>: Number of rotor points</li><li><code>nT::Int</code>: Number of turbines</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of buffer views for use in wake calculations</li></ul><p><strong>Note</strong></p><p>This function is <strong>private</strong> and intended for internal use only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/runfloris.jl#L199-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.compute_wake_effects!"><a class="docstring-binding" href="#FLORIDyn.compute_wake_effects!"><code>FLORIDyn.compute_wake_effects!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_wake_effects!(buffers::FLORISBuffers, views, iT::Int, RPl, RPw, location_t, 
                     states_wf, states_t, d_rotor, floris::Floris, nRP::Int)</code></pre><p>Compute wake effects for a single upstream turbine on the downstream turbine.</p><p>This function calculates the velocity deficit and added turbulence caused by turbine iT on the last turbine in the array. It handles coordinate transformations, wake variable calculations, and Gaussian wake modeling.</p><p><strong>Arguments</strong></p><ul><li><code>buffers::FLORISBuffers</code>: Pre-allocated computation buffers</li><li><code>views</code>: Tuple of buffer views from setup<em>computation</em>buffers!</li><li><code>iT::Int</code>: Index of the upstream turbine</li><li><code>RPl</code>: Rotor discretization points</li><li><code>RPw</code>: Rotor point weights</li><li><code>location_t</code>: Turbine locations matrix</li><li><code>states_wf</code>: Wind farm states matrix</li><li><code>states_t</code>: Turbine states matrix</li><li><code>d_rotor</code>: Rotor diameter array</li><li><code>floris::Floris</code>: FLORIS model parameters</li><li><code>nRP::Int</code>: Number of rotor points</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>. Results are written into fields of <code>buffers</code>:<ul><li><code>buffers.T_red_arr</code>: Velocity reduction factors for each turbine</li><li><code>buffers.T_aTI_arr</code>: Added turbulence intensity values</li><li><code>buffers.T_Ueff</code>: Effective wind speeds</li><li><code>buffers.T_weight</code>: Wake weighting factors</li></ul></li></ul><p><strong>Note</strong></p><p>This function is <strong>private</strong> and intended for internal use only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/runfloris.jl#L265-L297">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.compute_final_wind_shear!"><a class="docstring-binding" href="#FLORIDyn.compute_final_wind_shear!"><code>FLORIDyn.compute_final_wind_shear!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_final_wind_shear!(buffers::FLORISBuffers, RPl, RPw, location_t, set::Settings, 
                         windshear, tmp_RPs_r, states_wf)</code></pre><p>Compute final wind shear effects and effective wind speed for the last turbine.</p><p>This function calculates the wind shear reduction for the downstream turbine and computes the final effective wind speed by combining all wake effects and wind shear.</p><p><strong>Arguments</strong></p><ul><li><code>buffers::FLORISBuffers</code>: Pre-allocated computation buffers</li><li><code>RPl</code>: Rotor discretization points</li><li><code>RPw</code>: Rotor point weights</li><li><code>location_t</code>: Turbine locations matrix</li><li><code>set::Settings</code>: Simulation settings</li><li><code>windshear</code>: Wind shear data</li><li><code>tmp_RPs_r</code>: Temporary buffer for rotor point calculations</li><li><code>states_wf</code>: Wind farm states matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>. Results are written into fields of <code>buffers</code>:<ul><li><code>buffers.T_red_arr</code>: Velocity reduction factors for each turbine</li><li><code>buffers.T_aTI_arr</code>: Added turbulence intensity values</li><li><code>buffers.T_Ueff</code>: Effective wind speeds</li><li><code>buffers.T_weight</code>: Wake weighting factors</li></ul></li></ul><p><strong>Note</strong></p><p>This function is <strong>private</strong> and intended for internal use only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floris/runfloris.jl#L451-L479">source</a></section></details></article><h1 id="FLORIDyn"><a class="docs-heading-anchor" href="#FLORIDyn">FLORIDyn</a><a id="FLORIDyn-1"></a><a class="docs-heading-anchor-permalink" href="#FLORIDyn" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.initSimulation"><a class="docstring-binding" href="#FLORIDyn.initSimulation"><code>FLORIDyn.initSimulation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initSimulation(wf::Union{Nothing, WindFarm}, sim::Sim) -&gt; Union{Nothing, WindFarm}</code></pre><p>Initialize or load a wind farm simulation state based on simulation settings.</p><p>This function handles the initialization phase of a wind farm simulation by either saving  the current initialized state to disk or loading a previously saved state, depending on  the simulation configuration.</p><p><strong>Arguments</strong></p><ul><li><code>wf::Union{Nothing, WindFarm}</code>: Wind farm object containing the initialized simulation state, or <code>Nothing</code> if no state is available. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>sim::Sim</code>: Simulation configuration object containing initialization settings and file paths. See <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>wf::Union{Nothing, WindFarm}</code>: The wind farm state, either the original input state (for &quot;init&quot; mode) or a loaded state from disk (for &quot;load&quot; mode)</li></ul><p><strong>Behavior</strong></p><p>The function operates in two modes based on <code>sim.init</code>:</p><p><strong>&quot;init&quot; Mode</strong></p><ul><li>Uses the provided wind farm state as-is</li><li>If <code>sim.save_init_state</code> is <code>true</code>, saves the current state to <code>&quot;T_init.jld2&quot;</code> in the specified data directory</li><li>Logs the save operation for user feedback</li></ul><p><strong>&quot;load&quot; Mode</strong></p><ul><li>Attempts to load a previously saved wind farm state from <code>&quot;T_init.jld2&quot;</code></li><li>Falls back to the provided state if loading fails (with warning)</li><li>Handles file I/O errors gracefully</li></ul><p><strong>File Operations</strong></p><ul><li><strong>Save path</strong>: <code>$(sim.path_to_data)/T_init.jld2</code></li><li><strong>Format</strong>: JLD2 binary format for efficient Julia object serialization</li><li><strong>Error handling</strong>: Loading failures produce warnings but do not halt execution</li></ul><p><strong>Notes</strong></p><ul><li>The function is case-insensitive for the initialization mode string</li><li>File operations use the path specified in <code>sim.path_to_data</code></li><li>Loading errors are caught and logged as warnings, allowing simulation to proceed with the original state</li><li>This mechanism enables reproducible simulations by preserving and reusing initial conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/floridyn_cl.jl#L86-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.findTurbineGroups"><a class="docstring-binding" href="#FLORIDyn.findTurbineGroups"><code>FLORIDyn.findTurbineGroups</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">findTurbineGroups(wf::WindFarm, floridyn::FloriDyn) -&gt; Vector{Vector{Int64}}</code></pre><p>Determine wake interaction dependencies between turbines in a wind farm.</p><p>This function analyzes the spatial relationships between turbines to identify which turbines  are affected by the wakes of upstream turbines. It uses coordinate transformations to the  wind-aligned reference frame and geometric criteria to determine wake interactions.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, observation points, and wind field states. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters containing wake interaction thresholds. See <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>vv_dep::Vector{Vector{Int64}}</code>: A vector of vectors where <code>vv_dep[i]</code> contains the indices of all turbines  that affect turbine <code>i</code> through wake interactions. Each inner vector lists the upstream turbine indices  that influence the wake conditions at the corresponding turbine.</li></ul><p><strong>Algorithm</strong></p><ol><li><strong>Coordinate Transformation</strong>: For each turbine pair, transforms coordinates to a wind-aligned frame using the closest observation point</li><li><strong>Wake Zone Detection</strong>: Applies geometric criteria to determine if a downstream turbine lies within the wake zone:<ul><li>Upstream extent: <code>r₁[1] ≥ -uw × D[iT]</code> (allowing for slight upstream influence)</li><li>Downstream extent: <code>r₁[1] ≤ dw × D[iT]</code> (wake extends downstream)  </li><li>Lateral extent: <code>|r₁[2]| ≤ cw × D[iT]</code> (wake width constraint)</li></ul></li><li><strong>Dependency Matrix</strong>: Constructs a boolean dependency matrix and extracts indices for each turbine</li></ol><p><strong>Mathematical Description</strong></p><p>The wake interaction criteria are evaluated in the wind-aligned coordinate system:</p><pre><code class="language-julia hljs">r₁ = R(φ) × (rₒₚ - rₜᵤᵣᵦ)</code></pre><p>where:</p><ul><li><code>R(φ)</code> is the rotation matrix for wind direction angle <code>φ</code></li><li><code>rₒₚ</code> is the position of the closest observation point from the upstream turbine</li><li><code>rₜᵤᵣᵦ</code> is the position of the downstream turbine being evaluated</li></ul><p><strong>Notes</strong></p><ul><li>The function uses the closest observation point from each upstream turbine to determine wind direction</li><li>Wake zones are defined as multiples of rotor diameter using the FLORIDyn parameters</li><li>Self-interaction (turbine affecting itself) is explicitly excluded</li><li>The coordinate transformation accounts for the SOWFA wind direction convention</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/floridyn_cl.jl#L223-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.prepareSimulation"><a class="docstring-binding" href="#FLORIDyn.prepareSimulation"><code>FLORIDyn.prepareSimulation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prepareSimulation(set::Settings, wind::Wind, con::Con, floridyn::FloriDyn, 
                  floris::Floris, turbProp, sim::Sim) -&gt; (WindFarm, Wind, Sim, Con, Floris)</code></pre><p>Prepares the simulation environment for a wind farm analysis using the provided settings and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options.</li><li><code>wind::Wind</code>: Wind conditions or wind field data. See: <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a> </li><li><code>con::Con</code>: Controller parameters of the turbines.  See: <a href="../settings/#FLORIDyn.Con"><code>Con</code></a></li><li><code>floridyn::FloriDyn</code>: Parameters specific to the FLORIDyn model. See: <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li><li><code>floris::Floris</code>: Parameters specific to the FLORIS model. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>turbProp</code>: Properties of the turbines involved in the simulation.</li><li><code>sim::Sim</code>: Simulation-specific parameters or state. See: <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li></ul><p><strong>Arguments that get modified</strong></p><ul><li><code>wind</code>: Updated with wind velocity, direction, turbulence intensity, and shear profile.</li><li><code>con</code>: Updated with yaw data.</li><li><code>sim</code>: Updated with the number of simulation steps.</li><li><code>floris</code>: May include additional parameters for the FLORIS model.</li></ul><p><strong>Returns</strong></p><ul><li>Returns the tuple <code>(wf, wind, sim, con, floris)</code> where:<ul><li><code>wf</code>: Wind farm struct containing turbine states and positions. See: <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>wind</code>: Updated wind conditions.</li><li><code>sim</code>: Updated simulation parameters.</li><li><code>con</code>: Updated controller parameters.</li><li><code>floris</code>: Parameters for the FLORIS model.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/prepare_simulation.jl#L118-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.perturbationOfTheWF!"><a class="docstring-binding" href="#FLORIDyn.perturbationOfTheWF!"><code>FLORIDyn.perturbationOfTheWF!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">perturbationOfTheWF!(wf::WindFarm, wind::Wind) -&gt; Nothing</code></pre><p>Apply stochastic perturbations to the wind field states in-place.</p><p>This function adds Gaussian noise to the wind field parameters to model measurement  uncertainty or natural variability in wind conditions. The perturbations are applied  conditionally based on the wind perturbation configuration and are added directly  to the wind farm state matrix.</p><p><strong>Input/ Output Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm struct containing the state matrix <code>States_WF</code> to be perturbed</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>wind::Wind</code>: Wind configuration struct containing perturbation settings. See <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: The function modifies the wind farm state in-place</li></ul><p><strong>Behavior</strong></p><p>The function applies independent Gaussian perturbations to three wind field parameters:</p><p><strong>Velocity Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.vel == true</code></li><li><strong>Target</strong>: Column 1 of <code>wf.States_WF</code> (wind velocity [m/s])</li><li><strong>Noise</strong>: <code>wind.perturbation.vel_sigma * randn(nOP × nT)</code></li></ul><p><strong>Direction Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.dir == true</code></li><li><strong>Target</strong>: Column 2 of <code>wf.States_WF</code> (wind direction [degrees])</li><li><strong>Noise</strong>: <code>wind.perturbation.dir_sigma * randn(nOP × nT)</code></li></ul><p><strong>Turbulence Intensity Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.ti == true</code>  </li><li><strong>Target</strong>: Column 3 of <code>wf.States_WF</code> (turbulence intensity [-])</li><li><strong>Noise</strong>: <code>wind.perturbation.ti_sigma * randn(nOP × nT)</code></li></ul><p><strong>Mathematical Description</strong></p><p>For each enabled perturbation type, the function applies:</p><pre><code class="language-julia hljs">States_WF[:, col] += σ × N(0,1)</code></pre><p>where:</p><ul><li><code>σ</code> is the standard deviation for the specific parameter</li><li><code>N(0,1)</code> is standard normal random noise with dimensions <code>(nOP × nT)</code></li><li><code>nOP</code> is the number of observation points per turbine</li><li><code>nT</code> is the total number of turbines</li></ul><p><strong>Notes</strong></p><ul><li>The function uses in-place modification (indicated by the <code>!</code> suffix)</li><li>Perturbations are applied independently to each observation point and turbine</li><li>The random noise follows a standard normal distribution scaled by the respective sigma values</li><li>Only enabled perturbation types (based on boolean flags) are applied</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/floridyn_cl.jl#L148-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.setUpTmpWFAndRun!"><a class="docstring-binding" href="#FLORIDyn.setUpTmpWFAndRun!"><code>FLORIDyn.setUpTmpWFAndRun!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setUpTmpWFAndRun!(ub::UnifiedBuffers, wf::WindFarm, set::Settings, floris::Floris, 
                  wind::Wind) -&gt; Nothing</code></pre><p>Non-allocating version that uses a unified buffer struct for wind farm calculations.</p><p>This function performs wind farm wake calculations while avoiding memory allocations by reusing pre-allocated buffer arrays from a <a href="../types/#FLORIDyn.UnifiedBuffers"><code>UnifiedBuffers</code></a> struct. This is particularly  important for parallel execution and performance-critical loops where garbage collection overhead  needs to be minimized.</p><p><strong>Buffer Arguments</strong></p><ul><li><code>ub::UnifiedBuffers</code>: Unified buffer struct containing all pre-allocated arrays<ul><li><code>ub.M_buffer</code>: Pre-allocated buffer for results matrix (size: nT × 3)</li><li><code>ub.iTWFState_buffer</code>: Buffer for turbine wind field state</li><li><code>ub.tmp_Tpos_buffer</code>: Buffer for temporary turbine positions</li><li><code>ub.tmp_WF_buffer</code>: Buffer for temporary wind field states</li><li><code>ub.tmp_Tst_buffer</code>: Buffer for temporary turbine states</li><li><code>ub.dists_buffer</code>: Buffer for distance calculations</li><li><code>ub.plot_WF_buffer</code>: Buffer for plotting wind field data</li><li><code>ub.plot_OP_buffer</code>: Buffer for plotting operating point data</li></ul></li></ul><p><strong>Output Arguments</strong></p><ul><li><code>ub.M_buffer</code>: Pre-allocated buffer for results matrix (size: nT × 3)</li><li><code>wf.Weight</code>: Sets wake weight factors for each turbine from FLORIS calculations</li><li><code>wf.red_arr</code>: Updates wake reduction factors between turbines (wake interference matrix)</li></ul><p><strong>Input/ Output Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine data</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>set::Settings</code>: Settings object containing simulation parameters</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations</li><li><code>wind::Wind</code>: Wind field configuration</li></ul><p><strong>Returns</strong></p><ul><li>nothing: The function modifies <code>ub.M_buffer</code>, <code>wf.Weight</code>, and <code>wf.red_arr</code> in-place,  storing the results of the wind farm calculations</li></ul><p><strong>Performance Notes</strong></p><ul><li>Uses in-place operations to minimize memory allocations</li><li>Buffers must be pre-sized correctly for the specific wind farm configuration</li><li>Thread-safe when each thread uses its own set of buffers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/floridyn_cl.jl#L453-L496">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.interpolateOPs!"><a class="docstring-binding" href="#FLORIDyn.interpolateOPs!"><code>FLORIDyn.interpolateOPs!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interpolateOPs!(unified_buffers::UnifiedBuffers, intOPs::Vector{Matrix{Float64}}, 
                wf::WindFarm) -&gt; Nothing</code></pre><p>Compute interpolation weights and indices for observation points affecting each turbine using a unified buffer.</p><p>This function performs interpolation calculations while avoiding  memory allocations by reusing pre-allocated buffer arrays from a unified buffer struct.  This is critical for performance when called repeatedly in loops, such as in flow field calculations.</p><p><strong>Buffer Arguments</strong></p><ul><li><code>unified_buffers::UnifiedBuffers</code>: Unified buffer struct containing pre-allocated arrays including:<ul><li><code>dist_buffer</code>: Buffer for distance calculations (length ≥ wf.nOP)</li><li><code>sorted_indices_buffer</code>: Buffer for sorting indices (length ≥ wf.nOP)</li></ul></li></ul><p><strong>Output Arguments</strong></p><ul><li><code>intOPs::Vector{Matrix{Float64}}</code>: Pre-allocated vector of matrices to store interpolation results</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions and observation point data</li></ul><p><strong>Returns</strong></p><ul><li>nothing: The function modifies <code>intOPs</code> in-place, storing the interpolation results for each turbine</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create unified buffers
unified_buffers = create_unified_buffers(wf)

# Pre-allocate interpolation matrices
intOPs = [zeros(length(wf.dep[iT]), 4) for iT in 1:wf.nT]

# Non-allocating interpolation
interpolateOPs!(unified_buffers, intOPs, wf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/floridyn_cl.jl#L344-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.iterateOPs!"><a class="docstring-binding" href="#FLORIDyn.iterateOPs!"><code>FLORIDyn.iterateOPs!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">iterateOPs!(iterate_mode::IterateOPs_model, wf::WindFarm, sim::Sim, floris::Floris, 
            floridyn::FloriDyn, buffers::IterateOPsBuffers) -&gt; Nothing</code></pre><p>Advance observation points through the wind field using the specified iteration strategy.</p><p>This function family implements different algorithms for moving observation points (OPs)  through space and time, which is essential for accurate wake propagation modeling in  wind farm simulations. The choice of iteration method affects computational efficiency,  numerical stability, and physical accuracy.</p><p><strong>Summary</strong></p><p>The function modifies the following WindFarm fields:</p><ul><li><code>wf.States_OP</code>: Updates observation point positions and states through temporal advancement</li><li><code>wf.States_T</code>: Updates turbine states through circular shifting and temporal evolution  </li><li><code>wf.States_WF</code>: Updates wind field states through circular shifting and temporal evolution</li></ul><p><strong>Input/ Output Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine and observation point data</li></ul><p><strong>Input Arguments</strong></p><ul><li><code>iterate_mode::IterateOPs_model</code>: Iteration strategy (e.g., <a href="../types/#FLORIDyn.IterateOPs_basic"><code>IterateOPs_basic</code></a>, <a href="../types/#FLORIDyn.IterateOPs_average"><code>IterateOPs_average</code></a>)</li><li><code>sim::Sim</code>: Simulation configuration with time-stepping parameters</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations</li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters for wake dynamics</li><li><code>buffers::IterateOPsBuffers</code>: Pre-allocated buffers for allocation-free execution</li></ul><p><strong>Algorithm Overview</strong></p><ol><li><strong>State Preservation</strong>: Save initial turbine observation point states</li><li><strong>Downwind Advection</strong>: Move OPs downstream based on local wind velocity</li><li><strong>Crosswind Deflection</strong>: Apply wake-induced lateral deflection using centerline calculations</li><li><strong>Coordinate Transformation</strong>: Convert to world coordinates using wind direction</li><li><strong>Temporal Advancement</strong>: Perform circular shifting to advance time steps</li><li><strong>Spatial Reordering</strong>: Maintain downstream position ordering of observation points</li></ol><p><strong>Available Methods</strong></p><ul><li><code>iterateOPs!(::IterateOPs_basic, ...)</code>: Basic time-stepping with simple advection</li></ul><p><strong>Notes</strong></p><ul><li>Different iteration strategies provide trade-offs between accuracy and computational cost</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/iterate.jl#L90-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.angSOWFA2world"><a class="docstring-binding" href="#FLORIDyn.angSOWFA2world"><code>FLORIDyn.angSOWFA2world</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">angSOWFA2world(deg_SOWFA) -&gt; Float64</code></pre><p>Convert wind direction angle from SOWFA convention to world coordinate system.</p><p>This function performs coordinate transformation between different wind direction conventions used in wind farm simulations. SOWFA (Simulator fOr Wind Farm Applications) uses a different angular reference system than the standard world coordinate system used in calculations.</p><p><strong>Arguments</strong></p><ul><li><code>deg_SOWFA::Real</code>: Wind direction angle in SOWFA convention [degrees]</li></ul><p><strong>Returns</strong></p><ul><li><code>rad_World</code>: Wind direction angle in world coordinate system [radians]</li></ul><p><strong>Coordinate System Conversion</strong></p><p>The transformation follows the relationship:</p><pre><code class="language-julia hljs">θ_world = 270° - θ_SOWFA</code></pre><p><strong>SOWFA Convention</strong></p><ul><li>Wind direction angles are defined clockwise from a reference direction</li></ul><p><strong>World Convention</strong></p><ul><li>Wind direction angles are defined counterclockwise for mathematical calculations</li><li>Standard convention used in wake models and analytical computations</li></ul><p><strong>Mathematical Description</strong></p><p>The conversion process:</p><ol><li><strong>Angular transformation</strong>: <code>deg_World = 270 - deg_SOWFA</code></li><li><strong>Unit conversion</strong>: <code>rad_World = deg2rad(deg_World)</code></li></ol><p>The 270° offset accounts for the difference between clockwise (SOWFA) and  counterclockwise (world) angular conventions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Convert 90° SOWFA direction to world coordinates
world_angle = angSOWFA2world(90.0)  # Returns 3.141592... (180° in radians)

# Convert 0° SOWFA direction  
world_angle = angSOWFA2world(0.0)   # Returns 4.712388... (270° in radians)</code></pre><p><strong>Notes</strong></p><ul><li>The function handles the sign convention difference between coordinate systems</li><li>Output is always in radians for use in trigonometric calculations</li><li>This transformation is essential for proper wake modeling in wind farm simulations</li><li>The 270° offset ensures proper alignment between SOWFA and mathematical conventions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/floridyn_cl.jl#L29-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.runFLORIDyn"><a class="docstring-binding" href="#FLORIDyn.runFLORIDyn"><code>FLORIDyn.runFLORIDyn</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">runFLORIDyn(plt, set::Settings, wf::WindFarm, wind::Wind, sim, con, vis, floridyn, floris;
            rmt_plot_fn=nothing, msr=VelReduction) -&gt; (WindFarm, DataFrame, Matrix)</code></pre><p>Main entry point for the FLORIDyn closed-loop simulation.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plot object for live visualization during simulation</li><li><code>set::Settings</code>: Simulation settings and configuration parameters.</li><li><code>wf::WindFarm</code>: See: <a href="../types/#FLORIDyn.WindFarm">WindFarm</a> simulation state, including turbine and wind farm states.</li><li><code>wind::Wind</code>: See: <a href="../settings/#FLORIDyn.Wind">Wind</a> field settings.</li><li><code>sim::Sim</code>: Simulation state or configuration object. See: <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li><li><code>con::Con</code>: Controller object or control parameters. See: <a href="../settings/#FLORIDyn.Con"><code>Con</code></a></li><li><code>vis::Vis</code>: Visualization settings controlling online plotting and animation. See: <a href="../settings/#FLORIDyn.Vis"><code>Vis</code></a></li><li><code>floridyn::FloriDyn</code>: Parameters specific to the FLORIDyn model. See: <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li><li><code>floris::Floris</code>: Parameters specific to the FLORIS model. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rmt_plot_fn</code>: Optional remote plotting function for intermediate simulation results. When provided, this function  is called remotely (using <code>@spawnat 2</code>) to plot flow field visualization on a separate worker process. The function should accept parameters <code>(wf, X, Y, Z, vis, t_rel; msr=VelReduction)</code> where <code>wf</code> is the wind farm state, <code>X</code>, <code>Y</code>, <code>Z</code> are flow field coordinates and velocities, <code>vis</code> contains visualization settings, and <code>t_rel</code>  is the relative simulation time. Defaults to <code>nothing</code> for local plotting.</li><li><code>msr</code>: Measurement type for velocity reduction calculations. Defaults to <code>VelReduction</code>.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(wf, md, mi)</code> containing:</p><ul><li><code>wf::WindFarm</code>: Updated simulation state with final turbine positions, wind field states, and observation point data</li><li><code>md::DataFrame</code>: Measurement data with columns:<ul><li><code>:Time</code>: Simulation time steps</li><li><code>:ForeignReduction</code>: Wind speed reduction factors (%) due to wake effects from other turbines</li><li><code>:AddedTurbulence</code>: Additional turbulence intensity (%) induced by upstream turbines</li><li><code>:EffWindSpeed</code>: Effective wind speed (m/s) at each turbine after wake effects</li><li><code>:FreeWindSpeed</code>: Free-stream wind speed (m/s) without wake interference</li><li><code>:PowerGen</code>: Generated electrical power (MW) for each turbine</li></ul></li><li><code>mi::Matrix</code>: Interaction matrix combining time data with turbine-to-turbine wake interaction coefficients                for each simulation step</li></ul><p><strong>Description</strong></p><p>Runs a closed-loop wind farm simulation using the FLORIDyn and FLORIS models,  applying control strategies and updating turbine states over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/floridyn_cl/floridyn_cl.jl#L737-L779">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.run_floridyn"><a class="docstring-binding" href="#FLORIDyn.run_floridyn"><code>FLORIDyn.run_floridyn</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">run_floridyn(plt, set, wf, wind, sim, con, vis, 
             floridyn, floris; msr=VelReduction) -&gt; (WindFarm, DataFrame, Matrix)</code></pre><p>Unified function that automatically handles both multi-threading and single-threading modes for running FLORIDyn simulations with appropriate plotting callbacks.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: PyPlot instance, usually provided by ControlPlots</li><li><code>set</code>: Settings object. See: <a href="../settings/#Settings">Settings</a></li><li><code>wf</code>: WindFarm struct. These are work arrays, not persistent objects. See: <a href="../types/#FLORIDyn.WindFarm">WindFarm</a></li><li><code>wind</code>: Wind field input settings. See: <a href="../settings/#FLORIDyn.Wind">Wind</a></li><li><code>sim</code>: Simulation settings. See: <a href="../settings/#FLORIDyn.Sim">Sim</a></li><li><code>con</code>: Controller settings. See: <a href="../settings/#FLORIDyn.Con">Con</a></li><li><code>vis</code>: Visualization settings. See: <a href="../settings/#FLORIDyn.Vis">Vis</a></li><li><code>floridyn</code>: FLORIDyn model struct. See: <a href="../settings/#FLORIDyn.FloriDyn">FloriDyn</a></li><li><code>floris</code>: Floris model struct. See: <a href="../settings/#FLORIDyn.Floris">Floris</a></li><li><code>msr</code>: Measurement index for online flow field plotting (VelReduction, AddedTurbulence or EffWind).         Default VelReduction. See: <a href="../types/#FLORIDyn.MSR">MSR</a></li></ul><p><strong>Returns</strong></p><ul><li>Tuple (wf, md, mi): WindFarm, measurement data, and interaction matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/FLORIDyn.jl#L453-L475">source</a></section></details></article><h1 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.create_thread_buffers"><a class="docstring-binding" href="#FLORIDyn.create_thread_buffers"><code>FLORIDyn.create_thread_buffers</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_thread_buffers(wf::WindFarm, nth::Int, floris::Floris) -&gt; ThreadBuffers</code></pre><p>Create thread-local buffers for parallel flow field computation with FLORIS parameters.</p><p>This function pre-allocates all necessary data structures for each thread to avoid race conditions and memory allocations during the parallel computation loop.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Original wind farm object to use as template</li><li><code>nth::Int</code>: Number of threads to create buffers for</li><li><code>floris::Floris</code>: FLORIS parameters for creating proper FLORIS buffers</li></ul><p><strong>Returns</strong></p><ul><li><code>ThreadBuffers</code>: Struct containing all thread-local buffers</li></ul><p><strong>Performance Notes</strong></p><ul><li>Each thread gets its own copy of the WindFarm structure</li><li>Pre-allocates all arrays to minimize allocations during computation</li><li>Sets up dependency structure for virtual turbines at grid points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/calc_flowfield.jl#L22-L42">source</a></section><section><div><pre><code class="language-julia hljs">create_thread_buffers(wf::WindFarm, nth::Int) -&gt; ThreadBuffers</code></pre><p>Create thread-local buffers for parallel flow field computation.</p><p>This function pre-allocates all necessary data structures for each thread to avoid race conditions and memory allocations during the parallel computation loop.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Original wind farm object to use as template</li><li><code>nth::Int</code>: Number of threads to create buffers for</li></ul><p><strong>Returns</strong></p><ul><li><code>ThreadBuffers</code>: Struct containing all thread-local buffers</li></ul><p><strong>Performance Notes</strong></p><ul><li>Each thread gets its own copy of the WindFarm structure</li><li>Pre-allocates all arrays to minimize allocations during computation</li><li>Sets up dependency structure for virtual turbines at grid points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/calc_flowfield.jl#L59-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.getMeasurements"><a class="docstring-binding" href="#FLORIDyn.getMeasurements"><code>FLORIDyn.getMeasurements</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getMeasurements(buffers::ThreadBuffers, mx::Matrix, my::Matrix, nM::Int, zh::Real,
                wf::WindFarm, set::Settings, floris::Floris, wind::Wind) -&gt; Array{Float64,3}</code></pre><p>Calculate flow field measurements at specified grid points by treating them as virtual turbines.</p><p>This function computes flow field properties (velocity reduction, added turbulence, effective wind speed) at grid points by creating virtual turbines at each location and running the FLORIS wake model. Each grid point is treated as a turbine that depends on all real turbines in the wind farm, allowing wake effects to be captured in the flow field visualization.</p><p><strong>Arguments</strong></p><ul><li><code>buffers::ThreadBuffers</code>: Pre-allocated thread-local buffers created with <a href="#FLORIDyn.create_thread_buffers"><code>create_thread_buffers</code></a>;   for Julia 1.12 use <code>create_thread_buffers(wf, nthreads() + 1, floris)</code>; for single-thread use <code>create_thread_buffers(wf, 1, floris)</code></li><li><code>mx::Matrix</code>: X-coordinates of grid points (m)</li><li><code>my::Matrix</code>: Y-coordinates of grid points (m)  </li><li><code>nM::Int</code>: Number of measurements to compute (typically 3)</li><li><code>zh::Real</code>: Hub height for measurements (m)</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine data. See: <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a><ul><li><code>wf.nT</code>: Number of real turbines</li><li><code>wf.StartI</code>: Starting indices for turbine data</li><li><code>wf.posBase</code>, <code>wf.posNac</code>: Turbine positions</li><li><code>wf.States_*</code>: Turbine state matrices</li></ul></li><li><code>set::Settings</code>: Settings object containing simulation parameters. See: <a href="../settings/#Settings"><code>Settings</code></a></li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>wind::Wind</code>: Wind field configuration. See: <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions <code>(size(mx,1), size(mx,2), nM)</code><ul><li><code>mz[:,:,1]</code>: Velocity reduction</li><li><code>mz[:,:,2]</code>: Added turbulence intensity</li><li><code>mz[:,:,3]</code>: Effective wind speed</li></ul></li></ul><p><strong>Algorithm</strong></p><p>For each grid point:</p><ol><li>Creates a temporary wind farm with all original turbines plus one virtual turbine at the grid point</li><li>Sets the virtual turbine to depend on all real turbines (to capture wake effects)</li><li>Runs the FLORIS simulation to compute wake-affected flow properties</li><li>Extracts the result for the virtual turbine position</li></ol><p><strong>Performance Notes</strong></p><ul><li>Multi-threaded implementation using <code>@threads</code> for parallel processing of grid points when more than one buffer is provided</li><li>With a single buffer (<code>length(buffers.thread_buffers) == 1</code>), runs in a single-threaded loop</li><li>Each grid point requires a full wind farm simulation, so computation time scales with grid size</li><li>Uses thread-local buffers created by <a href="#FLORIDyn.create_thread_buffers"><code>create_thread_buffers</code></a> to avoid race conditions</li><li>On Julia 1.12 create <code>nthreads() + 1</code> buffers to accommodate thread indexing</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a 10x10 grid from 0 to 1000m
x_range = 0:100:1000
y_range = 0:100:1000
mx = repeat(collect(x_range)&#39;, length(y_range), 1)
my = repeat(collect(y_range), 1, length(x_range))

# Calculate 3 measurements at 90m hub height (single-thread)
buffers = create_thread_buffers(wind_farm, 1, floris_model)
mz = getMeasurements(buffers, mx, my, 3, 90.0, wind_farm, settings, floris_model, wind_config)

# Extract effective wind speed field
wind_speed_field = mz[:, :, 3]</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.calcFlowField"><code>calcFlowField</code></a>: Higher-level function that uses this to create complete flow field data</li><li><a href="#FLORIDyn.setUpTmpWFAndRun!"><code>setUpTmpWFAndRun!</code></a>: Underlying simulation function used for each grid point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/calc_flowfield.jl#L171-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.calcFlowField"><a class="docstring-binding" href="#FLORIDyn.calcFlowField"><code>FLORIDyn.calcFlowField</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calcFlowField(set::Settings, wf::WindFarm, wind::Wind, floris::Floris; plt=nothing)</code></pre><p>Generate full flow field plot data by calculating measurements across a grid.</p><p>This function creates a rectangular grid over the wind farm domain and calculates flow field properties at each grid point by treating them as virtual turbines. The computation can be performed in parallel if <code>set.threading</code> is true.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Settings object containing simulation parameters<ul><li><code>set.threading</code>: If true, uses multi-threaded computation with <code>@threads</code></li><li><code>set.parallel</code>: If true, enables parallel-specific optimizations</li></ul></li><li><code>wf::WindFarm</code>: Wind farm object containing turbine data</li><li><code>wind::Wind</code>: Wind field configuration  </li><li><code>floris::Floris</code>: FLORIS model parameters</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>plt=nothing</code>: Plot object for garbage collection control. If provided and <code>set.parallel</code> is true, automatically calls <code>plt.GC.enable(false)</code> before multithreading and <code>plt.GC.enable(true)</code>  after completion to prevent PyCall-related segmentation faults during parallel execution with ControlPlots loaded. To take full advantage of multithreading, executed the plotting in a separate process.</li><li><code>vis=nothing</code>: Visualization configuration object containing field limits and resolution settings. If provided, uses <code>vis.field_limits_min</code>, <code>vis.field_limits_max</code>, and <code>vis.field_resolution</code>  to define the computational grid. If not provided, defaults to domain [0,0,0] to [3000,3000,400]  meters with 20m resolution.</li></ul><p><strong>Returns</strong></p><ul><li><code>Z::Array{Float64,3}</code>: 3D array of flow field measurements with dimensions <code>(ny, nx, 3)</code><ul><li><code>Z[:,:,1]</code>: Velocity reduction factor</li><li><code>Z[:,:,2]</code>: Added turbulence intensity  </li><li><code>Z[:,:,3]</code>: Effective wind speed (m/s)</li></ul></li><li><code>X::Matrix{Float64}</code>: X-coordinate grid (m)</li><li><code>Y::Matrix{Float64}</code>: Y-coordinate grid (m)</li></ul><p><strong>Notes</strong></p><ul><li>Grid resolution and domain are configurable via the <code>vis</code> parameter, or use default values for backward compatibility</li><li>Hub height is taken from the first turbine in the wind farm</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Calculate flow field with threading and GC control
set.threading = true
Z, X, Y = calcFlowField(set, wf, wind, floris; plt)

# Extract velocity reduction field
velocity_reduction = Z[:, :, 1]

# Extract effective wind speed field  
wind_speed = Z[:, :, 3]</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.getMeasurements"><code>getMeasurements</code></a>: Function used internally to compute the flow field</li><li><a href="#FLORIDyn.plotFlowField"><code>plotFlowField</code></a>: Visualization function for the generated data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/calc_flowfield.jl#L326-L381">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.calc_rel_power"><a class="docstring-binding" href="#FLORIDyn.calc_rel_power"><code>FLORIDyn.calc_rel_power</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calc_rel_power(settings_file; dt=350, wind_dir=180.0, ti=0.062)</code></pre><p>Calculate relative power output for a wind farm simulation over time.</p><p>This function runs a FLORIDyn simulation and computes the relative power output based on  the cube of relative wind speeds at each turbine. The relative power represents the  power output compared to undisturbed wind conditions.</p><p><strong>Arguments</strong></p><ul><li><code>settings_file::String</code>: Path to the YAML configuration file containing wind farm settings</li><li><code>dt::Real=350</code>: Additional simulation time in seconds beyond the base configuration</li><li><code>wind_dir::Union{Real,Nothing}=180.0</code>: Wind direction in degrees. If <code>nothing</code>, uses  variable wind direction from the settings file. If a number, uses constant wind direction.</li><li><code>ti::Union{Real,Nothing}=0.062</code>: Turbulence intensity (TI) as a decimal (e.g., 0.062 = 6.2%).  If <code>nothing</code>, uses the turbulence intensity from the settings file.</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>times::Vector{Float64}</code>: Time points of the simulation [s]</li><li><code>rel_power::Vector{Float64}</code>: Relative power output at each time point [dimensionless]</li><li><code>set::Settings</code>: Simulation settings used</li><li><code>wf::WindFarm</code>: Wind farm object with final turbine states</li><li><code>wind::Wind</code>: Wind field object</li><li><code>floris::Floris</code>: FLORIS model object</li></ul><p><strong>Physics</strong></p><p>The relative power is calculated as:</p><pre><code class="language-julia hljs">rel_power[t] = (1/nT) * Σᵢ (rel_speed[i,t])³</code></pre><p>where <code>rel_speed[i,t]</code> is the relative wind speed at turbine <code>i</code> and time <code>t</code>, and  <code>nT</code> is the number of turbines. This follows the cubic relationship between wind  speed and power: P ∝ v³.</p><p><strong>Threading</strong></p><p>The function automatically detects and uses multithreading if available  (<code>Threads.nthreads() &gt; 1</code>). When using fixed wind direction, the simulation  uses constant yaw and direction modes for improved performance.</p><p><strong>Configuration</strong></p><p>When <code>wind_dir</code> is specified (not <code>nothing</code>):</p><ul><li>Sets yaw control to &quot;Constant&quot; mode</li><li>Sets wind direction input to &quot;Constant&quot; mode  </li><li>Applies the specified wind direction to both controller and wind field</li><li>Uses <code>Direction_Constant()</code> and <code>Yaw_Constant()</code> modes for optimization</li></ul><p>When <code>ti</code> is specified (not <code>nothing</code>):</p><ul><li>Overrides the turbulence intensity in the wind field with the specified value</li><li>Allows for parametric studies of turbulence intensity effects on power output</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Variable wind direction with default turbulence intensity
times, rel_power, set, wf, wind, floris = calc_rel_power(&quot;data/2021_9T_Data.yaml&quot;; 
                                                         dt=200, wind_dir=nothing)

# Fixed wind direction with custom turbulence intensity
times, rel_power, set, wf, wind, floris = calc_rel_power(&quot;data/2021_9T_Data.yaml&quot;; 
                                                         dt=100, wind_dir=270.0, ti=0.10)

# Low turbulence case study
times, rel_power, set, wf, wind, floris = calc_rel_power(&quot;data/2021_9T_Data.yaml&quot;; 
                                                         dt=150, wind_dir=180.0, ti=0.02)

# Analyze results
mean_power = mean(rel_power)
power_std = std(rel_power)
println(&quot;Mean relative power: &quot;, round(mean_power, digits=3))
println(&quot;Power variability: &quot;, round(power_std, digits=3))</code></pre><p><strong>See also</strong></p><p><a href="#FLORIDyn.prepare_large_plot_inputs"><code>FLORIDyn.prepare_large_plot_inputs</code></a>, <a href="#FLORIDyn.run_floridyn"><code>run_floridyn</code></a>, <a href="../settings/#Settings"><code>Settings</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/calc_power.jl#L4-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.plotFlowField"><a class="docstring-binding" href="#FLORIDyn.plotFlowField"><code>FLORIDyn.plotFlowField</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plotFlowField(state::Union{Nothing, PlotState}, plt, wf, mx, my, mz, vis::Vis, t=nothing; 
              msr::MSR=EffWind, fig=nothing)</code></pre><p>Plot a 2D contour of the flow field data with support for animation.</p><p><strong>Arguments</strong></p><ul><li><code>state::Union{Nothing, PlotState}</code>: Animation state object. Pass <code>nothing</code> for the first call,  then pass the returned state for subsequent calls to maintain the same figure and layout.</li><li><code>plt</code>: Plotting package (e.g., ControlPlots.plt)</li><li><code>wf</code>: Wind farm object containing turbine data</li><li><code>mx::Matrix</code>: X-coordinate grid</li><li><code>my::Matrix</code>: Y-coordinate grid  </li><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions (rows, cols, nM)</li><li><code>vis::Vis</code>: Visualization settings including save options and color scale parameters</li><li><code>t</code>: Time value for display in the plot title or annotations</li><li><code>msr::MSR</code>: Which measurement to plot. See: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>vis.unit_test::Bool</code>: Whether to automatically close plots for testing.</li></ul><p><strong>Returns</strong></p><ul><li><code>state::PlotState</code>: Updated or newly created plot state for use in subsequent calls</li></ul><p><strong>Description</strong></p><p>This function supports creating animations by maintaining plot state across multiple calls:</p><p><strong>First Call (state = nothing)</strong></p><ul><li>Creates new figure, axes, colorbar, and all plot elements</li><li>Initializes and returns a PlotState object</li></ul><p><strong>Subsequent Calls (state = PlotState)</strong></p><ul><li>Updates existing contour data, turbine positions, and observation points</li><li>Reuses the same figure and layout for smooth animation</li></ul><p><strong>Animation Example</strong></p><pre><code class="language-julia hljs">using ControlPlots

# Initialize state (first frame)
state = nothing
vis = Vis(online=true, save=true)  # Enable saving to video folder
for t in time_steps
    Z, X, Y = calcFlowField(settings, wind_farm, wind, floris)
    state = plotFlowField(state, plt, wind_farm, X, Y, Z, vis, t; msr=EffWind)
    plt.pause(0.01)  # Small delay for animation
end</code></pre><p><strong>Notes</strong></p><ul><li>The function automatically handles coordinate system transformations for turbine orientations</li><li>Observation points are displayed as white scatter points for reference</li><li>Color scales are kept consistent across animation frames when using the same measurement type</li><li>The time parameter <code>t</code> can be used for title updates or time annotations</li><li>When <code>vis.save=true</code>, plots are saved as PNG files to the <code>video/</code> directory</li><li>Saved filenames include measurement type and time information (e.g., <code>velocity_reduction_t0120s.png</code>)</li><li>The <code>video/</code> directory is automatically created if it doesn&#39;t exist</li><li>This function requires a plotting package like ControlPlots.jl to be loaded and available as <code>plt</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/plot_flowfield.jl#L40-L96">source</a></section><section><div><pre><code class="language-julia hljs">plotFlowField(plt, wf, mx, my, mz, vis, t=nothing; msr=EffWind, fig=nothing)</code></pre><p>Compatibility method for the original plotFlowField interface.</p><p>This method provides backward compatibility by calling the new state-based version  with <code>state=nothing</code>, effectively creating a single plot without animation support.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plotting package (e.g., ControlPlots.plt)</li><li><code>wf</code>: Wind farm object containing turbine data</li><li><code>mx::Matrix</code>: X-coordinate grid</li><li><code>my::Matrix</code>: Y-coordinate grid  </li><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions (rows, cols, nM)</li><li><code>vis::Vis</code>: Visualization settings including save options and color scale parameters</li><li><code>t</code>: Time value for display in the plot title or annotations</li><li><code>msr::MSR</code>: Which measurement to plot. See: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>vis.unit_test::Bool</code>: Whether to automatically close plots for testing.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: For compatibility with the original interface</li></ul><p><strong>Note</strong></p><p>This method is provided for backward compatibility. For animation support,  use the new interface with explicit state management.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/plot_flowfield.jl#L359-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.plot_flow_field"><a class="docstring-binding" href="#FLORIDyn.plot_flow_field"><code>FLORIDyn.plot_flow_field</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_flow_field(wf, X, Y, Z, vis; msr=VelReduction, plt=nothing, 
                fig=nothing) -&gt; Nothing</code></pre><p>High-level plotting function that automatically dispatches to either parallel or  sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>wf</code>: WindFarm object</li><li><code>X</code>, <code>Y</code>, <code>Z</code>: Flow field coordinate arrays</li><li><code>vis</code>: Visualization settings</li><li><code>msr</code>: Measurement type, see: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li><li><code>fig</code>: Figure name (optional)</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/smart_plotting.jl#L4-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.plotMeasurements"><a class="docstring-binding" href="#FLORIDyn.plotMeasurements"><code>FLORIDyn.plotMeasurements</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plotMeasurements(plt, wf::WindFarm, md::DataFrame, vis::Vis; 
                 separated=false, msr=VelReduction, pltctrl=nothing) -&gt; Nothing</code></pre><p>Plot measurement data from FLORIDyn simulation results.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plotting package (e.g., PyPlot, which is exported from ControlPlots); nothing for remote plotting</li><li><code>wf::WindFarm</code>: Wind farm object with field <code>nT</code> (number of turbines). See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>md::DataFrame</code>: Measurements DataFrame containing time series data with columns:<ul><li><code>Time</code>: Simulation time [s]</li><li><code>ForeignReduction</code>: Foreign reduction [%] (for VelReduction)</li><li><code>AddedTurbulence</code>: Added turbulence [%] (for AddedTurbulence)</li><li><code>EffWindSpeed</code>: Effective wind speed [m/s] (for EffWind)</li></ul></li><li><code>vis::Vis</code>: Visualization settings including unit_test parameter. See <a href="../settings/#FLORIDyn.Vis"><code>Vis</code></a></li><li><code>separated::Bool</code>: Whether to use separated subplot layout (default: false)</li><li><code>msr::MSR</code>: Measurement type to plot, see: <a href="../types/#FLORIDyn.MSR">MSR</a>. Options: VelReduction, AddedTurbulence, EffWind</li><li><code>pltctrl</code>: ControlPlots module instance (optional, used for large turbine count plotting); nothing for remote plotting</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Description</strong></p><p>This function creates time series plots of measurement data from FLORIDyn simulations. It handles:</p><ol><li>Time normalization by subtracting the start time</li><li>Multiple measurement types (velocity reduction, added turbulence, effective wind speed)</li><li>Automatic layout selection based on turbine count</li><li>Both separated (subplot) and combined plotting modes</li></ol><p><strong>Plotting Modes</strong></p><ul><li><strong>Separated mode</strong> (<code>separated=true</code>): Creates individual subplots for each turbine<ul><li>For ≤9 turbines: Traditional subplot grid</li><li>For &gt;9 turbines: Uses helper function with grouped subplots via <a href="#FLORIDyn.plot_x"><code>plot_x</code></a></li></ul></li><li><strong>Combined mode</strong> (<code>separated=false</code>): Plots all turbines on a single figure with different colors</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ControlPlots # For single-threaded plotting

# Plot velocity reduction for all turbines in combined mode
plotMeasurements(plt, wind_farm, measurements_df, vis; msr=VelReduction)

# Plot added turbulence with separated subplots
plotMeasurements(plt, wind_farm, measurements_df, vis; separated=true, msr=AddedTurbulence)

# Plot effective wind speed with ControlPlots module for large farms
plotMeasurements(plt, wind_farm, measurements_df, vis; separated=true, msr=EffWind, pltctrl=ControlPlots)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.plotFlowField"><code>plotFlowField</code></a>: For flow field visualization</li><li><a href="#FLORIDyn.getMeasurements"><code>getMeasurements</code></a>: For generating measurement data</li><li><a href="#FLORIDyn.prepare_large_plot_inputs"><code>prepare_large_plot_inputs</code></a>: Helper for large turbine counts</li><li><a href="#FLORIDyn.plot_x"><code>plot_x</code></a>: Multi-subplot plotting function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/plot_measurements.jl#L4-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.plot_measurements"><a class="docstring-binding" href="#FLORIDyn.plot_measurements"><code>FLORIDyn.plot_measurements</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_measurements(wf, md, vis; separated=true, msr=VelReduction, plt=nothing) -&gt; Nothing</code></pre><p>High-level measurements plotting function that automatically dispatches to either  parallel or sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>wf</code>: WindFarm object</li><li><code>md</code>: Measurement data</li><li><code>vis</code>: Visualization settings</li><li><code>separated</code>: Whether to use separated subplots</li><li><code>msr</code>: Measurement type, see: <a href="../types/#FLORIDyn.MSR">MSR</a> </li><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.plotMeasurements"><code>plotMeasurements</code></a>: The underlying plotting function used in sequential mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/smart_plotting.jl#L36-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.plot_rmt"><a class="docstring-binding" href="#FLORIDyn.plot_rmt"><code>FLORIDyn.plot_rmt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_rmt(X, Ys...; xlabel=&quot;&quot;, ylabel=&quot;&quot;, ylabels=nothing, labels=nothing, 
         xlims=nothing, ylims=nothing, ann=nothing, scatter=false, title=&quot;&quot;, 
         fig=&quot;&quot;, ysize=14, pltctrl=nothing) -&gt; Nothing</code></pre><p>Smart plotting function that automatically dispatches between remote parallel plotting  and sequential plotting based on Julia&#39;s threading and multiprocessing environment.</p><p>This function provides a unified interface for creating line plots or scatter plots that adapts to the available computational resources. It supports both single and  multiple data series with comprehensive labeling and styling options.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: X-axis data vector (e.g., time points, wind directions, positions)</li><li><code>Ys...</code>: Variable number of Y-axis data vectors. Each should have the same length as <code>X</code>. Can be passed in two ways:<ul><li><strong>Splatted vectors</strong> (for multiple Y-axes): <code>plot_rmt(X, Y1, Y2, ...; ylabels=[...], ...)</code></li><li><strong>Vector of vectors</strong> (for single shared Y-axis): <code>plot_rmt(X, [Y1, Y2]; ylabel=&quot;...&quot;, ...)</code></li></ul></li><li><code>xlabel::String=&quot;&quot;</code>: Label for the X-axis</li><li><code>ylabel::String=&quot;&quot;</code>: Label for the Y-axis (only valid for single Y-axis shared by all series)</li><li><code>ylabels::Union{Nothing,Vector{String}}=nothing</code>: Y-axis labels for multiple Y-axes (one per series)</li><li><code>labels::Union{Nothing,Vector{String}}=nothing</code>: Legend labels for each data series</li><li><code>xlims::Union{Nothing,Tuple{Real,Real}}=nothing</code>: X-axis limits as <code>(xmin, xmax)</code></li><li><code>ylims::Union{Nothing,Tuple{Real,Real}}=nothing</code>: Y-axis limits as <code>(ymin, ymax)</code></li><li><code>ann::Union{Nothing,Vector}=nothing</code>: Annotations to add to the plot</li><li><code>scatter::Bool=false</code>: Create scatter plot if <code>true</code>, line plot if <code>false</code></li><li><code>title::String=&quot;&quot;</code>: Plot title displayed at the top</li><li><code>fig::String=&quot;&quot;</code>: Figure window title/identifier for window management</li><li><code>ysize::Int=14</code>: Font size for y-axis labels in points</li><li><code>pltctrl::Union{Nothing,Module}=nothing</code>: ControlPlots module instance for sequential plotting</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: Function executes for side effects (displays plot)</li></ul><p><strong>Execution Modes</strong></p><p><strong>Parallel Mode (Remote Plotting)</strong></p><p><strong>Conditions</strong>: <code>Threads.nthreads() &gt; 1</code> AND <code>nprocs() &gt; 1</code> AND <code>pltctrl === nothing</code></p><ul><li>Executes plotting on remote worker process 2 using <code>@spawnat 2 Main.rmt_plot(...)</code></li><li>Reduces main process computational load for large datasets</li></ul><p><strong>Sequential Mode (Local Plotting)</strong></p><p><strong>Conditions</strong>: Single-threaded OR single-process OR <code>pltctrl</code> provided</p><ul><li>Uses provided <code>pltctrl</code> (ControlPlots module) for local execution</li><li>Required for unit testing and environments without multiprocessing</li><li>Calls <code>pltctrl.plot(...)</code> with appropriate parameter combinations</li></ul><p><strong>Parameter Validation</strong></p><ul><li><strong>Length consistency</strong>: All <code>Ys</code> vectors must match <code>X</code> length</li><li><strong>Label compatibility</strong>: <ul><li><code>ylabel</code> (single Y-axis) is used when passing a vector of vectors: <code>plot_rmt(X, [Y1, Y2]; ylabel=&quot;...&quot;)</code></li><li><code>ylabels</code> (multiple Y-axes) is used when splatting vectors: <code>plot_rmt(X, Y1, Y2; ylabels=[&quot;...&quot;, &quot;...&quot;])</code></li><li>Cannot use <code>ylabel</code> with multiple splatted series</li></ul></li><li><strong>Required arguments</strong>: <code>pltctrl</code> is mandatory for sequential mode</li></ul><p><strong>Multiple Y Series: Two Approaches</strong></p><p><strong>Approach 1: Vector of Vectors (Single Shared Y-axis)</strong></p><p>Use when all series share the same Y-axis label and scale:</p><pre><code class="language-julia hljs">time = 1:10
series1 = rand(10)
series2 = rand(10)

# Pass as a vector of vectors - all series share one Y-axis
plot_rmt(time, [series1, series2]; 
         xlabel=&quot;Time&quot;, 
         ylabel=&quot;Values&quot;,  # Single ylabel for shared axis
         labels=[&quot;Series 1&quot;, &quot;Series 2&quot;], 
         pltctrl=ControlPlots)</code></pre><p><strong>Approach 2: Splatted Vectors (Two Y-axes)</strong></p><p>Use when each series needs its own Y-axis label:</p><pre><code class="language-julia hljs">wind_dirs = [180, 200, 220, 240, 260, 280]
power = [0.85, 0.92, 0.88, 0.76, 0.65, 0.58]
thrust = [120, 135, 142, 138, 125, 110]

# Pass as separate arguments with splatting - each gets its own Y-axis
plot_rmt(wind_dirs, power, thrust;
         xlabel=&quot;Wind Direction (°)&quot;, 
         ylabels=[&quot;Power (MW)&quot;, &quot;Thrust (kN)&quot;],  # Separate label per Y-axis
         labels=[&quot;Power&quot;, &quot;Thrust&quot;], 
         pltctrl=ControlPlots)</code></pre><p><strong>Examples</strong></p><p><strong>Single Data Series</strong></p><pre><code class="language-julia hljs">using ControlPlots
time = 0:0.1:10
power = sin.(time) .+ 1
plot_rmt(time, power; 
         xlabel=&quot;Time (s)&quot;, ylabel=&quot;Power (MW)&quot;, 
         title=&quot;Turbine Power Output&quot;, pltctrl=ControlPlots)</code></pre><p><strong>Multiple Series on Shared Y-axis (Vector of Vectors)</strong></p><pre><code class="language-julia hljs">using ControlPlots
time = 1:10
series1 = rand(10)
series2 = rand(10)

plot_rmt(time, [series1, series2]; 
         xlabel=&quot;Time&quot;, 
         ylabel=&quot;Values&quot;,
         labels=[&quot;Series 1&quot;, &quot;Series 2&quot;], 
         title=&quot;Two Time Series&quot;,
         pltctrl=ControlPlots)</code></pre><p><strong>Multiple Series with Separate Y-axes (Splatted)</strong></p><pre><code class="language-julia hljs">using ControlPlots
wind_dirs = [180, 200, 220, 240, 260, 280]
power_t1 = [0.85, 0.92, 0.88, 0.76, 0.65, 0.58]
power_t2 = [0.80, 0.89, 0.85, 0.72, 0.61, 0.55]

plot_rmt(wind_dirs, power_t1, power_t2;
         xlabel=&quot;Wind Direction (°)&quot;, 
         ylabels=[&quot;Power T1 (MW)&quot;, &quot;Power T2 (MW)&quot;],
         labels=[&quot;Turbine 1&quot;, &quot;Turbine 2&quot;], 
         title=&quot;Power vs Wind Direction&quot;,
         xlims=(175, 285), pltctrl=ControlPlots)</code></pre><p><strong>Scatter Plot with Annotations</strong></p><pre><code class="language-julia hljs">x_pos = [0, 500, 1000, 1500]
y_pos = [0, 200, -100, 300]
plot_rmt(x_pos, y_pos; 
         xlabel=&quot;X Position (m)&quot;, ylabel=&quot;Y Position (m)&quot;,
         scatter=true, title=&quot;Turbine Layout&quot;,
         ann=[&quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;, &quot;T4&quot;], pltctrl=ControlPlots)</code></pre><p><strong>Automatic Parallel Execution</strong></p><pre><code class="language-julia hljs"># When Julia started with: julia -p 2 -t 4
# Automatically uses remote plotting (no pltctrl needed)
plot_rmt(wind_speeds, power_curve; 
         xlabel=&quot;Wind Speed (m/s)&quot;, ylabel=&quot;Power (MW)&quot;,
         title=&quot;Power Curve&quot;)</code></pre><p><strong>Error Handling</strong></p><ul><li><code>ArgumentError</code>: Length mismatch between <code>X</code> and any <code>Ys</code> vector</li><li><code>ArgumentError</code>: Using <code>ylabel</code> with multiple splatted series (use <code>ylabels</code> instead)</li><li><code>ErrorException</code>: Missing <code>pltctrl</code> in sequential mode</li></ul><p><strong>Implementation Details</strong></p><p>The function uses conditional dispatch based on Julia&#39;s threading and multiprocessing state:</p><ol><li>Checks <code>Threads.nthreads() &gt; 1 &amp;&amp; nprocs() &gt; 1 &amp;&amp; pltctrl === nothing</code></li><li><strong>If true</strong>: Parallel execution via <code>@spawnat 2 Main.rmt_plot(...)</code></li><li><strong>If false</strong>: Sequential execution via <code>pltctrl.plot(...)</code> with parameter branching</li></ol><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.plot_x"><code>plot_x</code></a>: Time series plotting with automatic subplot generation</li><li><a href="#FLORIDyn.plot_flow_field"><code>plot_flow_field</code></a>: 2D/3D flow field visualization</li><li><a href="#FLORIDyn.plot_measurements"><code>plot_measurements</code></a>: Wind farm measurement data plotting</li><li>[<code>ControlPlots.plot</code>]: Underlying plotting function for sequential mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/smart_plotting.jl#L139-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.plot_x"><a class="docstring-binding" href="#FLORIDyn.plot_x"><code>FLORIDyn.plot_x</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot_x(times, plot_data...; ylabels=nothing, labels=nothing, fig=&quot;Wind Direction&quot;, 
       xlabel=&quot;rel_time [s]&quot;, ysize=10, bottom=0.02, legend_size=nothing, pltctrl=nothing, 
       loc=nothing) -&gt; Nothing</code></pre><p>High-level time series plotting function that automatically dispatches to either  parallel or sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>times</code>:        Time vector for x-axis</li><li><code>plot_data...</code>: Variable number of data arrays to plot</li><li><code>ylabels</code>:      Labels for y-axes (optional)</li><li><code>labels</code>:       Labels for subplots (optional)</li><li><code>fig</code>:          Figure title (default: &quot;Wind Direction&quot;)</li><li><code>xlabel</code>:       X-axis label (default: &quot;rel_time [s]&quot;)</li><li><code>ysize</code>:        Size of the Y-axis labels in points (default: 10)</li><li><code>bottom</code>:       Bottom margin (default: 0.02)</li><li><code>legend_size</code>:  Legend font size in points (optional)</li><li><code>pltctrl</code>:      ControlPlots instance (only used in sequential mode)</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>Description</strong></p><p>When running with multiple threads and processes, it uses remote plotting  capabilities via <code>rmt_plotx</code> ONLY if no local <code>pltctrl</code> is provided. If a <code>pltctrl</code> argument is supplied (e.g. during unit tests with a mock), it forces the sequential path so tests can observe side-effects without needing remote worker setup.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">plot_x(times, data1, data2; ylabels=[&quot;Turbine 1&quot;, &quot;Turbine 2&quot;], 
       labels=[&quot;Wind Speed&quot;, &quot;Power&quot;], legend_size=8, pltctrl=pltctrl)</code></pre><p><strong>See Also</strong></p><ul><li><code>plotx</code>: The underlying plotting function from ControlPlots used in sequential mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/smart_plotting.jl#L82-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.prepare_large_plot_inputs"><a class="docstring-binding" href="#FLORIDyn.prepare_large_plot_inputs"><code>FLORIDyn.prepare_large_plot_inputs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prepare_large_plot_inputs(wf, md, data_column, ylabel) -&gt; (times, plot_data, turbine_labels, subplot_labels)</code></pre><p>Prepare grouped plotting inputs for large numbers of turbines when <code>separated=true</code>.</p><p>Returns</p><ul><li><code>times::Vector{Float64}</code>: Time vector (one entry per recorded time step)</li><li><code>plot_data::Vector{Any}</code>: Each element is either a Vector (single line subplot) or Vector{Vector{Float64}} (multiple lines)</li><li><code>turbine_labels::Vector{String}</code>: Y-axis labels per subplot (same ylabel repeated)</li><li><code>subplot_labels::Vector{Vector{String}}</code>: Line labels per subplot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/plot_measurements.jl#L174-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.close_all"><a class="docstring-binding" href="#FLORIDyn.close_all"><code>FLORIDyn.close_all</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">close_all(plt)</code></pre><p>Close all matplotlib figure windows.</p><p>This function automatically dispatches to either parallel or sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li></ul><p><strong>Description</strong></p><p>When running with multiple threads and processes, it uses remote plotting  capabilities to close all figures on the remote worker. Otherwise, it directly calls <code>plt.close(&quot;all&quot;)</code> to close all figures in the current process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/smart_plotting.jl#L357-L372">source</a></section></details></article><h1 id="Video-Creation"><a class="docs-heading-anchor" href="#Video-Creation">Video Creation</a><a id="Video-Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Video-Creation" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.cleanup_video_folder"><a class="docstring-binding" href="#FLORIDyn.cleanup_video_folder"><code>FLORIDyn.cleanup_video_folder</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cleanup_video_folder() -&gt; Nothing</code></pre><p>Clean up existing PNG files in the video folder before creating new videos.</p><p><strong>Description</strong></p><p>This function removes all PNG files from the &quot;video&quot; directory to ensure a clean slate  before generating new video frames. It is typically called before running simulations  that create video output to prevent mixing old frames with new ones.</p><p><strong>Behavior</strong></p><ul><li>Checks if the &quot;video&quot; directory exists</li><li>Scans the directory for files with &quot;.png&quot; extension</li><li>Attempts to delete each PNG file found</li><li>Reports the number of files deleted</li><li>Issues warnings for any files that cannot be deleted</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Clean up before creating new video frames
cleanup_video_folder()

# Run simulation that generates PNG frames
# ...

# Create video from frames
createVideo()</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.createVideo"><code>createVideo</code></a>: Create MP4 video from PNG frames</li><li><a href="#FLORIDyn.createAllVideos"><code>createAllVideos</code></a>: Create videos for all measurement types</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/plot_flowfield.jl#L390-L425">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.createVideo"><a class="docstring-binding" href="#FLORIDyn.createVideo"><code>FLORIDyn.createVideo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">createVideo(prefix::String; video_dir=&quot;video&quot;, output_dir=&quot;video&quot;, fps=2, delete_frames=false)</code></pre><p>Convert PNG files in a directory starting with a given prefix into an MP4 video.</p><p><strong>Arguments</strong></p><ul><li><code>prefix::String</code>: The prefix string that PNG files must start with (e.g., &quot;velocity<em>reduction&quot;, &quot;wind</em>speed&quot;)</li><li><code>video_dir::String</code>: Directory containing the PNG files (default: &quot;video&quot;)</li><li><code>output_dir::String</code>: Directory where the output video will be saved (default: &quot;video&quot;)</li><li><code>fps::Int</code>: Frames per second for the output video (default: 2)</li><li><code>delete_frames::Bool</code>: Whether to delete the PNG files after creating the video (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the created video file, or empty string if creation failed</li></ul><p><strong>Description</strong></p><p>This function searches for PNG files in the specified directory that start with the given prefix, sorts them naturally (handling numeric sequences correctly), and combines them into an MP4 video using FFmpeg. The function requires FFmpeg to be installed on the system.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create video from velocity reduction frames
video_path = createVideo(&quot;velocity_reduction&quot;; fps=4)

# Create video from wind speed frames and delete source frames
video_path = createVideo(&quot;wind_speed&quot;; fps=6, delete_frames=true)

# Create video from custom directory
video_path = createVideo(&quot;added_turbulence&quot;; video_dir=&quot;custom_plots&quot;, output_dir=&quot;videos&quot;)</code></pre><p><strong>Requirements</strong></p><ul><li>FFmpeg must be installed and available in the system PATH</li><li>PNG files should follow a consistent naming pattern with the prefix</li><li>Recommended naming: &quot;prefix<em>t0000s.png&quot;, &quot;prefix</em>t0012s.png&quot;, etc.</li></ul><p><strong>Notes</strong></p><ul><li>Files are sorted naturally to handle numeric sequences correctly (e.g., t0001s, t0010s, t0100s)</li><li>The output video filename will be &quot;prefix_animation.mp4&quot;</li><li>If no matching files are found, the function returns an empty string</li><li>FFmpeg parameters are optimized for good quality and reasonable file size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/create_video.jl#L6-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.createAllVideos"><a class="docstring-binding" href="#FLORIDyn.createAllVideos"><code>FLORIDyn.createAllVideos</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">createAllVideos(; video_dir=&quot;video&quot;, output_dir=&quot;video&quot;, fps=2, delete_frames=false)</code></pre><p>Create videos for all common measurement types found in the video directory.</p><p><strong>Arguments</strong></p><ul><li><code>video_dir::String</code>: Directory containing the PNG files (default: &quot;video&quot;)</li><li><code>output_dir::String</code>: Directory where output videos will be saved (default: &quot;video&quot;)</li><li><code>fps::Int</code>: Frames per second for output videos (default: 2)</li><li><code>delete_frames::Bool</code>: Whether to delete PNG files after creating videos (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Paths to created video files</li></ul><p><strong>Description</strong></p><p>This convenience function automatically detects common measurement type prefixes in the video directory and creates videos for each type found. It looks for the following prefixes:</p><ul><li>&quot;velocity_reduction&quot;</li><li>&quot;added_turbulence&quot; </li><li>&quot;wind_speed&quot;</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create videos for all measurement types found
video_paths = createAllVideos(fps=4, delete_frames=true)
println(&quot;Created videos: &quot;, video_paths)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/create_video.jl#L244-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.natural_sort_key"><a class="docstring-binding" href="#FLORIDyn.natural_sort_key"><code>FLORIDyn.natural_sort_key</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">natural_sort_key(filename::String)</code></pre><p>Generate a sort key for natural sorting of filenames containing numbers.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: The filename to generate a sort key for</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Sort key that handles numeric sequences naturally</li></ul><p><strong>Description</strong></p><p>This function creates a sort key that handles numeric sequences in filenames correctly. For example, it will sort [&quot;file1.png&quot;, &quot;file10.png&quot;, &quot;file2.png&quot;] as  [&quot;file1.png&quot;, &quot;file2.png&quot;, &quot;file10.png&quot;] rather than alphabetically.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">files = [&quot;velocity_reduction_t0001s.png&quot;, &quot;velocity_reduction_t0010s.png&quot;, &quot;velocity_reduction_t0002s.png&quot;]
sorted_files = sort(files, by=natural_sort_key)
# Result: [&quot;velocity_reduction_t0001s.png&quot;, &quot;velocity_reduction_t0002s.png&quot;, &quot;velocity_reduction_t0010s.png&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/9809926496db4c814214ca0e920e388479380d6c/src/visualisation/create_video.jl#L175-L197">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Low-Level Functions</a><a class="docs-footer-nextpage" href="../settings/">Settings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 26 November 2025 16:27">Wednesday 26 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
