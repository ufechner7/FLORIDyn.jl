<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Low-Level Functions · FLORIDyn.jl</title><meta name="title" content="Low-Level Functions · FLORIDyn.jl"/><meta property="og:title" content="Low-Level Functions · FLORIDyn.jl"/><meta property="twitter:title" content="Low-Level Functions · FLORIDyn.jl"/><meta name="description" content="Documentation for FLORIDyn.jl."/><meta property="og:description" content="Documentation for FLORIDyn.jl."/><meta property="twitter:description" content="Documentation for FLORIDyn.jl."/><meta property="og:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/functions/"/><meta property="twitter:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/functions/"/><link rel="canonical" href="https://ufechner7.github.io/FLORIDyn.jl/dev/functions/"/><meta property="og:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FLORIDyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLORIDyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">Exported Types</a></li><li class="is-active"><a class="tocitem" href>Low-Level Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Calculating-the-wind-directions"><span>Calculating the wind directions</span></a></li><li class="toplevel"><a class="tocitem" href="#Calculating-the-wind-velocity"><span>Calculating the wind velocity</span></a></li><li class="toplevel"><a class="tocitem" href="#Calculating-the-wind-shear"><span>Calculating the wind shear</span></a></li><li class="toplevel"><a class="tocitem" href="#Calculating-the-wind-turbulence"><span>Calculating the wind turbulence</span></a></li><li class="toplevel"><a class="tocitem" href="#Controller-functions"><span>Controller functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Helper-functions"><span>Helper functions</span></a></li></ul></li><li><a class="tocitem" href="../functions_II/">High-Level Functions</a></li><li><a class="tocitem" href="../settings/">Settings</a></li><li><a class="tocitem" href="../video_creation/">Video Creation</a></li><li><a class="tocitem" href="../user_guide/">User Guide</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../developer/">Developer notes</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Low-Level Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Low-Level Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl/blob/main/docs/src/functions.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Low-Level-Functions"><a class="docs-heading-anchor" href="#Low-Level-Functions">Low-Level Functions</a><a id="Low-Level-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Low-Level-Functions" title="Permalink"></a></h1><h1 id="Calculating-the-wind-directions"><a class="docs-heading-anchor" href="#Calculating-the-wind-directions">Calculating the wind directions</a><a id="Calculating-the-wind-directions-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-wind-directions" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.getWindDirT"><a class="docstring-binding" href="#FLORIDyn.getWindDirT"><code>FLORIDyn.getWindDirT</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_Constant, wind::Wind, iT, _)</code></pre><p>Return wind direction in SOWFA-degrees for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind</code>: The wind direction (scalar).</li><li><code>iT</code>: Index or indices of the turbines (can be an integer or vector).</li><li><code>_</code>: Placeholder for unused argument.</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Array of wind direction values, same size as <code>iT</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L9-L21">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_Constant_wErrorCov, wind::Wind, iT, t)</code></pre><p>Return wind direction in SOWFA-deg for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind::Wind</code>: <a href="../settings/#FLORIDyn.Wind">Wind</a></li><li><code>iT</code>: Vector of turbine indices (can be any indexable collection)</li><li><code>t</code>: Time step</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Vector of wind directions for the selected turbines, including random perturbation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L31-L43">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_Interpolation, wind::Wind, iT, t)</code></pre><p><strong>Direction_Interpolation</strong></p><p>Returns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.</p><p>Arguments:</p><ul><li>wind_dir::Matrix: columns are time and phi (wind direction)</li><li>iT: single value or vector with turbine index/indices</li><li>t: time of request</li></ul><p>Returns:</p><ul><li>phi: Vector of wind directions for each turbine in iT [°]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L114-L129">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_Interpolation_wErrorCov, wind::Wind, iT, t)</code></pre><p>Returns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.</p><p>Arguments:</p><ul><li>wind::Wind: <a href="../settings/#FLORIDyn.Wind">Wind</a></li><li>iT: single value or vector with turbine index/indices</li><li>t: time of request</li></ul><p>Returns:</p><ul><li>phi: Vector of wind directions for each turbine in iT [°]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L152-L165">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_InterpTurbine, wind::Wind, iT, t)</code></pre><p>Return wind direction in SOWFA-degrees for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir::Matrix</code>: Each row is <code>[time, phi_T0, phi_T1, ...]</code>.</li><li>`iT: Index or indices of turbines.</li><li><code>t</code>: Time of request. [s]</li></ul><p><strong>Returns</strong></p><ul><li><code>phi::Vector{Float64}</code>: Wind direction(s) for the selected turbine(s) at time <code>t</code>. [°]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L209-L221">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_InterpTurbine_wErrorCov, wind::Wind, iT, t)</code></pre><p>Return wind direction in SOWFA-deg for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind::Wind</code>: See: <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li><li><code>iT</code>: Index or indices of the turbines (can be integer or vector)</li><li><code>t</code>: Time of request (Float64) [s]</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Wind direction(s) for requested turbine(s), perturbed with noise. [°]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L250-L262">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_RW_with_Mean, wind_dir_now, wind::Wind)</code></pre><p>Returns the wind direction at the respective turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir_now</code>: Current value (vector)</li><li><code>wind_dir::Wind</code>: <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Updated wind direction(s) (vector) [°]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L292-L303">source</a></section><section><div><pre><code class="language-julia hljs">getWindDirT(::Direction_RW_with_Mean, wind::Wind, iT, t)</code></pre><p>Calculate wind direction using a random walk with mean reversion model.</p><p>This model combines stochastic variability with a tendency to return to a long-term  average direction, making it suitable for modeling realistic wind direction behavior  that exhibits both short-term fluctuations and long-term meteorological patterns.</p><p><strong>Model Description</strong></p><p>The wind direction is updated according to:</p><pre><code class="language-julia hljs">φ(t+1) = φ(t) + random_perturbation + mean_pull × (φ_target - φ(t))</code></pre><p>Where:</p><ul><li><code>random_perturbation</code>: Gaussian noise with covariance structure</li><li><code>mean_pull</code>: Strength of reversion toward the target direction (0 = no reversion, 1 = strong reversion)</li><li><code>φ_target</code>: Long-term average or equilibrium wind direction</li></ul><p><strong>Arguments</strong></p><ul><li><code>::Direction_RW_with_Mean</code>: Direction mode indicator</li><li><code>wind::Wind</code>: Wind configuration containing direction data as <a href="../types/#FLORIDyn.WindDirTriple"><code>WindDirTriple</code></a><ul><li><code>wind.dir.Init</code>: Target/equilibrium wind direction(s) [°]</li><li><code>wind.dir.CholSig</code>: Cholesky factor of covariance matrix for random perturbations</li><li><code>wind.dir.MeanPull</code>: Mean reversion strength parameter (0-1)</li></ul></li><li><code>iT</code>: Turbine index or indices (Integer or AbstractArray)</li><li><code>t</code>: Time value [s]. Note: Not used in this memoryless implementation.</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Wind direction(s) for the requested turbine(s) [°]</li></ul><p><strong>Physical Interpretation</strong></p><ul><li><strong>Mean reversion</strong>: Models the tendency of wind to return to prevailing directions</li><li><strong>Stochastic component</strong>: Captures short-term meteorological variability</li><li><strong>Spatial correlation</strong>: Through the covariance matrix, accounts for spatial dependencies between turbines</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Wind tends to revert to westerly (270°) with moderate strength
wind_dir_triple = WindDirTriple(
    Init=[270.0, 270.0, 270.0],     # Target directions for 3 turbines
    MeanPull=0.1,                   # 10% reversion strength per time step
    CholSig=0.5*I(3)                # Independent 0.5° standard deviation
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L315-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.getWindDirT_EnKF"><a class="docstring-binding" href="#FLORIDyn.getWindDirT_EnKF"><code>FLORIDyn.getWindDirT_EnKF</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getWindDirT_EnKF(::Direction_EnKF_InterpTurbine, wind, iT, t)</code></pre><p><strong>Direction<em>EnKF</em>InterpTurbine</strong></p><p>Return wind direction in SOWFA-deg for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>wind_dir::Matrix</code>: Matrix where each row is [time, <code>phi_T0</code>, <code>phi_T1</code>, ... <code>phi_Tn</code>]</li><li><code>iT</code>: Index or indices of the turbines (can be integer or vector)</li><li><code>t</code>: Time of request (scalar)</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Wind direction(s) at time <code>t</code> for turbine(s) <code>iT</code> [°]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_direction.jl#L75-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.getDataDir"><a class="docstring-binding" href="#FLORIDyn.getDataDir"><code>FLORIDyn.getDataDir</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getDataDir(set::Settings, wind::Wind, wf::WindFarm, t)</code></pre><p>Retrieve wind direction data for all turbines at the current simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing the direction mode configuration</li><li><code>wind::Wind</code>: Wind field data structure containing direction information and input type</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine states and configuration</li><li><code>t</code>: Current simulation time for temporal interpolation</li></ul><p><strong>Returns</strong></p><ul><li><code>phi</code>: Wind direction values (in degrees) for all turbines at the specified time</li></ul><p><strong>Description</strong></p><p>This function reads wind direction data and returns the current wind direction angle (phi) for all  turbines in the wind farm. The function handles two different input modes:</p><ol><li><p><strong>Random Walk with Mean mode</strong> (<code>wind.input_dir == &quot;RW_with_Mean&quot;</code>): Uses the current wind farm  state from <code>wf.States_WF[wf.StartI, 2]</code> along with the wind direction data to compute direction.</p></li><li><p><strong>Standard temporal interpolation mode</strong>: Uses the wind direction data directly with temporal  interpolation for all turbines at the specified simulation time.</p></li></ol><p>The function dispatches to <code>getWindDirT</code> with appropriate parameters based on the input mode,  ensuring consistent wind direction estimation across different modeling approaches.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Get wind direction for all turbines at current simulation time
phi = getDataDir(settings, wind_data, wind_farm, 100.0)

# The returned phi contains direction values for all turbines
direction_turbine_1 = phi[1]</code></pre><p><strong>Notes</strong></p><ul><li>The function automatically handles different wind input modes through conditional logic</li><li>For random walk mode, uses existing wind farm state as reference</li><li>For standard mode, performs temporal interpolation across all turbines</li></ul><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.getWindDirT"><code>getWindDirT</code></a>: Underlying function for wind direction temporal interpolation</li><li><a href="../settings/#Settings"><code>Settings</code></a>: Configuration structure containing direction mode settings</li><li><a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>: Wind field data structure containing direction information and input type</li><li><a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>: Wind farm configuration structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/correction/direction.jl#L4-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.correctDir!"><a class="docstring-binding" href="#FLORIDyn.correctDir!"><code>FLORIDyn.correctDir!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">correctDir!(::Direction_All, set, wf, wind, t)</code></pre><p>Apply direction correction to all operational points in the wind farm using the Direction_All strategy.</p><p><strong>Arguments</strong></p><ul><li><code>::Direction_All</code>: The direction correction strategy type that applies corrections to all operational points</li><li><code>set::Settings</code>: Simulation settings containing the direction mode configuration</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine states and configuration (modified in-place)</li><li><code>wind::Wind</code>: Wind field data structure containing direction information and input type</li><li><code>t</code>: Current simulation time for temporal interpolation</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: This function modifies the wind farm state in-place and returns nothing</li></ul><p><strong>Description</strong></p><p>This function applies a direction correction using the Direction_All strategy, which updates the  wind direction for all operational points in the wind farm. The function performs the following operations:</p><ol><li><strong>Data Retrieval</strong>: Calls <code>getDataDir</code> to obtain current wind direction data for all turbines</li><li><strong>Universal State Update</strong>: Updates the wind direction for all operational points (<code>wf.States_WF[:, 2]</code>)</li><li><strong>Observation Point Orientation</strong>: If the state matrix has 4 columns, updates the observation  point orientation (<code>wf.States_WF[wf.StartI, 4]</code>) for turbine starting positions only</li></ol><p>The correction applies a uniform direction (<code>phi[1]</code>) to all operational points, representing  a scenario where the entire wind field experiences the same directional conditions.</p><p><strong>Key Behavior</strong></p><ul><li><strong>All OPs Updated</strong>: Every operational point receives the same direction value</li><li><strong>Uniform Direction</strong>: Uses <code>phi[1]</code> for all operational points regardless of turbine</li><li><strong>Selective OP Orientation</strong>: Only turbine starting positions get OP orientation updates</li><li><strong>Complete Coverage</strong>: Affects the entire wind farm state matrix at once</li></ul><p>This strategy is suitable for:</p><ul><li>Scenarios with uniform wind direction across the entire wind farm</li><li>Rapid directional changes affecting all operational points simultaneously</li><li>Simplified modeling where spatial direction variations are negligible</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Apply direction correction to all operational points
correctDir!(Direction_All(), settings, wind_farm, wind_data, 100.0)

# All operational points now have identical wind direction
@assert all(wind_farm.States_WF[:, 2] .== phi[1])

# OP orientations match wind direction for turbine starting positions only
if size(wind_farm.States_WF, 2) == 4
    for i in 1:wind_farm.nT
        start_idx = wind_farm.StartI[i, 1]
        @assert wind_farm.States_WF[start_idx, 4] == wind_farm.States_WF[start_idx, 2]
    end
end</code></pre><p><strong>Implementation Notes</strong></p><ul><li>Uses first element of direction vector (<code>phi[1]</code>) for all operational points</li><li>Broadcasts the same direction value to all rows of column 2</li><li>OP orientation (column 4) is updated only for turbine starting positions (<code>wf.StartI</code>)</li><li>More comprehensive than <code>Direction_None</code> which only affects starting positions</li><li>Compatible with different wind input modes (constant, interpolated, random walk)</li></ul><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.getDataDir"><code>getDataDir</code></a>: Function for retrieving wind direction data</li><li><a href="../types/#FLORIDyn.Direction_None"><code>Direction_None</code></a>, <a href="../types/#FLORIDyn.Direction_Influence"><code>Direction_Influence</code></a>: Alternative correction strategies</li><li><a href="../settings/#Settings"><code>Settings</code></a>: Simulation settings structure</li><li><a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>: Wind farm configuration structure</li><li><a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>: Wind field data structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/correction/direction.jl#L63-L131">source</a></section><section><div><pre><code class="language-julia hljs">correctDir!(::Direction_None, set, wf, wind, t)</code></pre><p>Apply wind direction correction only to turbine starting positions without wake-based corrections.</p><p><strong>Arguments</strong></p><ul><li><code>::Direction_None</code>: Direction correction strategy that applies minimal corrections</li><li><code>set::Settings</code>: Simulation settings containing direction mode and interpolation parameters</li><li><code>wf::WindFarm</code>: Wind farm object with turbine states and configuration (modified in-place)</li><li><code>wind::Wind</code>: Wind field data containing direction time series or model parameters</li><li><code>t</code>: Current simulation time for temporal interpolation</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: Modifies wind farm state in-place</li></ul><p><strong>Description</strong></p><p>This correction strategy applies wind direction updates only to the starting positions of each  turbine (indexed by <code>wf.StartI</code>) rather than to all operational points. This represents a  minimal correction approach that updates turbine base states without affecting downstream  operational points.</p><p>The function performs these operations:</p><ol><li><strong>Data Retrieval</strong>: Obtains current wind direction via <a href="#FLORIDyn.getDataDir"><code>getDataDir</code></a></li><li><strong>Selective Assignment</strong>: Sets only turbine starting positions (<code>wf.StartI</code>) to <code>phi[1]</code></li><li><strong>Observation Point Sync</strong>: If present, aligns OP orientation with the uniform direction value</li></ol><p>This approach differs from <a href="../types/#FLORIDyn.Direction_All"><code>Direction_All</code></a> by only updating turbine starting positions  rather than all operational points, making it suitable for:</p><ul><li>Scenarios where only turbine base states need direction updates</li><li>Reduced computational overhead compared to full state corrections</li><li>Initial turbine positioning without affecting wake propagation states</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Apply direction correction to turbine starting positions only
correctDir!(Direction_None(), settings, wind_farm, wind_data, 100.0)

# Only starting positions are updated with uniform direction
for i in 1:wind_farm.nT
    start_idx = wind_farm.StartI[i, 1]
    @assert wind_farm.States_WF[start_idx, 2] == phi[1]
end

# OP orientations match the uniform direction (if 4-column state matrix)
if size(wf.States_WF, 2) == 4
    @assert all(wf.States_WF[wf.StartI, 4] .== phi[1])
end</code></pre><p><strong>Implementation Notes</strong></p><ul><li>Uses first element of direction vector (<code>phi[1]</code>) for all turbine starting positions</li><li>Only affects turbine starting positions (<code>wf.StartI</code>), not all operational points</li><li>OP orientation is set to the raw direction value (<code>phi[1]</code>), not the turbine state</li><li>Compatible with different wind input modes (constant, interpolated, random walk)</li><li>More computationally efficient than full state corrections</li></ul><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.correctDir!"><code>correctDir!</code></a>: Generic direction correction interface</li><li><a href="#FLORIDyn.getDataDir"><code>getDataDir</code></a>: Wind direction data retrieval</li><li><a href="../types/#FLORIDyn.Direction_All"><code>Direction_All</code></a>, <a href="../types/#FLORIDyn.Direction_Influence"><code>Direction_Influence</code></a>: Alternative correction strategies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/correction/direction.jl#L144-L204">source</a></section><section><div><pre><code class="language-julia hljs">correctDir!(::Direction_Influence, set::Settings, wf, wind, t)</code></pre><p>Apply influence-based wind direction correction where each turbine&#39;s direction depends on upstream operational points through dependency relationships and interpolation weights.</p><p><strong>Arguments</strong></p><ul><li><code>::Direction_Influence</code>: Direction correction strategy that uses dependency-based influence modeling</li><li><code>set::Settings</code>: Simulation settings containing direction mode and interpolation parameters</li><li><code>wf::WindFarm</code>: Wind farm object with turbine states and dependency configuration (modified in-place)</li><li><code>wind::Wind</code>: Wind field data containing direction time series or model parameters</li><li><code>t</code>: Current simulation time for temporal interpolation</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: Modifies wind farm state in-place</li></ul><p><strong>Description</strong></p><p>This correction strategy implements sophisticated dependency-based direction modeling where each turbine&#39;s wind direction is influenced by upstream operational points. The function processes each turbine individually based on its dependency configuration:</p><p><strong>Processing Logic per Turbine</strong></p><ol><li><strong>No Dependencies</strong>: If <code>wf.dep[iT]</code> is empty, assigns the raw ambient direction <code>phi[iT]</code></li><li><strong>Single Influence Row</strong>: For <code>wf.intOPs[iT]</code> with one 4-column row <code>[idx1 w1 idx2 w2]</code>, computes direction as <code>w1 * States_WF[idx1,2] + w2 * States_WF[idx2,2]</code></li><li><strong>Multiple Influence Rows</strong>: For multiple 4-column rows with corresponding weights in  <code>wf.Weight[iT]</code>, computes weighted average of per-row interpolated directions</li><li><strong>Fallback Cases</strong>: Uses raw ambient direction <code>phi[iT]</code> for malformed data or zero weights</li></ol><p><strong>Key Features</strong></p><ul><li><strong>Index Validation</strong>: Validates all operational point indices before accessing state data</li><li><strong>Robust Handling</strong>: Gracefully handles missing or malformed dependency/weight/interpolation data</li><li><strong>Sequential Processing</strong>: Uses already-corrected turbine directions within the same iteration</li><li><strong>Orientation Sync</strong>: Updates OP orientation (column 4) to match corrected turbine direction</li></ul><p><strong>Data Structure Requirements</strong></p><ul><li><code>wf.dep[iT]</code>: Vector of turbine indices that influence turbine <code>iT</code></li><li><code>wf.intOPs[iT]</code>: Matrix where each row is <code>[idx1 w1 idx2 w2]</code> for linear interpolation</li><li><code>wf.Weight[iT]</code>: Vector of weights for combining multiple influence rows</li><li><code>wf.StartI</code>: 1×nT matrix containing starting row indices for each turbine</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Single influence case - turbine 2 influenced by OPs at indices 1 and 3
wf.dep[2] = [1, 3]
wf.intOPs[2] = [1 0.3 3 0.7]  # 30% from OP 1, 70% from OP 3
correctDir!(Direction_Influence(), settings, wf, wind, 100.0)

# Multiple influence case with weighted combination
wf.dep[3] = [1, 2, 4]
wf.intOPs[3] = [1 0.5 2 0.5; 2 0.8 4 0.2]  # Two influence combinations
wf.Weight[3] = [0.6, 0.4]  # Weights for combining the two influences
correctDir!(Direction_Influence(), settings, wf, wind, 100.0)</code></pre><p><strong>Implementation Details</strong></p><ul><li>Uses <code>StartI[1, iT]</code> indexing (1×nT matrix layout) to access turbine starting positions</li><li>Performs bounds checking on all operational point indices before state access</li><li>Skips invalid indices or zero weights to maintain numerical stability</li><li>Updates orientation column only for the specific turbine&#39;s starting position</li><li>More computationally intensive than <code>Direction_None</code> or <code>Direction_All</code> due to dependency processing</li></ul><p><strong>Error Handling</strong></p><ul><li>Invalid operational point indices are skipped with fallback to ambient direction</li><li>Missing dependency/weight/interpolation arrays are treated as empty (no influence)</li><li>Zero or negative weights are ignored in weighted averaging calculations</li><li>Malformed interpolation matrices (wrong dimensions) trigger fallback behavior</li></ul><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.getDataDir"><code>getDataDir</code></a>: Function for retrieving ambient wind direction data</li><li><a href="../types/#FLORIDyn.Direction_None"><code>Direction_None</code></a>, <a href="../types/#FLORIDyn.Direction_All"><code>Direction_All</code></a>: Simpler correction strategies</li><li><a href="../settings/#Settings"><code>Settings</code></a>: Simulation settings structure containing direction mode</li><li><a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>: Wind farm configuration structure with dependency data</li><li><a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>: Wind field data structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/correction/direction.jl#L217-L291">source</a></section></details></article><h1 id="Calculating-the-wind-velocity"><a class="docs-heading-anchor" href="#Calculating-the-wind-velocity">Calculating the wind velocity</a><a id="Calculating-the-wind-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-wind-velocity" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.getDataVel"><a class="docstring-binding" href="#FLORIDyn.getDataVel"><code>FLORIDyn.getDataVel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">    getDataVel(set::Settings, wind::Wind, wf::WindFarm, t, tmp_m, floris::Floris)</code></pre><p>Return the wind speed vector <code>u</code> for all turbines at simulation time <code>t</code> according to the configured input / model mode. Also returns (potentially updated) <code>wind</code>.</p><p>Arguments</p><ul><li><code>set::Settings</code>: simulation settings (uses <code>set.vel_mode</code>)</li><li><code>wind::Wind</code>: wind field state (<code>wind.input_vel</code> selects special branches)</li><li><code>wf::WindFarm</code>: wind farm (uses <code>wf.nT</code>, <code>wf.States_WF</code>)</li><li><code>t</code>: current simulation time</li><li><code>tmp_m</code>: temporary matrix (only used for I<em>and</em>I wake reduction)</li><li><code>floris::Floris</code>: FLORIS parameters (yaw exponent etc., only I<em>and</em>I branch)</li></ul><p>Supported (unit tested in <code>test_getDataVel_branches.jl</code>)</p><ul><li>Standard interpolation / constant variants via <code>set.vel_mode</code>:   <code>Velocity_Constant</code>, <code>Velocity_Interpolation</code>, <code>Velocity_Constant_wErrorCov</code>,   <code>Velocity_Interpolation_wErrorCov</code>, <code>Velocity_InterpTurbine</code>,   <code>Velocity_InterpTurbine_wErrorCov</code>, <code>Velocity_ZOH_wErrorCov</code>.</li><li>EnKF turbine interpolation branch: <code>wind.input_vel == &quot;EnKF_InterpTurbine&quot;</code> calling   <code>getWindSpeedT_EnKF(Velocity_EnKF_InterpTurbine(), ...)</code> with clamping of out-of-range times.</li></ul><p>Not yet fully integrated (guarded / broken tests)</p><ul><li><code>&quot;I_and_I&quot;</code>: an internal estimator state struct (<code>WSEStruct</code> in <code>windfield_velocity.jl</code>) already exists   and the low-level update routine <code>WindSpeedEstimatorIandI_FLORIDyn</code> runs, but a public, documented   construction path (export, convenience constructor, validation of required fields, tests) is missing.   The branch is therefore kept experimental and the test remains <code>@test_broken</code> until we provide a   stable API (e.g. <code>build_IandI_estimator(wf, data; kwargs...)</code>).</li><li><code>&quot;RW_with_Mean&quot;</code>: random-walk-with-mean model commented out; current call raises <code>MethodError</code>.</li></ul><p>Planned cleanups / TODO</p><ol><li>Provide concrete exported estimator type &amp; finalize <code>I_and_I</code> logic.</li><li>Re-introduce Random Walk with Mean model (<code>Velocity_RW_with_Mean</code>).</li></ol><p>Behavior summary</p><ul><li>Default: <code>u = getWindSpeedT(set.vel_mode, wind.vel, 1:nT, t)</code>.</li><li>EnKF: per-turbine linear interpolation table with time clamping.</li><li>I<em>and</em>I: (future) estimator integration plus optional wake reduction using <code>tmp_m[:,1]</code>.</li><li>RW<em>with</em>Mean: (future) stochastic update around mean with mean-pull term.</li></ul><p>All returned velocities are in m/s. Only I<em>and</em>I may mutate <code>wind.vel</code> estimator state.</p><p>Example</p><pre><code class="language-julia hljs">u, wind = getDataVel(set, wind, wf, 100.0, tmp_m, floris)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/correction/velocity.jl#L178-L224">source</a></section></details></article><h1 id="Calculating-the-wind-shear"><a class="docs-heading-anchor" href="#Calculating-the-wind-shear">Calculating the wind shear</a><a id="Calculating-the-wind-shear-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-wind-shear" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.getWindShearT"><a class="docstring-binding" href="#FLORIDyn.getWindShearT"><code>FLORIDyn.getWindShearT</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getWindShearT(::Shear_Interpolation, wind_shear::AbstractMatrix, z)</code></pre><p>Compute the wind shear at a given height <code>z</code> using the specified <code>wind_shear</code> model.</p><p><strong>Arguments</strong></p><ul><li><code>::Shear_Interpolation</code>: (Type only) Use interpolation to determine the wind shear.</li><li><code>wind_shear</code>: A matrix describing the wind shear profile.</li><li><code>z</code>: The height (in meters) at which to evaluate the wind shear.</li></ul><p><strong>Returns</strong></p><ul><li>The wind shear value at height <code>z</code>.</li></ul><p><strong>REMARKS</strong></p><p>Expects a .csv file called &quot;WindShearProfile.csv&quot; with a normalized wind speed profile for different heights:</p><pre><code class="language-julia hljs">z, (u_z/u0)
z, (u_z/u0)
z, (u_z/u0)</code></pre><p>There is a linear interpolation between every pair. In case z is out of bounds the function will use the closest available setpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_shear.jl#L6-L28">source</a></section><section><div><pre><code class="language-julia hljs">getWindShearT(::Shear_PowerLaw, wind_shear::WindShear, z_norm)</code></pre><p>Return the shear factor <code>u_eff = shear * u_referenceHeight</code> using the power law.</p><p><strong>Arguments</strong></p><ul><li><code>Shear_PowerLaw</code>: (type only, unused) Specifies that this method applies to the power law model</li><li><code>wind_shear</code>: A struct of type (<code>WindShear</code>)(@ref)<ul><li><code>z0</code>: Reference height (not used in this function)</li><li><code>alpha</code>: WindShear coefficient</li></ul></li><li><code>z_norm</code>: Height(s) (can be scalar or array)</li></ul><p><strong>Returns</strong></p><ul><li><code>shear</code>: The shear factor at the given height(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_shear.jl#L58-L72">source</a></section></details></article><h1 id="Calculating-the-wind-turbulence"><a class="docs-heading-anchor" href="#Calculating-the-wind-turbulence">Calculating the wind turbulence</a><a id="Calculating-the-wind-turbulence-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-wind-turbulence" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.getDataTI"><a class="docstring-binding" href="#FLORIDyn.getDataTI"><code>FLORIDyn.getDataTI</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getDataTI(set::Settings, wind::Wind, wf::WindFarm, t) -&gt; Vector</code></pre><p>Retrieve turbulence intensity data for all turbines at the current simulation time.</p><p>This function obtains turbulence intensity values for all turbines in the wind farm using the configured turbulence model and wind field data. It serves as a wrapper around the underlying turbulence intensity retrieval system.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Settings object containing simulation configuration<ul><li><code>set.turb_mode</code>: Turbulence model configuration specifying the retrieval method</li></ul></li><li><code>wind::Wind</code>: Wind configuration object containing turbulence intensity data<ul><li><code>wind.ti</code>: Turbulence intensity data, parameters, or model configuration</li></ul></li><li><code>wf::WindFarm</code>: Wind farm object containing turbine information<ul><li><code>wf.nT</code>: Number of turbines in the wind farm</li></ul></li><li><code>t</code>: Current simulation time for time-dependent turbulence intensity models</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Turbulence intensity values for all turbines (dimensionless, typically 0.05-0.25)</li></ul><p><strong>Behavior</strong></p><p>The function creates a vector of all turbine indices <code>[1, 2, ..., nT]</code> and retrieves the corresponding turbulence intensity values using the specified turbulence model. The actual retrieval method depends on the <code>set.turb_mode</code> configuration and can include:</p><ul><li>Constant turbulence intensity</li><li>Time-interpolated values from data files</li><li>Turbine-specific interpolation</li><li>Random walk models with covariance</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Get turbulence intensity for all turbines at t=100s
TI_values = getDataTI(settings, wind_config, wind_farm, 100.0)
println(&quot;TI for turbine 1: &quot;, TI_values[1])</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.getWindTiT"><code>getWindTiT</code></a>: Underlying function for turbulence intensity retrieval</li><li><a href="#FLORIDyn.correctTI!"><code>correctTI!</code></a>: Function that uses this data to update wind farm states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/correction/turbulence.jl#L79-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.getWindTiT"><a class="docstring-binding" href="#FLORIDyn.getWindTiT"><code>FLORIDyn.getWindTiT</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getWindTiT(::TI_Constant, wind_ti, iT, _)</code></pre><p>Return turbulence intensity for the requested turbine(s).</p><p><strong>Arguments</strong></p><ul><li><code>::TI_Constant</code>: Type parameter to indicate constant wind turbulence</li><li><code>wind_ti</code>:       Constant value (turbulence intensity)</li><li><code>iT</code>:            Index or indices of the turbines</li><li><code>_</code>:             will be ignored</li></ul><p><strong>Returns</strong></p><ul><li><code>Ti</code>: Array of turbulence intensity values for each turbine index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_turbulence.jl#L4-L17">source</a></section><section><div><pre><code class="language-julia hljs">getWindTiT(::TI_Interpolation, wind_ti::AbstractMatrix, iT, t)</code></pre><p>Interpolates the wind turbulence intensity (TI) at a given time <code>t</code> using the specified <code>TI_Interpolation</code> method.</p><p><strong>Arguments</strong></p><ul><li><code>::TI_Interpolation</code>: Use linear interpolation to calculate the turbulence intensity.</li><li><code>wind_ti::Matrix</code>: Matrix containing wind turbulence intensity values over time.</li><li><code>iT</code>: Index/indices of the turbines (can be Int or array).</li><li><code>t</code>: The specific time at which to interpolate the turbulence intensity.</li></ul><p><strong>Returns</strong></p><ul><li>The interpolated turbulence for the requested turbine(s) at time <code>t</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The function assumes that <code>wind_ti</code> contains the necessary data for interpolation as (time, TI) pairs (n×2 matrix)</li><li>Uniform interpolation version - all turbines experience the same changes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_turbulence.jl#L54-L72">source</a></section><section><div><pre><code class="language-julia hljs">getWindTiT(::TI_InterpTurbine, wind_ti::AbstractMatrix, iT, t)</code></pre><p>Retrieve the wind turbulence intensity (TI) for a specific turbine at a given time.</p><p><strong>Arguments</strong></p><ul><li><code>::TI_InterpTurbine</code>: The turbulence intensity interpolation object for the turbine.</li><li><code>wind_ti::AbstractMatrix</code>: Matrix containing wind turbulence intensity values.</li><li><code>iT</code>: Index of the turbine for which the TI is requested.</li><li><code>t</code>: Time at which the TI value is needed.</li></ul><p><strong>Returns</strong></p><ul><li>The interpolated wind turbulence intensity value for the specified turbine at time <code>t</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/windfield/windfield_turbulence.jl#L139-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.correctTI!"><a class="docstring-binding" href="#FLORIDyn.correctTI!"><code>FLORIDyn.correctTI!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">correctTI!(::TI_None, set::Settings, wf, wind, t) -&gt; Nothing</code></pre><p>Update turbulence intensity values in the wind farm state matrix without correction.</p><p>This function implements the &quot;no correction&quot; strategy for turbulence intensity, where  the wind farm turbulence intensity values are updated with fresh data from the wind  field model without applying any correction algorithms. It serves as the baseline  approach for turbulence intensity handling in FLORIDyn simulations.</p><p><strong>Arguments</strong></p><ul><li><code>::TI_None</code>: Dispatch type indicating no turbulence intensity correction algorithm</li><li><code>set::Settings</code>: Settings object containing simulation configuration and turbulence model parameters<ul><li><code>set.turb_mode</code>: Turbulence model configuration specifying the retrieval method</li></ul></li><li><code>wf::WindFarm</code>: Wind farm object containing the state matrices to be updated<ul><li><code>wf.States_WF</code>: Wind field states matrix where column 3 contains turbulence intensity values</li><li><code>wf.StartI</code>: Starting indices for each turbine&#39;s observation points</li><li><code>wf.nT</code>: Number of turbines</li></ul></li><li><code>wind::Wind</code>: Wind configuration object containing turbulence intensity data<ul><li><code>wind.ti</code>: Turbulence intensity data or model parameters</li></ul></li><li><code>t</code>: Current simulation time for time-dependent turbulence intensity retrieval</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: The function modifies the wind farm state in-place</li></ul><p><strong>Behavior</strong></p><ol><li>Retrieves current turbulence intensity values for all turbines using <a href="#FLORIDyn.getDataTI"><code>getDataTI</code></a></li><li>Updates the wind farm state matrix <code>wf.States_WF</code> at rows <code>wf.StartI</code> and column 3</li><li>Transposes the turbulence intensity vector to match the matrix structure</li><li>Provides error handling for matrix update operations</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Update turbulence intensity without correction at t=50s
correctTI!(TI_None(), settings, wf, wind, 50.0)

# The wind farm state matrix is now updated with new TI values
current_ti = wf.States_WF[wf.StartI, 3]</code></pre><p><strong>Notes</strong></p><ul><li>The function modifies the wind farm object in-place (indicated by the <code>!</code> suffix)</li><li>This &quot;no correction&quot; approach provides baseline turbulence intensity without  applying wake-induced corrections or measurement-based adjustments</li><li>Error handling ensures graceful failure if matrix dimensions are incompatible</li></ul><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.getDataTI"><code>getDataTI</code></a>: Function used to retrieve turbulence intensity data</li><li><a href="../types/#FLORIDyn.TI_None"><code>TI_None</code></a>: Dispatch type for no correction strategy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/correction/turbulence.jl#L4-L53">source</a></section><section><div><pre><code class="language-julia hljs">correctTI!(::TI_Influence, set::Settings, wf::WindFarm, wind::Wind, t)</code></pre><p>Apply influence-based turbulence intensity correction where each turbine&#39;s turbulence intensity depends on upstream operational points through dependency relationships and interpolation weights.</p><p><strong>Arguments</strong></p><ul><li><code>::TI_Influence</code>: Turbulence intensity correction strategy that uses dependency-based influence modeling</li><li><code>set::Settings</code>: Simulation settings containing turbulence intensity mode and interpolation parameters</li><li><code>wf::WindFarm</code>: Wind farm object with turbine states and dependency configuration (modified in-place)</li><li><code>wind::Wind</code>: Wind field data containing turbulence intensity time series or model parameters</li><li><code>t</code>: Current simulation time for temporal interpolation</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: Modifies wind farm state in-place</li></ul><p><strong>Description</strong></p><p>This correction strategy implements dependency-based turbulence intensity modeling where each turbine&#39;s ambient turbulence intensity is influenced by upstream operational points. The function processes each turbine individually based on its dependency configuration and updates column 3 of the wind farm state matrix (<code>wf.States_WF[:, 3]</code>).</p><p><strong>Processing Logic per Turbine</strong></p><ol><li><strong>No Dependencies</strong>: If <code>wf.dep[iT]</code> is empty, assigns the raw ambient turbulence intensity <code>TI[iT]</code></li><li><strong>Single Influence Row</strong>: For <code>wf.intOPs[iT]</code> with one 4-column row <code>[idx1 w1 idx2 w2]</code>, computes turbulence intensity as <code>w1 * States_WF[idx1,3] + w2 * States_WF[idx2,3]</code></li><li><strong>Multiple Influence Rows</strong>: For multiple 4-column rows, computes the arithmetic mean of per-row interpolated turbulence intensities (simple averaging without additional weighting)</li><li><strong>Fallback Cases</strong>: Uses raw ambient turbulence intensity <code>TI[iT]</code> for malformed data or invalid indices</li></ol><p><strong>Key Features</strong></p><ul><li><strong>Index Validation</strong>: Validates all operational point indices before accessing state data</li><li><strong>Robust Handling</strong>: Gracefully handles missing or malformed dependency/interpolation data</li><li><strong>Sequential Processing</strong>: Uses already-corrected turbine TI values within the same iteration</li><li><strong>Bounds Checking</strong>: Prevents out-of-bounds access to the wind farm state matrix</li><li><strong>Simple Averaging</strong>: Multiple influence rows are combined using arithmetic mean (MATLAB-consistent)</li></ul><p><strong>Data Structure Requirements</strong></p><ul><li><code>wf.dep[iT]</code>: Vector of turbine indices that influence turbine <code>iT</code></li><li><code>wf.intOPs[iT]</code>: Matrix where each row is <code>[idx1 w1 idx2 w2]</code> for linear interpolation</li><li><code>wf.StartI</code>: 1×nT matrix containing starting row indices for each turbine</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Single influence case - turbine 2 influenced by OPs at indices 1 and 3
wf.dep[2] = [1, 3]
wf.intOPs[2] = [1 0.4 3 0.6]  # 40% from OP 1, 60% from OP 3
correctTI!(TI_Influence(), settings, wf, wind, 100.0)

# Multiple influence case with mean averaging
wf.dep[3] = [1, 2, 4]
wf.intOPs[3] = [1 0.3 2 0.7; 2 0.2 4 0.8]  # Two influence combinations
# Result: mean of (0.3*TI[1] + 0.7*TI[2]) and (0.2*TI[2] + 0.8*TI[4])
correctTI!(TI_Influence(), settings, wf, wind, 100.0)</code></pre><p><strong>Implementation Details</strong></p><ul><li>Uses <code>StartI[1, iT]</code> indexing (1×nT matrix layout) to access turbine starting positions</li><li>Performs bounds checking on all operational point indices before state access</li><li>Skips invalid indices and counts valid ones for proper averaging in multiple-row cases</li><li>Does not use distance weighting or sophisticated spatial models (matches MATLAB behavior)</li><li>Compatible with different turbulence intensity input modes (constant, interpolated, etc.)</li></ul><p><strong>Error Handling</strong></p><ul><li>Invalid operational point indices are skipped with fallback to ambient turbulence intensity</li><li>Missing dependency/interpolation arrays are treated as empty (no influence)</li><li>Malformed interpolation matrices (wrong dimensions) trigger fallback behavior</li><li>Zero valid interpolations in multiple-row case falls back to ambient TI</li></ul><p><strong>Turbulence Intensity Integration</strong></p><ul><li>Base TI values obtained via <code>getDataTI</code> which supports multiple input modes</li><li>Compatible with constant, interpolated, and time-varying turbulence intensity sources</li><li>Turbulence intensity values are dimensionless (typically 0.05-0.25)</li></ul><p><strong>Notes</strong></p><ul><li>Unlike velocity and direction corrections, this function does not use Weight arrays for combining multiple rows</li><li>The MATLAB reference uses simple mean averaging for multiple influence combinations</li><li>Order of turbine processing matters as earlier turbines&#39; corrected TI affects later calculations</li><li>More computationally intensive than <code>TI_None</code> due to dependency processing</li></ul><p><strong>See also</strong></p><ul><li><a href="#FLORIDyn.getDataTI"><code>getDataTI</code></a>: Function for retrieving ambient turbulence intensity data</li><li><a href="#FLORIDyn.correctTI!"><code>correctTI!(::TI_None, set::Settings, wf, wind, t)</code></a>: Simpler TI correction without influence</li><li><a href="../settings/#Settings"><code>Settings</code></a>: Simulation settings structure containing turbulence intensity mode</li><li><a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>: Wind farm configuration structure with dependency data</li><li><a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>: Wind field data structure containing turbulence intensity information</li></ul><p><strong>WARNING:</strong></p><p>This correction method is not properly tested. Use at your own risk!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/correction/turbulence.jl#L125-L214">source</a></section></details></article><h1 id="Controller-functions"><a class="docs-heading-anchor" href="#Controller-functions">Controller functions</a><a id="Controller-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Controller-functions" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.getYaw"><a class="docstring-binding" href="#FLORIDyn.getYaw"><code>FLORIDyn.getYaw</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getYaw(::Yaw_SOWFA, con::Con, iT, t) -&gt; Float64 or Vector{Float64}</code></pre><p>Return the yaw angle at time <code>t</code> for the specified turbine(s) using linear interpolation from controller data.</p><p><strong>Arguments</strong></p><ul><li><code>::Yaw_SOWFA</code>: Controller type dispatch parameter for SOWFA-style yaw control</li><li><code>con::Con</code>: Controller configuration struct containing yaw control data</li><li><code>iT</code>: Turbine index or indices to query:<ul><li><code>Integer</code>: Single turbine index (1-based)</li><li><code>AbstractVector{&lt;:Integer}</code>: Vector of turbine indices for multiple turbines</li></ul></li><li><code>t::Real</code>: Requested time (in seconds)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Single yaw angle (in degrees) if <code>iT</code> is an integer</li><li><code>Vector{Float64}</code>: Vector of yaw angles (in degrees) if <code>iT</code> is a vector</li></ul><p><strong>Behavior</strong></p><ul><li><strong>Interpolation</strong>: Uses linear interpolation between time points with flat extrapolation</li><li><strong>Data source</strong>: Retrieves yaw data from <code>con.yaw_data</code> matrix</li><li><strong>Out-of-bounds handling</strong>: If <code>t</code> is outside the time range, the function:<ul><li>Issues a warning message</li><li>Clamps <code>t</code> to the nearest boundary (first or last time point)</li></ul></li><li><strong>Single time point</strong>: If only one time point exists, returns the corresponding yaw value directly</li><li><strong>Error handling</strong>: Throws an error if <code>iT</code> is not an integer or vector of integers</li></ul><p><strong>Data Format</strong></p><p>The <code>con.yaw_data</code> matrix should have the structure:</p><pre><code class="language-julia hljs">[time₁  yaw₁₁  yaw₁₂  ...  yaw₁ₙ]
[time₂  yaw₂₁  yaw₂₂  ...  yaw₂ₙ]
[  ⋮      ⋮      ⋮    ⋱     ⋮  ]
[timeₘ  yawₘ₁  yawₘ₂  ...  yawₘₙ]</code></pre><p>where <code>m</code> is the number of time steps and <code>n</code> is the number of turbines.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create controller configuration with yaw data
con = Con(yaw=&quot;SOWFA&quot;, yaw_data=[0.0  10.0  5.0;   # t=0s: T1=10°, T2=5°
                                 1.0  15.0  10.0;  # t=1s: T1=15°, T2=10°
                                 2.0  20.0  15.0]) # t=2s: T1=20°, T2=15°

# Get yaw for turbine 1 at t=0.5s (interpolated)
yaw1 = getYaw(Yaw_SOWFA(), con, 1, 0.5)  # Returns 12.5°

# Get yaw for multiple turbines at t=1.5s
yaws = getYaw(Yaw_SOWFA(), con, [1, 2], 1.5)  # Returns [17.5°, 12.5°]

# Out-of-bounds time (will issue warning)
yaw_oob = getYaw(Yaw_SOWFA(), con, 1, 5.0)  # Returns 20.0° with warning</code></pre><p><strong>See Also</strong></p><ul><li><a href="../types/#FLORIDyn.Yaw_SOWFA"><code>Yaw_SOWFA</code></a>: Controller type for SOWFA-style yaw control</li><li><a href="../settings/#FLORIDyn.Con"><code>Con</code></a>: Controller configuration struct</li><li><code>Interpolations.linear_interpolation</code>: Underlying interpolation method used</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/controller/controller.jl#L4-L61">source</a></section><section><div><pre><code class="language-julia hljs">getYaw(::Yaw_Constant, con::Con, iT, t) -&gt; Float64 or Vector{Float64}</code></pre><p>Return a single constant yaw angle for one or multiple turbines.</p><p><strong>Arguments</strong></p><ul><li><code>::Yaw_Constant</code>: Controller type dispatch parameter for constant yaw control</li><li><code>con::Con</code>: Controller configuration struct containing fixed yaw value</li><li><code>iT</code>: Turbine index or indices to query:<ul><li><code>Integer</code>: Single turbine index (1-based) </li><li><code>AbstractVector{&lt;:Integer}</code>: Vector of turbine indices for multiple turbines</li></ul></li><li><code>t::Real</code>: Requested time (ignored for constant yaw, kept for uniform interface)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Single yaw angle (in degrees) if <code>iT</code> is an integer</li><li><code>Vector{Float64}</code>: Vector of yaw angles (in degrees) if <code>iT</code> is a vector</li></ul><p><strong>Behavior</strong></p><ul><li><strong>Constant value</strong>: Uses <code>con.yaw_fixed</code> as the yaw angle for all turbines and times</li><li><strong>Time independence</strong>: The time parameter <code>t</code> is ignored since yaw is constant</li><li><strong>Multiple turbines</strong>: Returns the same constant value for all requested turbines</li><li><strong>Error handling</strong>: Throws an error if <code>iT</code> is not an integer or vector of integers</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create controller configuration with constant yaw
con = Con(yaw=&quot;Constant&quot;, yaw_fixed=270.0)  # 270° constant yaw

# Get yaw for turbine 1 (any time)
yaw1 = getYaw(Yaw_Constant(), con, 1, 100.0)  # Returns 270.0°

# Get yaw for multiple turbines
yaws = getYaw(Yaw_Constant(), con, [1, 2, 3], 50.0)  # Returns [270.0°, 270.0°, 270.0°]</code></pre><p><strong>See Also</strong></p><ul><li><a href="../types/#FLORIDyn.Yaw_Constant"><code>Yaw_Constant</code></a>: Controller type for constant yaw control</li><li><a href="../settings/#FLORIDyn.Con"><code>Con</code></a>: Controller configuration struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/controller/controller.jl#L99-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.getInduction"><a class="docstring-binding" href="#FLORIDyn.getInduction"><code>FLORIDyn.getInduction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getInduction(::Induction_Constant, con::Con, iT, t) -&gt; Float64 or Vector{Float64}</code></pre><p>Return a single constant induction factor for one or multiple turbines.</p><p><strong>Arguments</strong></p><ul><li><code>::Induction_Constant</code>: Controller type dispatch parameter for constant induction control</li><li><code>con::Con</code>: Controller configuration struct containing fixed induction value</li><li><code>iT</code>: Turbine index or indices to query:<ul><li><code>Integer</code>: Single turbine index (1-based)</li><li><code>AbstractVector{&lt;:Integer}</code>: Vector of turbine indices for multiple turbines</li></ul></li><li><code>t::Real</code>: Requested time (ignored for constant induction, kept for uniform interface)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Single induction factor if <code>iT</code> is an integer</li><li><code>Vector{Float64}</code>: Vector of induction factors if <code>iT</code> is a vector</li></ul><p><strong>Behavior</strong></p><ul><li><strong>Constant value</strong>: Uses <code>con.induction_fixed</code> as the induction factor for all turbines and times</li><li><strong>Time independence</strong>: The time parameter <code>t</code> is ignored since induction is constant</li><li><strong>Multiple turbines</strong>: Returns the same constant value for all requested turbines</li><li><strong>Error handling</strong>: Throws an error if <code>iT</code> is not an integer or vector of integers</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create controller configuration with constant induction
con = Con(induction=&quot;Constant&quot;, induction_fixed=0.33)  # 0.33 constant induction factor

# Get induction for turbine 1 (any time)
induction1 = getInduction(Induction_Constant(), con, 1, 100.0)  # Returns 0.33

# Get induction for multiple turbines
inductions = getInduction(Induction_Constant(), con, [1, 2, 3], 50.0)  # Returns [0.33, 0.33, 0.33]</code></pre><p><strong>See Also</strong></p><ul><li><a href="../types/#FLORIDyn.Induction_Constant"><code>Induction_Constant</code></a>: Controller type for constant induction control</li><li><a href="../settings/#FLORIDyn.Con"><code>Con</code></a>: Controller configuration struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/controller/controller.jl#L149-L187">source</a></section><section><div><pre><code class="language-julia hljs">getInduction(::Induction_TGC, con::Con, iT, t) -&gt; Float64 or Vector{Float64}</code></pre><p>Return the induction factor at time <code>t</code> for the specified turbine(s) using linear interpolation from controller data.</p><p><strong>Arguments</strong></p><ul><li><code>::Induction_TGC</code>: Controller type dispatch parameter for TGC-style induction control</li><li><code>con::Con</code>: Controller configuration struct containing induction control data</li><li><code>iT</code>: Turbine index or indices to query:<ul><li><code>Integer</code>: Single turbine index (1-based)</li><li><code>AbstractVector{&lt;:Integer}</code>: Vector of turbine indices for multiple turbines</li></ul></li><li><code>t::Real</code>: Requested time (in seconds)</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Single induction factor if <code>iT</code> is an integer</li><li><code>Vector{Float64}</code>: Vector of induction factors if <code>iT</code> is a vector</li></ul><p><strong>Behavior</strong></p><ul><li><strong>Interpolation</strong>: Uses linear interpolation between time points with flat extrapolation</li><li><strong>Data source</strong>: Retrieves induction data from <code>con.induction_data</code> matrix</li><li><strong>Out-of-bounds handling</strong>: If <code>t</code> is outside the time range, the function:<ul><li>Issues a warning message</li><li>Clamps <code>t</code> to the nearest boundary (first or last time point)</li></ul></li><li><strong>Single time point</strong>: If only one time point exists, returns the corresponding induction value directly</li><li><strong>Error handling</strong>: Throws an error if <code>iT</code> is not an integer or vector of integers</li></ul><p><strong>Data Format</strong></p><p>The <code>con.induction_data</code> matrix should have the structure:</p><pre><code class="language-julia hljs">[time₁  induction₁₁  induction₁₂  ...  induction₁ₙ]
[time₂  induction₂₁  induction₂₂  ...  induction₂ₙ]
[  ⋮        ⋮            ⋮        ⋱       ⋮     ]
[timeₘ  inductionₘ₁  inductionₘ₂  ...  inductionₘₙ]</code></pre><p>where <code>m</code> is the number of time steps and <code>n</code> is the number of turbines.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create controller configuration with induction data
con = Con(induction=&quot;TGC&quot;, 
          induction_data=[0.0  0.30  0.25;   # t=0s: T1=0.30, T2=0.25
                         1.0  0.35  0.30;   # t=1s: T1=0.35, T2=0.30
                         2.0  0.40  0.35])  # t=2s: T1=0.40, T2=0.35

# Get induction for turbine 1 at t=0.5s (interpolated)
induction1 = getInduction(Induction_TGC(), con, 1, 0.5)  # Returns 0.325

# Get induction for multiple turbines at t=1.5s
inductions = getInduction(Induction_TGC(), con, [1, 2], 1.5)  # Returns [0.375, 0.325]

# Out-of-bounds time (will issue warning)
induction_oob = getInduction(Induction_TGC(), con, 1, 5.0)  # Returns 0.40 with warning</code></pre><p><strong>See Also</strong></p><ul><li><a href="../types/#FLORIDyn.Induction_TGC"><code>Induction_TGC</code></a>: Controller type for TGC-style induction control</li><li><a href="../settings/#FLORIDyn.Con"><code>Con</code></a>: Controller configuration struct</li><li><code>Interpolations.linear_interpolation</code>: Underlying interpolation method used</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/controller/controller.jl#L199-L257">source</a></section></details></article><h1 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="FLORIDyn.toMSR"><a class="docstring-binding" href="#FLORIDyn.toMSR"><code>FLORIDyn.toMSR</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">toMSR(s::String)</code></pre><p>Converts the input string <code>s</code> to a MSR (Measurement System Representation) enumeration.</p><p>Supports the following string formats:</p><ul><li>Enum names: <code>&quot;VelReduction&quot;</code>, <code>&quot;AddedTurbulence&quot;</code>, <code>&quot;EffWind&quot;</code></li><li>Flow field names: <code>&quot;flow_field_vel_reduction&quot;</code>, <code>&quot;flow_field_added_turbulence&quot;</code>, <code>&quot;flow_field_eff_wind_speed&quot;</code></li><li>Measurement names: <code>&quot;msr_vel_reduction&quot;</code>, <code>&quot;msr_added_turbulence&quot;</code>, <code>&quot;msr_eff_wind_speed&quot;</code></li></ul><p>See also <a href="../types/#FLORIDyn.MSR"><code>MSR</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/FLORIDyn.jl#L120-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.now_microseconds"><a class="docstring-binding" href="#FLORIDyn.now_microseconds"><code>FLORIDyn.now_microseconds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">now_microseconds()::String</code></pre><p>Returns current timestamp as a string with microsecond resolution. Format: &quot;YYYY-mm-ddTHH-MM-SS.uuuuuu&quot;</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; now_microseconds()
&quot;2025-08-08T16-58-55.494911&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/visualisation/high_res_time.jl#L7-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.now_nanoseconds"><a class="docstring-binding" href="#FLORIDyn.now_nanoseconds"><code>FLORIDyn.now_nanoseconds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">now_nanoseconds()::String</code></pre><p>Returns current timestamp as a string with nanosecond resolution. Format: &quot;YYYY-mm-ddTHH-MM-SS.nnnnnnnnn&quot;</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; now_nanoseconds()
&quot;2025-08-08T16-58-55.494911123&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/visualisation/high_res_time.jl#L38-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.precise_now"><a class="docstring-binding" href="#FLORIDyn.precise_now"><code>FLORIDyn.precise_now</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">precise_now()::String</code></pre><p>Alias for now_microseconds() - returns current timestamp with microsecond resolution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/visualisation/high_res_time.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.unique_name"><a class="docstring-binding" href="#FLORIDyn.unique_name"><code>FLORIDyn.unique_name</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unique_name()::String</code></pre><p>Creates a unique directory name for storing simulation results.</p><p>This function generates a unique directory name by combining the prefix &quot;floridyn<em>run</em>&quot; with a high-resolution timestamp. The timestamp includes microsecond precision to ensure uniqueness even when multiple simulations are started in quick succession.</p><p><strong>Returns</strong></p><ul><li><code>String</code>: A unique directory name in the format <code>&quot;floridyn_run_YYYY-mm-ddTHH-MM-SS.uuuuuu&quot;</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; unique_name()
&quot;floridyn_run_2025-08-08T16-58-55.494911&quot;

julia&gt; unique_name()
&quot;floridyn_run_2025-08-08T16-58-55.495123&quot;</code></pre><p><strong>Notes</strong></p><ul><li>The generated name is suitable for use as a directory name on all operating systems</li><li>Uses hyphens instead of colons in the time portion for filesystem compatibility</li><li>Microsecond precision ensures uniqueness for rapid successive calls</li><li>Used to create separate output directories for each run</li></ul><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.now_microseconds"><code>now_microseconds</code></a>: The underlying timestamp function used</li><li><a href="../settings/#FLORIDyn.Vis"><code>Vis</code></a>: Visualization settings that may use unique names for output directories</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/visualisation/high_res_time.jl#L74-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.isdelftblue"><a class="docstring-binding" href="#FLORIDyn.isdelftblue"><code>FLORIDyn.isdelftblue</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isdelftblue() -&gt; Bool</code></pre><p>Check if the current environment is the Delft Blue supercomputer.</p><p>This function determines whether the code is running on the Delft Blue supercomputer by checking for the existence of the <code>~/scratch</code> directory, which is a characteristic feature of the Delft Blue file system.</p><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if running on Delft Blue (i.e., <code>~/scratch</code> directory exists),          <code>false</code> otherwise.</li></ul><p><strong>Usage</strong></p><p>This function is used throughout FLORIDyn.jl to automatically adapt file paths  to the computing environment. On Delft Blue, output files are stored in the  scratch directory, which can be accessed remotely and offers lots of space.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">if isdelftblue()
    output_path = joinpath(homedir(), &quot;scratch&quot;, &quot;out&quot;)
else
    output_path = joinpath(pwd(), &quot;out&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/settings.jl#L1202-L1228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.find_floridyn_runs"><a class="docstring-binding" href="#FLORIDyn.find_floridyn_runs"><code>FLORIDyn.find_floridyn_runs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">find_floridyn_runs(directory::String = pwd())</code></pre><p>Find all directories starting with &quot;floridyn_run&quot; in the specified directory.</p><p><strong>Arguments</strong></p><ul><li><code>directory::String</code>: Directory to search in (default: current working directory)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: List of full paths to floridyn_run directories, sorted by name</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Find floridyn_run directories in current directory
dirs = find_floridyn_runs()

# Find in specific directory
dirs = find_floridyn_runs(&quot;out&quot;)

# Count how many exist
count = length(find_floridyn_runs())</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.delete_results"><code>delete_results</code></a>: Function that uses this to find directories to delete</li><li><a href="#FLORIDyn.unique_name"><code>unique_name</code></a>: Function that creates these directories</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/visualisation/high_res_time.jl#L237-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="FLORIDyn.delete_results"><a class="docstring-binding" href="#FLORIDyn.delete_results"><code>FLORIDyn.delete_results</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">delete_results(vis::Vis, n::Int=1; dry_run::Bool = false)</code></pre><p>Delete the newest <code>n</code> directories starting with &quot;floridyn_run&quot; from both the visualization  output directory and video directory.</p><p>This function provides comprehensive cleanup by removing the most recent floridyn_run directories from both output and video paths simultaneously. It&#39;s particularly useful for removing failed runs,  test runs, or managing disk space by keeping only the most relevant simulation outputs across both directory types.</p><p><strong>Arguments</strong></p><ul><li><code>vis::Vis</code>: Visualization settings object containing both output and video path configurations</li><li><code>n::Int</code>: Number of newest directories to delete from each directory (must be positive, default: 1)  </li><li><code>dry_run::Bool</code>: Preview mode - shows what would be deleted without actually deleting (default: <code>false</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Absolute paths of directories that were deleted from both locations combined. Returns empty vector if no matching directories found or if <code>n ≤ 0</code>.</li></ul><p><strong>Behavior</strong></p><ul><li><strong>Directory Search</strong>: Searches both <code>vis.output_path</code> and <code>vis.video_path</code> for directories matching <code>floridyn_run_*</code> pattern</li><li><strong>Dual Cleanup</strong>: Operates on both output and video directories in sequence</li><li><strong>Sorting</strong>: Sorts directories by modification time (newest first) within each directory</li><li><strong>Selection</strong>: Selects up to <code>n</code> newest directories for deletion from each location</li><li><strong>Dry Run</strong>: When <code>dry_run=true</code>, logs what would be deleted but performs no actual deletion</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create visualization settings
vis = Vis(&quot;data/vis_default.yaml&quot;)

# Delete the single newest floridyn_run directory from both output and video directories
deleted = delete_results(vis)
println(&quot;Deleted: &quot;, length(deleted), &quot; directories total&quot;)

# Delete the 3 newest floridyn_run directories from each location
deleted = delete_results(vis, 3)
println(&quot;Deleted directories: &quot;, basename.(deleted))</code></pre><p><strong>Important Notes</strong></p><ul><li><strong>Dual Operation</strong>: This function operates on BOTH output and video directories</li><li><strong>Independent Processing</strong>: Each directory is processed separately - <code>n</code> directories from output AND <code>n</code> directories from video</li><li><strong>Non-existent Directories</strong>: Silently skips directories that don&#39;t exist rather than creating them</li></ul><p><strong>See Also</strong></p><ul><li><a href="../settings/#FLORIDyn.Vis"><code>Vis</code></a>: Visualization settings struct with output and video path configuration</li><li><a href="#FLORIDyn.unique_name"><code>unique_name()</code></a>: Creates timestamped floridyn_run directories</li><li><a href="#FLORIDyn.find_floridyn_runs"><code>find_floridyn_runs()</code></a>: Lists existing floridyn_run directories in a given path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/5b21218453bb2551c2a93823221d520c22f89975/src/visualisation/high_res_time.jl#L109-L159">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Exported Types</a><a class="docs-footer-nextpage" href="../functions_II/">High-Level Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 31 December 2025 20:46">Wednesday 31 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
