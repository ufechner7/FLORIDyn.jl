var documenterSearchIndex = {"docs":
[{"location":"settings/#Simulation-settings","page":"Settings","title":"Simulation settings","text":"","category":"section"},{"location":"settings/#Introduction","page":"Settings","title":"Introduction","text":"","category":"section"},{"location":"settings/","page":"Settings","title":"Settings","text":"The settings are defined in five .yaml files in the folder data, one to define the simulation and one to define the visualization. In addition, there is a projects.yaml and a default.yaml file  The function setup converts the first one into three settings structs, containing strings and numbers. The constructor Settings creates a struct of marker types from these settings structs. ","category":"page"},{"location":"settings/","page":"Settings","title":"Settings","text":"For each of the simulation yaml files there must be a folder with the same name (without the .yaml extension) in the data directory. In this folder the required .csv files must be stored.","category":"page"},{"location":"settings/","page":"Settings","title":"Settings","text":"The constructor Vis(filename) creates a visualisation settings struct from the visualisation yaml file. The file turbine_specs.yaml contains the turbine definitions.","category":"page"},{"location":"settings/","page":"Settings","title":"Settings","text":"A project has a name and a description  and consists of the two yaml files mentioned above. The default.yaml file is autogenerated and must NOT be in git. It stores the name of the active project and the name of the default measurement.","category":"page"},{"location":"settings/#The-file-2021_9T_Data.yaml","page":"Settings","title":"The file 2021_9T_Data.yaml","text":"","category":"section"},{"location":"settings/","page":"Settings","title":"Settings","text":"This is the main input configuration file.","category":"page"},{"location":"settings/","page":"Settings","title":"Settings","text":"# FLORIDyn project configuration\n#\n# Flow conditions\n# Choose the input files for wind velocity, direction and ambient turbulence intensity as well as shear.\nwind:\n  # Velocity Input\n  # - I_and_I       uses the Immersion and Invariance effective wind speed estimator based on SOWFA data. \n  # - Interpolation linearly interpolates between set-points, the value is equally used for all turbines.\n  # - Interpolation_wErrorCov Same as above, but with error covariance. \n  # - InterpTurbine also linearly interpolates between set-points, but individually for every turbine. \n  # - InterpTurbine_wErrorCov Same as above, but with error covariance.\n  # - Constant      provides a constant velocity for all turbines.\n  # - Constant_wErrorCov      Same as above, but with error covariance.\n  # - EnKF_InterpTurbine\n  # - RW_with_Mean  random walk with mean\n  # - ZOH_wErrorCov\n  input_vel: Constant\n\n  # Wind Direction Input\n  # - Constant\n  # - Constant_wErrorCov\n  # - Interpolation\n  # - Interpolation_wErrorCov\n  # - InterpTurbine\n  # - InterpTurbine_wErrorCov\n  # - RW_with_mean             random walk with mean\n  input_dir: Interpolation\n  input_ti: Constant\n  input_shear: PowerLaw\n  correction:\n    vel: None\n    dir: All\n    ti: None\n  perturbation:\n    vel: 0\n    vel_sigma: 0.2\n    dir: 0\n    dir_sigma: 0.5\n    ti: 0\n    ti_sigma: 0.005\n\nsim:\n  # the used FLORIS model; currently, only 'gaussian' is supported\n  floris: gaussian\n  # start & end time of the simulation and the time resolution. \n  start_time: 20000       # [s]\n  end_time: 21200         # [s]\n  time_step: 4            # [s]\n\n  # The discretization method, 'sunflower' or 'isocell'. The latter provides a regular grid \n  # with equal sized cells. This is the favoured method! Downside is that the number of cells\n  # can not be chosen freely, the algorithm might correct the requested number of cells to \n  # the nearest possible number (3, 12, 27, 48, 75, 108, 147, ...).  \n  # Sunflower distributes based on an outgoing spiral, the number of cells can be freely chosen.\n  rotor_discret: isocell\n  rotor_points: 50 # number of points for the discretization of the rotor disk\n  \n  # Dynamic settings\n  dyn:\n    # Advection speed\n    # Multiplier of the travel speed of the OPs with their own wind speed. \n    # The published FLORIDyn models used 1, other literature suggests values as low as 0.6.\n    advection: 1\n    advection_mod: linear\n    # Operating point (OP) / wind field propagation\n    # 'Basic'    iterates the OPs based on their wind speed, OPs do not interact with each other. \n    # 'Averaged' is a weighted average between the new wind speed value and the old value. \n    #            This smoothes out turbulent inputs and reduces the occasions when one OP overtakes another OP. \n    # 'Maximum'  overwrites the state of a slower OP once the faster one overtakes it.\n    op_iteration: IterateOPs_basic\n    # In case the averaging is used, provide weights for the new value (first weight) \n    # and the old value (second value). They have to sum up to 1.\n    op_iter_weights: [0.7, 0.3]\n    vel:\n      # Spacial-Time-Averaged weight settings for the wind speed\n      #   Lejeune: 512 63 126\n      #   Becker Energies: 256 126 256\n      #   Becker CLC: 256 256 50\n      iter_sigma_dw: 256\n      iter_sigma_cw: 256\n      iter_sigma_time: 50\n    dir:\n      # Spacial-Time-Averaged weight settings for the wind direction\n      iter_sigma_dw: 512\n      iter_sigma_cw: 512\n      iter_sigma_time: 50\n  # Choose if simulation should be initialized, an initialized state should be loaded \n  # or should be started without initialization.\n  init: noinit # 'noinit' or 'load' (load requires initT.jld2)\n  path_to_data: \"data/2021_9T_Data\"\n  save_init_state: false  # if true, stores T_init.jld2\n  save_final_state: false # if true, stores T_final.jld2\n\n# Controller\n# Currently only the yaw angle can be set, the axial induction factor is always set to 1/3.\n# - 'Interpolate' per turbine reads an orientation file 'Control_YawInterpolation.csv' \n#                 to interpolate the turbines world orientation between different set-points. \n# - SOWFA         reads the file 'SOWFA_nacelleYaw.csv' which is directly the renamed file\n#                 from a SOWFA simulation. \n# - Constant      reads a single orientation and applies it to all turbines at all times.\ncon:\n  yaw: SOWFA\n\nfloris:\n  alpha: 2.32\n  beta: 0.154\n  k_a: 0.3837\n  k_b: 0.0037\n  k_fa: 0.73\n  k_fb: 0.8325\n  k_fc: 0.0325\n  k_fd: -0.32\n  eta: 1\n  p_p: 2.2\n  airDen: 1.225 # kg/m^3 (SOWFA)\n  TIexp: 3 # TI crosswind distribution is modelled as a factor of sigma_y and sigma_z.\n           # This is in contrast to previous literature which assumed a fixed box area and the\n           # turbines therein as source of higher TI.\n\nfloridyn:\n  n_op: 200\n  deltaUW: 10.0\n  deltaDW: 0.5\n  deltaCW: 3.0\n  dynStateChange: \"None\"\n  twf_model: \"heterogeneous\"\n\nturbines:\n    - id: 1\n      type: DTU 10MW\n      x: 600\n      y: 2400\n      z: 0\n      a: 0.33\n      yaw: 0\n      ti: 0.06\n...\n    - id: 9\n      type: DTU 10MW\n      x: 2400\n      y: 600\n      z: 0\n      a: 0.33\n      yaw: 0\n      ti: 0.06\n","category":"page"},{"location":"settings/#The-file-vis_default.yaml","page":"Settings","title":"The file vis_default.yaml","text":"","category":"section"},{"location":"settings/","page":"Settings","title":"Settings","text":"This is the default file, used to configure the simulation output. All plots listed in the sections flow_fields and measurements are created in the output folder when running the script main_all.jl.","category":"page"},{"location":"settings/","page":"Settings","title":"Settings","text":"vis:\n  show_plots: true       # Enable/disable showing plots during simulation\n  log_debug: false       # Enable/disable logging of debug information\n  save: true             # Enable/disable saving of plots to disk\n  save_results: true     # Enable/disable saving of simulation results as .jld2 files\n  print_filenames: false # If true, print the names of the saved files\n  video_folder: \"video\"  # Relative video folder path \n  output_folder: \"out\"   # Relative output folder path\n  unique_output_folder: true # If true, a unique output folder is created for each simulation run\n  skip_flow_fields: false    # When true, do not create flow field visualizations\n  skip_measurements: false   # When true, do not create measurement visualizations\n  field_limits_min: [0.0, 0.0, 0.0]          # [xmin, ymin, zmin] in meters\n  field_limits_max: [3000.0, 3000.0, 400.0]  # [xmax, ymax, zmax] in meters\n  field_resolution: 20.0                     # Resolution of the field in meters\n  flow_fields:               # List of flow field visualizations to be created\n    - name: \"flow_field_vel_reduction\"    # Flow field relative wind speed (video)\n      online: true\n      create_video: true\n      skip: true\n    - name: \"flow_field_vel_reduction\"    # Flow field relative wind speed (plot)\n      online: false\n      create_video: false\n      skip: false      \n    - name: \"flow_field_added_turbulence\" # Flow field added turbulence\n      online: true\n      create_video: true\n      skip: true\n    - name: \"flow_field_eff_wind_speed\"   # Flow field effective wind speed\n      online: false\n      create_video: false\n      skip: false\n  measurements:           # List of measurement plots to be created\n    - name: \"msr_vel_reduction\"     # Measurement relative wind speed\n      separated: true\n      skip: false\n    - name: \"msr_vel_reduction\"     # Measurement relative wind speed\n      separated: false\n      skip: false\n    - name: \"msr_added_turbulence\"  # Measurement added turbulence\n      separated: false\n      skip: false\n    - name: \"msr_added_turbulence\"  # Measurement added turbulence\n      separated: true\n      skip: false\n    - name: \"msr_eff_wind_speed\"    # Measurement effective wind speed\n      separated: false\n      skip: false\n    - name: \"msr_eff_wind_speed\"    # Measurement effective wind speed\n      separated: true\n      skip: false\n  v_min:  2.0   # Minimum velocity for color scale in flow field visualizations [m/s] \n  v_max: 10.0   # Maximum velocity for color scale in flow field visualizations [m/s]\n  # Minimum relative velocity value for velocity reduction visualizations (msr=VelReduction)\n  # Controls the color scale for relative wind speed plots. Range: 0 .. 100 %\n  rel_v_min:  20.0 # Unit: [%]\n  # Maximum relative velocity value for velocity reduction visualizations (msr=VelReduction)\n  # Controls the upper limit for relative wind speed plots. Range: 0 .. 100 %\n  rel_v_max: 100.0 # Unit: [%]\n  # Maximum turbulence value for added turbulence visualizations (msr=AddedTurbulence)\n  # Controls the upper limit for turbulence plots\n  turb_max: 35.0   # Turbulence intensity, Unit: [%]\n  up_int: 1        # Update interval - how frequently visualization updates occur  [s]\n  unit_test: false # When true, closes plots automatically after 1 second","category":"page"},{"location":"settings/#Types-created-from-the-yaml-files","page":"Settings","title":"Types created from the yaml files","text":"","category":"section"},{"location":"settings/#FLORIDyn.Sim","page":"Settings","title":"FLORIDyn.Sim","text":"Sim\n\nA mutable struct representing the simulation settings.\n\nFields\n\nfloris::String: The name of the FLORIS model to be used.\nstart_time::Int64: The start time of the simulation in seconds.\nend_time::Int64: The end time of the simulation in seconds.\ntime_step::Int64: The time step for the simulation in seconds.\nsim_step::Union{Nothing, Int64}: Optional simulation step size.\nn_sim_steps::Union{Nothing, Int64}: Optional number of simulation steps.\nrotor_discret::String: The rotor discretization method, e.g., \"Uniform\", \"Gaussian\".\nrotor_points::Int64: The number of rotor points for discretization.\ndyn::Dyn: The dynamic settings for the simulation.\ninit::String: The initialization method, e.g., \"init\", \"load\".\npath_to_data::String: The path to the directory where simulation data is stored.\nsave_init_state::Bool: Whether to save the initial state of the simulation.\nsave_final_state::Bool: Whether to save the final state of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Wind","page":"Settings","title":"FLORIDyn.Wind","text":"Wind\n\nA mutable struct representing wind settings.\n\nFields\n\ninput_vel::String: The type of wind velocity input, e.g., \"Constant\", \"Interpolation\".\ninput_dir::String: The type of wind direction input, e.g., \"Constant\", \"Interpolation\".\ninput_ti::String: The type of turbulence intensity input, e.g., \"Constant\", \"Interpolation\".\ninput_shear::String: The type of wind shear input, e.g., \"PowerLaw\", \"Interpolation\".\ncorrection::WindCorrection: Settings for wind corrections.\nperturbation::WindPerturbation: Settings for wind perturbations.\nvel::Union{Nothing, Float64}: Optional wind velocity value.\ndir::Union{Nothing, Matrix{Float64}, WindDirMatrix, WindDirType, WindDirTriple}: Optional wind direction matrix or covariance data.\nti::Union{Nothing, Float64}: Optional turbulence intensity value.\nshear::Union{Nothing, WindShear}: Optional wind shear profile.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Con","page":"Settings","title":"FLORIDyn.Con","text":"Con\n\nA mutable struct for configuration settings.\n\nFields\n\nyaw::String: The yaw control strategy, e.g., \"Constant\", \"Interpolation\".\nyaw_data::Union{Nothing, Matrix{Float64}}: Optional yaw data matrix.\ntanh_yaw::Bool: Whether to use hyperbolic tangent yaw control.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Vis","page":"Settings","title":"FLORIDyn.Vis","text":"Vis\n\nA mutable struct for visualization settings in wind farm simulations.\n\nThis struct controls visualization options during simulation runtime, particularly for live plotting and animation features. It provides both stored fields and computed  properties for flexible path management.\n\nFields\n\nonline::Bool: Enable/disable online visualization during simulation. When true,                  live plots and animations are displayed during the simulation run.                 When false, visualization is disabled for faster computation.\nsave::Bool: Enable/disable saving of plots to disk. When true, plots are saved               to disk in PNG format. When false, plots are only displayed (default: false).\nprint_filenames::Bool: Enable/disable printing of saved filenames to console.                          When true, filenames of saved plots are printed (default: false).\nvideo_folder::String: Relative path for the video output directory. Used when online=true                        and save=true (default: \"video\").\nfps::Int: Frames per second for video output when creating videos from saved frames.            Controls the playback speed of generated MP4 videos (default: 12).\noutput_folder::String: Relative path for the output directory. Used when online=false                         and save=true (default: \"out\").\nunique_output_folder::Bool: If true, a unique timestamped folder is created for each simulation run.                             If false, files are saved directly to the output folder (default: true).\nflow_fields::Vector{FlowField}: List of flow field visualizations to be created. Each FlowField                                   contains configuration for name, online display, video creation, and skip control.                                  See FlowField for details (default: FlowField[]).\nmeasurements::Vector{Measurement}: List of measurement visualizations to be created. Each Measurement                                      contains configuration for name, separated plotting, and skip control.                                     See Measurement for details (default: Measurement[]).\nv_min::Float64: Minimum velocity value for color scale in effective wind speed                   visualizations (msr=EffWind). Used to set consistent color scale limits                   across animation frames (default: 2.0).\nv_max::Float64: Maximum velocity value for color scale in effective wind speed                   visualizations (msr=EffWind). Used to set consistent upper limits across                   animation frames (default: 10.0).\nrel_v_min::Float64: Minimum relative velocity value for velocity reduction                       visualizations (msr=VelReduction). Controls the color scale for relative                       wind speed plots. Range: [0, 100] (default: 20.0).\nrel_v_max::Float64: Maximum relative velocity value for velocity reduction                       visualizations (msr=VelReduction). Controls the upper limit for relative                       wind speed plots. Range: [0, 100] (default: 100.0).\nturb_max::Float64: Maximum turbulence value for added turbulence visualizations (msr=AddedTurbulence).                     Controls the upper limit for turbulence plots (default: 35.0).\nup_int::Int: Update interval - controls how frequently visualization updates occur.               Higher values result in less frequent updates for better performance (default: 1).\nunit_test::Bool: Enable unit test mode for visualization functions. When true,                    plots are automatically closed after 1 second for testing purposes (default: false).\n\nComputed Properties\n\nvideo_path::String: Full absolute path to the video directory. Automatically creates the                       directory if it doesn't exist. Path is environment-dependent:                       ~/scratch/video_folder on Delft Blue, pwd()/video_folder elsewhere.\noutput_path::String: Full absolute path to the output directory. Automatically creates the                        directory if it doesn't exist. Path is environment-dependent:                       ~/scratch/output_folder on Delft Blue, pwd()/output_folder elsewhere.\n\nConstructors\n\n# Default constructor with keyword arguments\nvis = Vis(online=true, save=true, v_min=2.0, v_max=12.0)\n\n# Constructor from YAML file\nvis = Vis(\"path/to/config.yaml\")  # Loads from data[\"vis\"] section\n\nExamples\n\n# Enable online visualization with plot saving and custom color scales\nvis = Vis(online=true, save=true, v_min=2.0, v_max=12.0, rel_v_min=20.0, rel_v_max=100.0, up_int=5)\n\n# Display only, no saving with default color scales\nvis = Vis(online=true, save=false, v_min=2.0, rel_v_min=20.0)\n\n# Specify flow field and measurement visualizations to create\nflow_fields = [FlowField(\"flow_field_vel_reduction\", true, true), FlowField(\"flow_field_added_turbulence\", false, false)]\nmeasurements = [Measurement(\"msr_vel_reduction\", true), Measurement(\"msr_added_turbulence\", false)]\nvis = Vis(online=true, save=true, flow_fields=flow_fields, measurements=measurements)\n\n# Disable online visualization for batch processing\nvis = Vis(online=false, save=false)\n\n# Load from YAML configuration (automatically parses flow_fields and measurements)\nvis = Vis(\"data/vis_default.yaml\")\n\n# Access computed properties (creates directories automatically)\nprintln(\"Saving plots to: \", vis.video_path)  # When online=true\nprintln(\"Output directory: \", vis.output_path) # When online=false\n\nYAML Configuration Format\n\nWhen loading from YAML files, the flow_fields and measurements are automatically parsed:\n\nvis:\n  online: true\n  save: true\n  flow_fields:\n    - name: \"flow_field_vel_reduction\"\n      online: true\n      create_video: true\n      skip: false\n    - \"flow_field_added_turbulence\"  # Simple format, defaults applied\n  measurements:\n    - name: \"msr_vel_reduction\" \n      separated: true\n      skip: false\n    - \"msr_added_turbulence\"  # Simple format, defaults applied\n\nFile Saving Behavior\n\nWhen save=true, plots are saved as PNG files with descriptive names:\n\nff_velocity_reduction.png - for velocity reduction plots (msr=VelReduction)\nff_added_turbulence.png - for turbulence intensity plots (msr=AddedTurbulence)  \nff_wind_speed.png - for effective wind speed plots (msr=EffWind)\nTime-stamped versions: ff_velocity_reduction_t0120s.png when time parameter is provided\n\nSave location depends on the online setting:\n\nonline=true: Files saved to video_path (for animations)\nonline=false: Files saved to output_path (for final results)\n\nPerformance Notes\n\nOnline visualization significantly slows down simulation performance\nUseful for debugging, monitoring simulation progress, or creating videos of the simulation\nWhen disabled, visualization functions are skipped to improve computational efficiency\nup_int can be used to reduce visualization frequency and improve simulation speed\nDirectory creation is automatic but occurs only when computed properties are accessed\nFlow fields and measurements with skip=true are ignored completely for optimal performance\n\nEnvironment Adaptation\n\nThe struct automatically adapts to different computing environments:\n\nDelft Blue supercomputer: Uses ~/scratch/ directory for ample storage space\nLocal systems: Uses current working directory (pwd())\nDetection is automatic via the isdelftblue() function\n\nSee Also\n\nFlowField: Configuration struct for flow field visualizations\nMeasurement: Configuration struct for measurement visualizations\nparse_flow_fields: Function to convert YAML flow field configurations\nparse_measurements: Function to convert YAML measurement configurations\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Floris","page":"Settings","title":"FLORIDyn.Floris","text":"Floris\n\nA mutable struct representing the settings for the FLORIDyn simulation. \n\nFields\n\nalpha::Float64: The alpha parameter for the FLORIS model.\nbeta::Float64: The beta parameter for the FLORIS model.\nk_a::Float64: The k_a parameter for the FLORIS model.\nk_b::Float64: The k_b parameter for the FLORIS model.\nk_fa::Float64: The k_fa parameter for the FLORIS model.\nk_fb::Float64: The k_fb parameter for the FLORIS model.\nk_fc::Float64: The k_fc parameter for the FLORIS model.\nk_fd::Float64: The k_fd parameter for the FLORIS model.\neta::Int: The eta parameter for the FLORIS model.\np_p::Float64: The p_p parameter for the FLORIS model.\nairDen::Float64: The air density for the FLORIS model.\nTIexp::Int: The turbulence intensity exponent for the FLORIS model.\nrotor_points::Union{Nothing, Int64}: Optional number of rotor points.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.FloriDyn","page":"Settings","title":"FLORIDyn.FloriDyn","text":"FloriDyn\n\nA structure representing the settings for the FLORIDyn simulation environment.\n\nFields\n\nn_op::Int: The number of operating points.\ndeltaUW::Float64: The delta U wind speed perturbation.\ndeltaDW::Float64: The delta D wind direction perturbation.\ndeltaCW::Float64: The delta C wind turbulence intensity perturbation.\ndynStateChange::String: The type of dynamic state change, e.g., \"Constant\", \"Interpolation\".\ntwf_model::String: The type of TWF (Turbine Wake Flow) model used, e.g., \"Gaussian\", \"FLORIDyn\".\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.TurbineArray","page":"Settings","title":"FLORIDyn.TurbineArray","text":"TurbineArray\n\nA structure representing the configuration and properties of a wind turbine array.\n\nFields\n\npos::Matrix{Float64}: A matrix containing the positions of turbines. Each row represents                         a turbine with columns for x, y, and z coordinates (in meters).\ntype::Vector{String}: A vector of strings specifying the type/model of each turbine.\ninit_States::Matrix{Float64}: A matrix containing the initial states of each turbine.                                 Each row represents a turbine with columns for:                                 - Column 1: a - axial induction factor                                 - Column 2: yaw - initial yaw angle (in degrees)                                 - Column 3: ti - turbulence intensity\n\nExample\n\n# Create a simple 2-turbine array\npos = [0.0 0.0 0.0; 500.0 0.0 0.0]  # Two turbines 500m apart\ntype = [\"NREL_5MW\", \"NREL_5MW\"]\ninit_states = [0.33 0.0 0.1; 0.33 0.0 0.1]  # Both start with same initial conditions\nturbines = TurbineArray(pos, type, init_states)\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.TurbineData","page":"Settings","title":"FLORIDyn.TurbineData","text":"TurbineData\n\nA structure containing technical specifications for wind turbines.\n\nFields\n\nnac_pos::Matrix{Float64}: An N × 3 matrix where each row corresponds to the (x, y, z)                              coordinates of the nacelle position for each turbine in meters.\nrotor_diameter::Vector{Float64}: A vector of rotor diameters corresponding to each turbine in meters.\n\nExample\n\n# Get turbine data for specific types\nnames = [\"DTU 10MW\", \"V116\", \"GE Haliade X\"]\nturbine_data = getTurbineData(names)\nprintln(\"First turbine nacelle height: \", turbine_data.nac_pos[1, 3], \" m\")\nprintln(\"First turbine rotor diameter: \", turbine_data.rotor_diameter[1], \" m\")\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.FlowField","page":"Settings","title":"FLORIDyn.FlowField","text":"FlowField\n\nStructure representing a single flow field visualization configuration.\n\nThis struct defines the configuration for individual flow field visualizations, including the flow field type, online visualization settings, video creation options, and skip control.\n\nFields\n\nname::String: The name/identifier of the flow field type (e.g., \"flow_field_vel_reduction\", \"flow_field_added_turbulence\", \"flow_field_eff_wind_speed\")\nonline::Bool: Whether the flow field should be displayed during online visualization (true)  or only saved offline (false). Default is false for offline-only processing.\ncreate_video::Bool: Whether to create a video from the flow field frames (true) or not (false). Default is false for no video creation.\nskip::Bool: Whether to skip processing of this flow field entirely (true) or process normally (false). Default is false for normal processing. When true, the flow field will be ignored completely.\n\nExamples\n\n# Velocity reduction flow field with online display and video creation\nvel_field = FlowField(\"flow_field_vel_reduction\", true, true)\n\n# Turbulence flow field with offline-only processing, no video\nturb_field = FlowField(\"flow_field_added_turbulence\", false, false)\n\n# Flow field that should be skipped entirely\nskipped_field = FlowField(\"flow_field_eff_wind_speed\", false, false, true)\n\n# Using keyword arguments\neff_field = FlowField(name=\"flow_field_eff_wind_speed\", online=false, create_video=true, skip=false)\n\nSee Also\n\nparse_flow_fields: Function to convert YAML flow field configurations to FlowField arrays\nplotFlowField: Function that uses these configurations for visualization\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Measurement","page":"Settings","title":"FLORIDyn.Measurement","text":"Measurement\n\nStructure representing a single measurement visualization configuration.\n\nThis struct defines the configuration for individual measurement visualizations, including the measurement type, whether it should be displayed in separated plots, and skip control.\n\nFields\n\nname::String: The name/identifier of the measurement type (e.g., \"msr_vel_reduction\", \"msr_added_turbulence\", \"msr_eff_wind_speed\")\nseparated::Bool: Whether the measurement should be plotted in separate individual plots (true)  or combined in a single plot (false). Default is false for combined plotting.\nskip::Bool: Whether to skip processing of this measurement entirely (true) or process normally (false). Default is false for normal processing. When true, the measurement will be ignored completely.\n\nExamples\n\n# Velocity reduction measurement with separated plots\nvel_measurement = Measurement(\"msr_vel_reduction\", true)\n\n# Turbulence measurement with combined plots  \nturb_measurement = Measurement(\"msr_added_turbulence\", false)\n\n# Measurement that should be skipped entirely\nskipped_measurement = Measurement(\"msr_eff_wind_speed\", false, true)\n\n# Using keyword arguments\neff_measurement = Measurement(name=\"msr_eff_wind_speed\", separated=false, skip=false)\n\nSee Also\n\nparse_measurements: Function to convert YAML measurement configurations to Measurement arrays\nplotMeasurements: Function that uses these configurations for visualization\n\n\n\n\n\n","category":"type"},{"location":"settings/#Settings","page":"Settings","title":"Settings","text":"","category":"section"},{"location":"settings/","page":"Settings","title":"Settings","text":"The Settings struct and functions related to examples and settings.","category":"page"},{"location":"settings/#FLORIDyn.install_examples","page":"Settings","title":"FLORIDyn.install_examples","text":"install_examples(add_packages=true)\n\nInstall example files, executables, and data files for the FLORIDyn.jl package.\n\nThis function sets up a complete working environment by copying:\n\nExample Julia scripts from the package's examples directory (via copy_examples)\nExecutable scripts (like run_julia) to a local bin directory (via copy_bin)\nModel configuration files and data to a local data directory (via copy_model_settings)\n\nArguments\n\nadd_packages::Bool=true: Whether to automatically install additional required packages  (\"LaTeXStrings\", \"Timers\") that are commonly used in the examples\n\nExample\n\n# Install examples with automatic package installation\ninstall_examples()\n\n# Install examples without installing additional packages\ninstall_examples(false)\n\nAfter running this function, you can:\n\nRun example scripts from the created examples/ directory\nExecute ./bin/run_julia to start Julia with the project environment\nAccess model data files in the data/ directory\n\nSee also: copy_examples, copy_bin, copy_model_settings\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.copy_examples","page":"Settings","title":"FLORIDyn.copy_examples","text":"copy_examples()\n\nCopy all example scripts to the folder \"examples\" (it will be created if it doesn't exist).\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.copy_model_settings","page":"Settings","title":"FLORIDyn.copy_model_settings","text":"copy_model_settings()\n\nCopy model configuration files and data directories to the local data directory.\n\nThis function copies essential model configuration files and simulation data from the package's  data directory to a local data/ directory in the current working directory. \n\nFiles and Directories Copied\n\nConfiguration File\n\n2021_9T_Data.yaml: Main wind farm configuration file containing turbine layout, simulation parameters,  and model settings\n\nData Directory\n\n2021_9T_Data/: Complete SOWFA simulation data directory containing:\nSOWFA_bladePitch.csv: Blade pitch angle time series\nSOWFA_generatorPower.csv: Generator power output data\nSOWFA_generatorTorque.csv: Generator torque measurements\nSOWFA_nacelleYaw.csv: Nacelle yaw angle data\nSOWFA_rotorSpeedFiltered.csv: Filtered rotor speed measurements\nU.csv, WindVel.csv: Wind velocity data\nWindDir.csv, WindDirConstant.csv: Wind direction measurements\nWindTI.csv, WindTIConstant.csv: Turbulence intensity data\nAdditional covariance and profile files\n\nAutomatic Operations\n\nThe function automatically:\n\nCreates the data/ directory if it doesn't exist\nCopies the main YAML configuration file using copy_files\nRecursively copies the entire 2021_9T_Data/ subdirectory with all CSV files\nSets proper file permissions (0o774) on all copied files\n\nThis function is called as part of install_examples to set up a complete  working environment with all necessary configuration files and simulation data.\n\nSee also: copy_files, install_examples\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.copy_bin","page":"Settings","title":"FLORIDyn.copy_bin","text":"copy_bin()\n\nCopy the script run_julia to the folder \"bin\" (it will be created if it doesn't exist).\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.copy_files","page":"Settings","title":"FLORIDyn.copy_files","text":"copy_files(relpath, files)\n\nCopy a list of files from the package directory to a local directory.\n\nThis utility function copies files from the package's source directory structure to  a corresponding local directory. It automatically handles directory creation and  sets appropriate file permissions.\n\nArguments\n\nrelpath::String: The relative path (directory name) within both the package and  local filesystem where files should be copied\nfiles::Vector{String}: A vector of filenames to copy from the source to destination\n\nDetails\n\nThe function:\n\nCreates the destination directory (relpath) if it doesn't exist\nCopies each file from <package_dir>/<relpath>/<file> to ./<relpath>/<file>\nSets executable permissions (0o774) on all copied files\nOverwrites existing files (uses force=true)\n\nReturns\n\nVector{String}: The list of files that were copied (same as input files)\n\nExample\n\n# Copy specific example files to local examples directory\ncopy_files(\"examples\", [\"main.jl\", \"menu.jl\"])\n\n# Copy data files to local data directory  \ncopy_files(\"data\", [\"config.yaml\", \"turbine_data.csv\"])\n\nThis function is used internally by copy_examples, copy_model_settings,  and other file copying utilities.\n\nSee also: copy_examples, copy_model_settings, copy_bin\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.setup","page":"Settings","title":"FLORIDyn.setup","text":"setup(filename) -> (wind, sim, con, floris, floridyn, ta)\n\nLoad wind farm configuration from a YAML file and parse all simulation components.\n\nThis function reads the configuration file of the simulation and extracts all necessary  parameters for setting up a FLORIDyn simulation, including wind conditions, simulation  settings, control strategies, FLORIS model parameters, FLORIDyn dynamics, and turbine  array layout.\n\nArguments\n\nfilename::String: Path to the YAML configuration file. The file should contain sections for: wind, sim, con, floris, floridyn, and turbines.\n\nReturns\n\nA 6-tuple containing fully configured simulation components:\n\nwind::Wind: Wind conditions and input specifications (velocity, direction, turbulence, shear, corrections, perturbations)\nsim::Sim: Simulation parameters (time range, discretization, dynamics, initialization, data paths)  \ncon::Con: Control settings (yaw strategies, control data)\nfloris::Floris: FLORIS wake model parameters (alpha, beta, k coefficients, air density, etc.)\nfloridyn::FloriDyn: FLORIDyn dynamic model settings (operating points, perturbations, state changes)\nta::TurbineArray: Turbine array configuration (positions, types, initial states)\n\nYAML File Structure\n\nThe configuration file must contain these top-level sections:\n\nwind:          # Wind input specifications and corrections\nsim:           # Simulation time, discretization, and dynamics  \ncon:           # Control strategies and yaw data\nfloris:        # FLORIS model coefficients and parameters\nfloridyn:      # FLORIDyn dynamic model settings\nturbines:      # Array of turbine definitions with position, type, initial states\n\nExample\n\n# Load complete wind farm configuration\nwind, sim, con, floris, floridyn, ta = setup(\"data/2021_9T_Data.yaml\")\n\n# Access turbine positions  \nprintln(\"Number of turbines: \", size(ta.pos, 1))\nprintln(\"Simulation duration: \", sim.end_time - sim.start_time, \" seconds\")\n\nSee Also\n\nWind: Wind conditions and input specifications\nSim: Simulation parameters and settings  \nCon: Control configuration\nFloris: FLORIS wake model parameters\nFloriDyn: FLORIDyn dynamic model settings\nTurbineArray: Turbine array layout and properties\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.Settings","page":"Settings","title":"FLORIDyn.Settings","text":"Settings\n\nA mutable struct that holds configuration parameters for the FLORIDyn simulation environment.\n\nFields\n\nvel_mode::VelModel: See: VelModel\ndir_mode::DirModel: See: DirModel\nturb_mode\nshear_mode\ncor_dir_mode\ncor_vel_mode\ncor_turb_mode\niterate_mode\ncontrol_mode\nparallel::Bool:  Run plotting in a separate process.\nthreading::Bool: Enable threading for parallel computation within a single process\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Settings-Tuple{Wind, Sim, Con}","page":"Settings","title":"FLORIDyn.Settings","text":"Settings(wind::Wind, sim::Sim, con::Con, parallel=false, threading=false)\n\nCreate and return a Settings object using the provided wind and sim parameters.\n\nArguments\n\nwind::Wind: An instance of the Wind struct containing wind-related parameters.\nsim::Sim: An instance of the Sim struct containing the simulation parameters.\ncon::Con: An instance of the Con struct containing the controller parameters.\nparallel::Bool:  Enable plotting in a separate process (default: false)\nthreading::Bool: Enable threading for parallel computation within a single process (default: false)\n\nReturns\n\nA Settings struct configured with the given wind and simulation parameters.\n\nNotes\n\nThe function uses the str2type helper to convert string representations of model types  into their corresponding Julia types.\nThe Settings struct encapsulates the model settings for velocity, direction,  turbulence intensity, shear, and correction modes.\n\n\n\n\n\n","category":"method"},{"location":"settings/#FLORIDyn.getTurbineData","page":"Settings","title":"FLORIDyn.getTurbineData","text":"getTurbineData(names::Vector{String}) -> TurbineData\n\nRetrieve nacelle positions and rotor diameters for a given list of wind turbine types.\n\nArguments\n\nnames::Vector{String}: A vector of wind turbine type names. Supported types are loaded from the data/turbine_specs.yaml file and currently include:\n\"DTU 10MW\"\n\"DTU 5MW\"\n\"Senvion 6.2M\"\n\"V116\"\n\"V117\"\n\"V162\"\n\"GE Haliade X\"\n\nReturns\n\nA TurbineData struct with the following fields:\nnac_pos::Matrix{Float64}: An N × 3 matrix where each row corresponds to the (x, y, z) coordinates of the nacelle position for each turbine.\nrotor_diameter::Vector{Float64}: A vector of rotor diameters corresponding to each turbine.\n\nRaises\n\nArgumentError if an unknown or misspelled turbine name is encountered.\n\nExample\n\nnames = [\"DTU 10MW\", \"V116\"]\nturbine_data = getTurbineData(names)\nprintln(\"Nacelle positions: \", turbine_data.nac_pos)\nprintln(\"Rotor diameters: \", turbine_data.rotor_diameter)\n\nData Source\n\nTurbine specifications are loaded from data/turbine_specs.yaml. To add new turbine types, add entries to this file following the existing format.\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.parse_measurements","page":"Settings","title":"FLORIDyn.parse_measurements","text":"parse_measurements(measurements_yaml::Vector) -> Vector{Measurement}\n\nConvert YAML measurement configurations into an array of Measurement structs.\n\nThis function parses the measurement section from a YAML visualization configuration and converts it into a structured array of Measurement objects. It handles both simple string entries and complex dictionary entries with name, separated, and skip flag specifications.\n\nArguments\n\nmeasurements_yaml::Vector: Vector containing measurement configurations from YAML. Each element can be either:\nA simple string (measurement name)\nA dictionary with \"name\", \"separated\", and \"skip\" keys\n\nReturns\n\nVector{Measurement}: Array of Measurement structs with parsed configurations\n\nYAML Format Support\n\nThe function supports multiple YAML formats:\n\nSimple Format (separated=false, skip=false by default)\n\nmeasurements:\n  - \"msr_vel_reduction\"\n  - \"msr_added_turbulence\" \n\nExtended Format (with separated and skip flags)\n\nmeasurements:\n  - name: \"msr_vel_reduction\"\n    separated: true\n    skip: false\n  - name: \"msr_added_turbulence\"\n    separated: false\n    skip: true\n\nMixed Format\n\nmeasurements:\n  - \"msr_vel_reduction\"           # Simple string, defaults applied\n  - name: \"msr_added_turbulence\"  # Dictionary format\n    separated: true\n    skip: false\n\nAlgorithm\n\nIterate through each measurement entry in the YAML vector\nCheck type: Determine if entry is string or dictionary\nExtract values: Get name, separated, and skip flags based on format\nCreate struct: Construct Measurement struct with parsed values\n\nError Handling\n\nHandles missing separated and skip flags by defaulting to false\nProcesses mixed simple/complex YAML structures gracefully\nValidates measurement name extraction\n\nExamples\n\n# Parse from YAML data\nyaml_measurements = [\n    \"msr_vel_reduction\",\n    Dict(\"name\" => \"msr_added_turbulence\", \"separated\" => true, \"skip\" => false)\n]\n\nmeasurements = parse_measurements(yaml_measurements)\n# Returns: [Measurement(\"msr_vel_reduction\", false, false), \n#          Measurement(\"msr_added_turbulence\", true, false)]\n\nSee Also\n\nMeasurement: The struct type created by this function\nVis: Visualization settings struct that uses these measurements\nplotMeasurements: Function that consumes these measurement configurations\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.parse_flow_fields","page":"Settings","title":"FLORIDyn.parse_flow_fields","text":"parse_flow_fields(flow_fields_yaml::Vector) -> Vector{FlowField}\n\nConvert YAML flow field configurations into an array of FlowField structs.\n\nThis function parses the flow_fields section from a YAML visualization configuration and converts it into a structured array of FlowField objects. It handles both simple string entries and complex dictionary entries with name, online, create_video, and skip flag specifications.\n\nArguments\n\nflow_fields_yaml::Vector: Vector containing flow field configurations from YAML. Each element can be either:\nA simple string (flow field name)\nA dictionary with \"name\", \"online\", \"create_video\", and \"skip\" keys\n\nReturns\n\nVector{FlowField}: Array of FlowField structs with parsed configurations\n\nYAML Format Support\n\nThe function supports multiple YAML formats:\n\nSimple Format (online=false, create_video=false, skip=false by default)\n\nflow_fields:\n  - \"flow_field_vel_reduction\"\n  - \"flow_field_added_turbulence\" \n\nExtended Format (with online, create_video, and skip flags)\n\nflow_fields:\n  - name: \"flow_field_vel_reduction\"\n    online: true\n    create_video: true\n    skip: false\n  - name: \"flow_field_added_turbulence\"\n    online: false\n    create_video: false\n    skip: true\n\nMixed Format\n\nflow_fields:\n  - \"flow_field_vel_reduction\"           # Simple string, defaults applied\n  - name: \"flow_field_added_turbulence\"  # Dictionary format\n    online: true\n    create_video: false\n    skip: false\n\nExamples\n\n# Parse from YAML data\nyaml_flow_fields = [\n    \"flow_field_vel_reduction\",\n    Dict(\"name\" => \"flow_field_added_turbulence\", \"online\" => true, \"create_video\" => false, \"skip\" => true)\n]\n\nflow_fields = parse_flow_fields(yaml_flow_fields)\n\nSee Also\n\nFlowField: The struct type created by this function\nparse_measurements: Similar function for measurement configurations\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#High-Level-Functions","page":"High-Level Functions","title":"High-Level Functions","text":"","category":"section"},{"location":"functions_II/#FLORIS","page":"High-Level Functions","title":"FLORIS","text":"","category":"section"},{"location":"functions_II/#FLORIDyn.calcCt","page":"High-Level Functions","title":"FLORIDyn.calcCt","text":"calcCt(a::Number, _) -> Float64\ncalcCt(a::AbstractVector, _) -> AbstractVector\n\nCalculate the thrust coefficient ct = 4a(1-a).\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.centerline!","page":"High-Level Functions","title":"FLORIDyn.centerline!","text":"centerline!(deflection::AbstractMatrix,\n            states_op, states_t, states_wf, floris::Floris, d_rotor)\n\nCompute the cross-wind wake deflection at the observation points in-place using the Gaussian wake model.\n\nThis function calculates the lateral (y) and vertical (z) deflection of the wake centerline  due to yaw misalignment and other effects. The results are written directly into the provided  deflection matrix without allocating temporary arrays.\n\nOutput Arguments\n\ndeflection::AbstractMatrix (size n×2): Wake deflection components filled in-place\nColumn 1: Lateral deflection Δy [m]  \nColumn 2: Vertical deflection Δz [m] (always zero in current implementation)\n\nInput Arguments\n\nstates_op::AbstractMatrix (size n×k): Observation point states where n is number of points\nColumn 4 contains downstream distance in wake-aligned coordinates [m]\nstates_t::AbstractMatrix: Turbine state matrix containing:\nColumn 1: Axial induction factor a [-]\nColumn 2: Yaw angle [degrees]\nColumn 3: Local turbulence intensity TI [-]\nstates_wf::AbstractMatrix: Wind field state matrix containing:\nColumn 3: Ambient turbulence intensity TI₀ [-]\nfloris::Floris: FLORIS model parameters for wake calculations (see Floris)\nd_rotor::Real: Rotor diameter D [m]\n\nNotes\n\nOnly states_op[:, 4] (downstream distance) is used from the observation points\nThe function internally converts yaw angles from degrees to radians with sign correction\nThrust coefficient is calculated from axial induction factor using calcCt\n\nSee also: getVars!\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.discretizeRotor","page":"High-Level Functions","title":"FLORIDyn.discretizeRotor","text":"discretizeRotor(n_rp::Int) -> Tuple{Matrix{Float64}, Vector{Float64}}\n\nDiscretizes the rotor into n_rp segments using the isocell algorithm.\n\nMemoization: results are cached per thread. Repeated calls with the same n_rp on the same thread reuse the cached arrays (no lock needed). Do not mutate the returned arrays, as they are shared within the thread.\n\nArguments\n\nn_rp::Int: The number of radial points to discretize the rotor into.\n\nReturns\n\n(m_rp, w) where:\nm_rp::Matrix{Float64}: Size (nC, 3); first column zeros, columns 2–3 are normalized coordinates in [-0.5, 0.5].\nw::Vector{Float64}: Weights per cell that sum to approximately 1.\n\nNotes\n\nPer-thread cache avoids contention; different threads may compute and hold their own cached copies for the same n_rp.\nThe isocell algorithm may not yield exactly n_rp cells but aims for a similar number.\nFor details, see: Masset et al. (2009) https://orbi.uliege.be/bitstream/2268/91953/1/massetisocellorbi.pdf\nThe choice N1 = 3 is used here; values of 4 or 5 are also viable.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.init_states","page":"High-Level Functions","title":"FLORIDyn.init_states","text":"init_states(set::Settings, wf::WindFarm, wind::Wind, init_turb, \n            floris::Floris, sim::Sim) -> Tuple{Matrix, Matrix, Matrix}\n\nInitialize the state arrays for wind farm simulation using the Gaussian wake model.\n\nThis function sets up the initial conditions for turbines, observation points, and wind field  states based on the provided configuration parameters. It computes initial positions, wind  conditions, and wake properties for each turbine in the wind farm.\n\nArguments\n\nset::Settings: Simulation settings containing configuration options for velocity, direction, and turbulence models\nwf::WindFarm: Wind farm object containing turbine positions, dimensions, and state arrays (see WindFarm)\nwind::Wind: Wind conditions including velocity, direction, and turbulence intensity data (see Wind)\ninit_turb: Initial turbine state parameters (axial induction factor, yaw angle, turbulence intensity)\nfloris::Floris: FLORIS model parameters for wake calculations (see Floris)\nsim::Sim: Simulation parameters including time step and start time (see Sim)\n\nReturns\n\nA tuple (states_op, states_t, states_wf) containing:\n\nstates_op::Matrix: Observation point states with 3D coordinates and wake positions\nstates_t::Matrix: Turbine states including control parameters and operational conditions  \nstates_wf::Matrix: Wind field states with velocity, direction, and turbulence data\n\nDescription\n\nThe function performs the following initialization steps for each turbine:\n\nRetrieves wind field data (velocity, direction, turbulence intensity) based on the specified input methods\nInitializes wind field states at all observation points for the turbine\nCalculates downwind distances for wake coordinate system\nSets initial turbine states from provided parameters\nComputes crosswind wake deflections using the centerline function\nTransforms coordinates from wake-relative to world coordinate system\nUpdates observation point positions including turbine base and nacelle offsets\n\nNotes\n\nSupports multiple wind input methods including interpolation, constant values, and random walk models\nHandles both 3D and 4D wind field configurations (with optional orientation data)\nUses SOWFA coordinate system conventions for angle transformations\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.getVars!","page":"High-Level Functions","title":"FLORIDyn.getVars!","text":"    getVars!(sig_y, sig_z, x_0, delta, pc_y, pc_z, rps, c_t, yaw, ti, ti0, floris::Floris, d_rotor)\n\nCompute Gaussian wake widths, deflection, potential-core radii, and onset distance at observation points, in-place.\n\nOutput Arguments\n\nsig_y::AbstractVector{<:Real} (length n): Lateral Gaussian width σ_y at each point [m]\nsig_z::AbstractVector{<:Real} (length n): Vertical Gaussian width σ_z at each point [m]\nx_0::AbstractVector{<:Real} (length n): Onset distance of the far-wake x₀ [m]\ndelta::AbstractMatrix{<:Real} (length n×2): Deflection components [Δy, Δz] [m]\npc_y::AbstractVector{<:Real} (length n): Potential-core radius in y at each point [m]\npc_z::AbstractVector{<:Real} (length n): Potential-core radius in z at each point [m]\n\nInput Arguments\n\nrps::AbstractMatrix (n×3): Observation points in wake-aligned frame; columns are [x_downstream, y_cross, z_cross] [m]\nc_t::Union{Number,AbstractVector}: Thrust coefficient Ct (scalar or length n) [-]\nyaw::Union{Number,AbstractVector}: Yaw misalignment (scalar or length n) [rad]\nti::Union{Number,AbstractVector}: Local turbulence intensity TI at turbine (scalar or length n) [-]\nti0::Union{Number,AbstractVector}: Ambient turbulence intensity TI₀ (scalar or length n) [-]\nfloris::Floris: FLORIS Gaussian model parameters; see Floris\nd_rotor::Real: Rotor diameter D [m]\n\nBehavior\n\nSupports scalar or per-point values for c_t, yaw, ti, ti0; scalars are broadcast to all points.\nUses floris.k_a, floris.k_b, floris.alpha, floris.beta to compute per-point   x₀, σ_y, σ_z, deflection Δy (here Δz is set to 0), and potential-core radii pc_y, pc_z.\nNo heap allocations beyond the provided outputs; results are written in-place and the function returns nothing.\n\nNotes\n\nOnly rps[:, 1] (downstream distance) is used by this implementation; rps[:, 2:3] are ignored.\ndelta must have at least 2 columns; only columns 1:2 are written.\nUnits: distances in meters, angles in radians, intensities and Ct are dimensionless.\n\nExample\n\nn = size(RPs, 1)\nsig_y = similar(RPs[:, 1])\nsig_z = similar(RPs[:, 1])\nx0    = similar(RPs[:, 1])\ndelta = zeros(n, 2)\npc_y  = similar(RPs[:, 1])\npc_z  = similar(RPs[:, 1])\ngetVars!(sig_y, sig_z, x0, delta, pc_y, pc_z, RPs, Ct, yaw, TI, TI0, floris, D)\n\nReturns\n\nnothing — all results are written into the provided arrays.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.getPower","page":"High-Level Functions","title":"FLORIDyn.getPower","text":"getPower(wf::WindFarm, m::AbstractMatrix, floris::Floris, con::Con)\n\nCalculate the power output of wind turbines in a wind farm simulation.\n\nThis function computes the power generated by wind turbines based on their operational states, wind conditions, and control settings. It accounts for yaw angle effects and optional yaw range constraints using hyperbolic tangent functions for smooth operational limits.\n\nArguments\n\nwf::WindFarm: Wind farm object containing turbine states, dimensions, and operational data with current axial induction factors and yaw angles (see WindFarm)\nm::Matrix: Measurement or simulation data matrix where column 3 contains effective wind speeds at turbine locations [m/s]\nfloris::Floris: FLORIS model parameters containing air density, drivetrain efficiency, and power curve parameters (see Floris)\ncon::Con: Controller configuration object with yaw control settings and operational constraints (see Con)\n\nReturns\n\nP::Vector{Float64}: Power output for each turbine in the wind farm [W]\n\nDescription\n\nThe function calculates power using the standard wind turbine power equation with yaw corrections:\n\nP = 0.5 × ρ × A × Cp × U³ × η × cos(γ)^p_p × f_yaw_constraints\n\nWhere:\n\nρ is air density [floris.airDen] [kg/m³]\nA is rotor swept area π × (D/2)² [m²]\nCp is power coefficient calculated as 4a(1-a)² [-]\nU is effective wind speed from column 3 of matrix m [m/s]\nη is drivetrain efficiency [floris.eta] [-]\nγ is yaw angle [rad]\np_p is yaw power exponent [floris.p_p] [-]\nf_yaw_constraints is optional yaw range constraint factor [-]\n\nThe yaw constraint factor is applied when con.tanh_yaw is true:\n\nf_yaw_constraints = [0.5 × tanh((γ_max - γ) × 50) + 0.5] × \n                           [-0.5 × tanh((γ_min - γ) × 50) + 0.5]\n\nNotes\n\nPower coefficient is calculated from axial induction factor: Cp = 4a(1-a)²\nYaw effects reduce power output according to cos(γ)^p_p where p_p is typically 1.88\nOptional yaw range constraints use hyperbolic tangent functions with slope factor 50 for smooth transitions\nWhen con.tanh_yaw is enabled, power is smoothly constrained within [con.yawRangeMin, con.yawRangeMax]\nThe constraint functions approach step functions but provide smooth gradients for optimization\nAxial induction factors are extracted from wf.States_T[wf.StartI, 1] for current time step\nYaw angles are converted from degrees to radians internally\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.runFLORIS!","page":"High-Level Functions","title":"FLORIDyn.runFLORIS!","text":"runFLORIS!(buffers::FLORISBuffers, set::Settings, location_t, states_wf, states_t, d_rotor, \n           floris, windshear::Union{Matrix, WindShear})\n\nExecute the FLORIS (FLOw Redirection and Induction in Steady State) wake model simulation for wind farm analysis.\n\nThis is the main orchestrating function that coordinates the FLORIS wake model execution through  a series of specialized sub-functions. It performs wake analysis using the Gaussian wake model to  calculate velocity reductions, turbulence intensity additions, and effective wind speeds at turbine  locations, accounting for wake interactions, rotor discretization, wind shear effects, and turbulence propagation.\n\nArguments\n\nbuffers::FLORISBuffers: Pre-allocated buffer arrays for computation and output storage (see FLORISBuffers)\nset::Settings: Simulation settings containing configuration options for wind shear modeling\nlocation_t: Matrix of turbine positions [x, y, z] coordinates for each turbine [m]\nstates_wf: Wind field state matrix containing velocity, direction, and turbulence data\nstates_t: Turbine state matrix with axial induction factors, yaw angles, and turbulence intensities\nd_rotor: Vector of rotor diameters for each turbine [m]\nfloris: FLORIS model parameters containing wake model coefficients and rotor discretization settings (see Floris)\nwindshear: Wind shear profile data for vertical wind speed variation modeling, either a matrix or of type WindShear\n\nReturns\n\nnothing. Results are written into fields of buffers:\nbuffers.T_red_arr: Velocity reduction factors for each turbine\nbuffers.T_aTI_arr: Added turbulence intensity values\nbuffers.T_Ueff: Effective wind speeds  \nbuffers.T_weight: Wake weighting factors\n\nImplementation Structure\n\nThe function is implemented as a high-level orchestrator that calls specialized sub-functions:\n\nprepare_rotor_points!: Handles rotor discretization, scaling, rotation, and translation\nhandle_single_turbine!: Optimized path for single turbine simulations (wind shear only)\nsetup_computation_buffers!: Initializes and configures computation buffers and views\ncompute_wake_effects!: Core wake computation loop for each upstream turbine\ncompute_final_wind_shear!: Final wind shear and effective wind speed calculation\n\nComputational Process\n\nSingle Turbine Case\n\nFor single turbine simulations, the function uses an optimized path that only calculates  wind shear effects without wake interactions, providing significant performance benefits.\n\nMulti-Turbine Wake Analysis\n\nFor multi-turbine wind farms, the function performs:\n\nRotor Point Preparation\n\nDiscretizes rotor planes using the isocell algorithm\nApplies yaw rotation transformations and coordinate translations\nHandles both active turbines (d_rotor > 0) and placeholder turbines\n\nWake Interaction Calculations\n\nFor each upstream turbine affecting downstream turbines:\n\nCoordinate Transformations: Aligns coordinates with wind direction and turbine yaw\nWake Variable Calculations: Computes wake expansion, deflection, and potential core dimensions\nVelocity Deficit Modeling: Applies Gaussian wake theory with yaw corrections\nTurbulence Enhancement: Calculates added turbulence using empirical correlations\nSuperposition: Combines effects from multiple upstream turbines\n\nFinal Integration\n\nApplies vertical wind shear corrections to the downstream turbine\nCombines all wake effects with wind shear for final effective wind speed\n\nMathematical Models\n\nThe function implements state-of-the-art wake modeling based on:\n\nGaussian Wake Theory: For velocity deficit calculations with yaw corrections\nAnalytical Deflection Models: For wake steering in yawed conditions\nEmpirical Turbulence Models: For wake-added turbulence intensity\nLinear Superposition: For combining multiple wake interactions\n\nPerformance Characteristics\n\nComputational Complexity: O(N²) for N turbines due to wake interactions\nMemory Efficiency: Uses pre-allocated buffers to avoid runtime allocations\nOptimization: Single turbine case bypasses multi-turbine calculations\nVectorization: Leverages SIMD operations where possible\n\nNotes\n\nUses SOWFA (Simulator for Offshore Wind Farm Applications) coordinate conventions\nSupports both research and engineering applications for wind farm optimization\nRequires proper initialization of turbine states and wind field conditions\nBuffer sizes must be compatible with rotor discretization settings\n\nReferences\n\nBastankhah, M. and Porté-Agel, F. (2016). Experimental and theoretical study of wind turbine wakes in yawed conditions\nNiayifar, A. and Porté-Agel, F. (2016). Analytical modeling of wind farms: A new approach for power prediction\n\nSee Also\n\nprepare_rotor_points!: Rotor point preparation and transformation\nhandle_single_turbine!: Single turbine optimization path\nsetup_computation_buffers!: Buffer initialization and setup\ncompute_wake_effects!: Core wake interaction calculations\ncompute_final_wind_shear!: Final wind shear integration\nFLORISBuffers: Buffer structure documentation\nFloris: FLORIS model parameters\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.prepare_rotor_points!","page":"High-Level Functions","title":"FLORIDyn.prepare_rotor_points!","text":"prepare_rotor_points!(buffers::FLORISBuffers, location_t, states_t, d_rotor, floris::Floris)\n\nPrepare rotor discretization points with scaling, rotation, and translation for the last turbine.\n\nThis function handles the rotor point discretization, scales them by the rotor diameter, applies yaw rotation, and translates them to the turbine location. The results are stored in the buffers to avoid allocations.\n\nArguments\n\nbuffers::FLORISBuffers: Pre-allocated computation buffers\nlocation_t: Turbine locations matrix\nstates_t: Turbine states matrix (includes yaw angles)\nd_rotor: Rotor diameter array\nfloris::Floris: FLORIS model parameters\n\nReturns\n\nRPl: View of transformed rotor points\nRPw: Rotor point weights\n\nNote\n\nThis function is private and intended for internal use only.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.handle_single_turbine!","page":"High-Level Functions","title":"FLORIDyn.handle_single_turbine!","text":"handle_single_turbine!(buffers::FLORISBuffers, RPl, RPw, location_t, set::Settings, windshear, d_rotor)\n\nHandle the special case when there is only one turbine in the simulation.\n\nThis function computes the wind shear reduction for a single turbine case and populates the appropriate buffer arrays. It returns early to avoid the multi-turbine wake calculations.\n\nArguments\n\nbuffers::FLORISBuffers: Pre-allocated computation buffers\nRPl: Rotor discretization points\nRPw: Rotor point weights\nlocation_t: Turbine locations matrix\nset::Settings: Simulation settings\nwindshear: Wind shear data\nd_rotor: Rotor diameter array\n\nReturns\n\nnothing (results stored in buffers)\n\nNote\n\nThis function is private and intended for internal use only.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.setup_computation_buffers!","page":"High-Level Functions","title":"FLORIDyn.setup_computation_buffers!","text":"setup_computation_buffers!(buffers::FLORISBuffers, nRP::Int, nT::Int)\n\nInitialize and setup computation buffers for multi-turbine wake calculations.\n\nThis function resizes output arrays and creates views of pre-allocated buffers to match the current rotor discretization size. It ensures all buffers are properly sized before the main computation loop.\n\nArguments\n\nbuffers::FLORISBuffers: Pre-allocated computation buffers\nnRP::Int: Number of rotor points\nnT::Int: Number of turbines\n\nReturns\n\nTuple of buffer views for use in wake calculations\n\nNote\n\nThis function is private and intended for internal use only.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.compute_wake_effects!","page":"High-Level Functions","title":"FLORIDyn.compute_wake_effects!","text":"compute_wake_effects!(buffers::FLORISBuffers, views, iT::Int, RPl, RPw, location_t, \n                     states_wf, states_t, d_rotor, floris::Floris, nRP::Int)\n\nCompute wake effects for a single upstream turbine on the downstream turbine.\n\nThis function calculates the velocity deficit and added turbulence caused by turbine iT on the last turbine in the array. It handles coordinate transformations, wake variable calculations, and Gaussian wake modeling.\n\nArguments\n\nbuffers::FLORISBuffers: Pre-allocated computation buffers\nviews: Tuple of buffer views from setupcomputationbuffers!\niT::Int: Index of the upstream turbine\nRPl: Rotor discretization points\nRPw: Rotor point weights\nlocation_t: Turbine locations matrix\nstates_wf: Wind farm states matrix\nstates_t: Turbine states matrix\nd_rotor: Rotor diameter array\nfloris::Floris: FLORIS model parameters\nnRP::Int: Number of rotor points\n\nReturns\n\nnothing. Results are written into fields of buffers:\nbuffers.T_red_arr: Velocity reduction factors for each turbine\nbuffers.T_aTI_arr: Added turbulence intensity values\nbuffers.T_Ueff: Effective wind speeds\nbuffers.T_weight: Wake weighting factors\n\nNote\n\nThis function is private and intended for internal use only.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.compute_final_wind_shear!","page":"High-Level Functions","title":"FLORIDyn.compute_final_wind_shear!","text":"compute_final_wind_shear!(buffers::FLORISBuffers, RPl, RPw, location_t, set::Settings, \n                         windshear, tmp_RPs_r, states_wf)\n\nCompute final wind shear effects and effective wind speed for the last turbine.\n\nThis function calculates the wind shear reduction for the downstream turbine and computes the final effective wind speed by combining all wake effects and wind shear.\n\nArguments\n\nbuffers::FLORISBuffers: Pre-allocated computation buffers\nRPl: Rotor discretization points\nRPw: Rotor point weights\nlocation_t: Turbine locations matrix\nset::Settings: Simulation settings\nwindshear: Wind shear data\ntmp_RPs_r: Temporary buffer for rotor point calculations\nstates_wf: Wind farm states matrix\n\nReturns\n\nnothing. Results are written into fields of buffers:\nbuffers.T_red_arr: Velocity reduction factors for each turbine\nbuffers.T_aTI_arr: Added turbulence intensity values\nbuffers.T_Ueff: Effective wind speeds\nbuffers.T_weight: Wake weighting factors\n\nNote\n\nThis function is private and intended for internal use only.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn","page":"High-Level Functions","title":"FLORIDyn","text":"","category":"section"},{"location":"functions_II/#FLORIDyn.initSimulation","page":"High-Level Functions","title":"FLORIDyn.initSimulation","text":"initSimulation(wf::Union{Nothing, WindFarm}, sim::Sim) -> Union{Nothing, WindFarm}\n\nInitialize or load a wind farm simulation state based on simulation settings.\n\nThis function handles the initialization phase of a wind farm simulation by either saving  the current initialized state to disk or loading a previously saved state, depending on  the simulation configuration.\n\nArguments\n\nwf::Union{Nothing, WindFarm}: Wind farm object containing the initialized simulation state, or Nothing if no state is available. See WindFarm\nsim::Sim: Simulation configuration object containing initialization settings and file paths. See Sim\n\nReturns\n\nwf::Union{Nothing, WindFarm}: The wind farm state, either the original input state (for \"init\" mode) or a loaded state from disk (for \"load\" mode)\n\nBehavior\n\nThe function operates in two modes based on sim.init:\n\n\"init\" Mode\n\nUses the provided wind farm state as-is\nIf sim.save_init_state is true, saves the current state to \"T_init.jld2\" in the specified data directory\nLogs the save operation for user feedback\n\n\"load\" Mode\n\nAttempts to load a previously saved wind farm state from \"T_init.jld2\"\nFalls back to the provided state if loading fails (with warning)\nHandles file I/O errors gracefully\n\nFile Operations\n\nSave path: $(sim.path_to_data)/T_init.jld2\nFormat: JLD2 binary format for efficient Julia object serialization\nError handling: Loading failures produce warnings but do not halt execution\n\nNotes\n\nThe function is case-insensitive for the initialization mode string\nFile operations use the path specified in sim.path_to_data\nLoading errors are caught and logged as warnings, allowing simulation to proceed with the original state\nThis mechanism enables reproducible simulations by preserving and reusing initial conditions\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.findTurbineGroups","page":"High-Level Functions","title":"FLORIDyn.findTurbineGroups","text":"findTurbineGroups(wf::WindFarm, floridyn::FloriDyn) -> Vector{Vector{Int64}}\n\nDetermine wake interaction dependencies between turbines in a wind farm.\n\nThis function analyzes the spatial relationships between turbines to identify which turbines  are affected by the wakes of upstream turbines. It uses coordinate transformations to the  wind-aligned reference frame and geometric criteria to determine wake interactions.\n\nArguments\n\nwf::WindFarm: Wind farm object containing turbine positions, observation points, and wind field states. See WindFarm\nfloridyn::FloriDyn: FLORIDyn model parameters containing wake interaction thresholds. See FloriDyn\n\nReturns\n\nvv_dep::Vector{Vector{Int64}}: A vector of vectors where vv_dep[i] contains the indices of all turbines  that affect turbine i through wake interactions. Each inner vector lists the upstream turbine indices  that influence the wake conditions at the corresponding turbine.\n\nAlgorithm\n\nCoordinate Transformation: For each turbine pair, transforms coordinates to a wind-aligned frame using the closest observation point\nWake Zone Detection: Applies geometric criteria to determine if a downstream turbine lies within the wake zone:\nUpstream extent: r₁[1] ≥ -uw × D[iT] (allowing for slight upstream influence)\nDownstream extent: r₁[1] ≤ dw × D[iT] (wake extends downstream)  \nLateral extent: |r₁[2]| ≤ cw × D[iT] (wake width constraint)\nDependency Matrix: Constructs a boolean dependency matrix and extracts indices for each turbine\n\nMathematical Description\n\nThe wake interaction criteria are evaluated in the wind-aligned coordinate system:\n\nr₁ = R(φ) × (rₒₚ - rₜᵤᵣᵦ)\n\nwhere:\n\nR(φ) is the rotation matrix for wind direction angle φ\nrₒₚ is the position of the closest observation point from the upstream turbine\nrₜᵤᵣᵦ is the position of the downstream turbine being evaluated\n\nNotes\n\nThe function uses the closest observation point from each upstream turbine to determine wind direction\nWake zones are defined as multiples of rotor diameter using the FLORIDyn parameters\nSelf-interaction (turbine affecting itself) is explicitly excluded\nThe coordinate transformation accounts for the SOWFA wind direction convention\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.prepareSimulation","page":"High-Level Functions","title":"FLORIDyn.prepareSimulation","text":"prepareSimulation(set::Settings, wind::Wind, con::Con, floridyn::FloriDyn, \n                  floris::Floris, turbProp, sim::Sim) -> (WindFarm, Wind, Sim, Con, Floris)\n\nPrepares the simulation environment for a wind farm analysis using the provided settings and parameters.\n\nArguments\n\nset::Settings: Simulation settings containing configuration options.\nwind::Wind: Wind conditions or wind field data. See: Wind \ncon::Con: Controller parameters of the turbines.  See: Con\nfloridyn::FloriDyn: Parameters specific to the FLORIDyn model. See: FloriDyn\nfloris::Floris: Parameters specific to the FLORIS model. See: Floris\nturbProp: Properties of the turbines involved in the simulation.\nsim::Sim: Simulation-specific parameters or state. See: Sim\n\nArguments that get modified\n\nwind: Updated with wind velocity, direction, turbulence intensity, and shear profile.\ncon: Updated with yaw data.\nsim: Updated with the number of simulation steps.\nfloris: May include additional parameters for the FLORIS model.\n\nReturns\n\nReturns the tuple (wf, wind, sim, con, floris) where:\nwf: Wind farm struct containing turbine states and positions. See: WindFarm\nwind: Updated wind conditions.\nsim: Updated simulation parameters.\ncon: Updated controller parameters.\nfloris: Parameters for the FLORIS model.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.perturbationOfTheWF!","page":"High-Level Functions","title":"FLORIDyn.perturbationOfTheWF!","text":"perturbationOfTheWF!(wf::WindFarm, wind::Wind) -> Nothing\n\nApply stochastic perturbations to the wind field states in-place.\n\nThis function adds Gaussian noise to the wind field parameters to model measurement  uncertainty or natural variability in wind conditions. The perturbations are applied  conditionally based on the wind perturbation configuration and are added directly  to the wind farm state matrix.\n\nInput/ Output Arguments\n\nwf::WindFarm: Wind farm struct containing the state matrix States_WF to be perturbed\n\nInput Arguments\n\nwind::Wind: Wind configuration struct containing perturbation settings. See Wind\n\nReturns\n\nnothing: The function modifies the wind farm state in-place\n\nBehavior\n\nThe function applies independent Gaussian perturbations to three wind field parameters:\n\nVelocity Perturbation\n\nCondition: wind.perturbation.vel == true\nTarget: Column 1 of wf.States_WF (wind velocity [m/s])\nNoise: wind.perturbation.vel_sigma * randn(nOP × nT)\n\nDirection Perturbation\n\nCondition: wind.perturbation.dir == true\nTarget: Column 2 of wf.States_WF (wind direction [degrees])\nNoise: wind.perturbation.dir_sigma * randn(nOP × nT)\n\nTurbulence Intensity Perturbation\n\nCondition: wind.perturbation.ti == true  \nTarget: Column 3 of wf.States_WF (turbulence intensity [-])\nNoise: wind.perturbation.ti_sigma * randn(nOP × nT)\n\nMathematical Description\n\nFor each enabled perturbation type, the function applies:\n\nStates_WF[:, col] += σ × N(0,1)\n\nwhere:\n\nσ is the standard deviation for the specific parameter\nN(0,1) is standard normal random noise with dimensions (nOP × nT)\nnOP is the number of observation points per turbine\nnT is the total number of turbines\n\nNotes\n\nThe function uses in-place modification (indicated by the ! suffix)\nPerturbations are applied independently to each observation point and turbine\nThe random noise follows a standard normal distribution scaled by the respective sigma values\nOnly enabled perturbation types (based on boolean flags) are applied\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.setUpTmpWFAndRun!","page":"High-Level Functions","title":"FLORIDyn.setUpTmpWFAndRun!","text":"setUpTmpWFAndRun!(ub::UnifiedBuffers, wf::WindFarm, set::Settings, floris::Floris, \n                  wind::Wind) -> Nothing\n\nNon-allocating version that uses a unified buffer struct for wind farm calculations.\n\nThis function performs wind farm wake calculations while avoiding memory allocations by reusing pre-allocated buffer arrays from a UnifiedBuffers struct. This is particularly  important for parallel execution and performance-critical loops where garbage collection overhead  needs to be minimized.\n\nBuffer Arguments\n\nub::UnifiedBuffers: Unified buffer struct containing all pre-allocated arrays\nub.M_buffer: Pre-allocated buffer for results matrix (size: nT × 3)\nub.iTWFState_buffer: Buffer for turbine wind field state\nub.tmp_Tpos_buffer: Buffer for temporary turbine positions\nub.tmp_WF_buffer: Buffer for temporary wind field states\nub.tmp_Tst_buffer: Buffer for temporary turbine states\nub.dists_buffer: Buffer for distance calculations\nub.plot_WF_buffer: Buffer for plotting wind field data\nub.plot_OP_buffer: Buffer for plotting operating point data\n\nOutput Arguments\n\nub.M_buffer: Pre-allocated buffer for results matrix (size: nT × 3)\nwf.Weight: Sets wake weight factors for each turbine from FLORIS calculations\nwf.red_arr: Updates wake reduction factors between turbines (wake interference matrix)\n\nInput/ Output Arguments\n\nwf::WindFarm: Wind farm object containing turbine data\n\nInput Arguments\n\nset::Settings: Settings object containing simulation parameters\nfloris::Floris: FLORIS model parameters for wake calculations\nwind::Wind: Wind field configuration\n\nReturns\n\nnothing: The function modifies ub.M_buffer, wf.Weight, and wf.red_arr in-place,  storing the results of the wind farm calculations\n\nPerformance Notes\n\nUses in-place operations to minimize memory allocations\nBuffers must be pre-sized correctly for the specific wind farm configuration\nThread-safe when each thread uses its own set of buffers\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.interpolateOPs!","page":"High-Level Functions","title":"FLORIDyn.interpolateOPs!","text":"interpolateOPs!(unified_buffers::UnifiedBuffers, intOPs::Vector{Matrix{Float64}}, \n                wf::WindFarm) -> Nothing\n\nCompute interpolation weights and indices for observation points affecting each turbine using a unified buffer.\n\nThis function performs interpolation calculations while avoiding  memory allocations by reusing pre-allocated buffer arrays from a unified buffer struct.  This is critical for performance when called repeatedly in loops, such as in flow field calculations.\n\nBuffer Arguments\n\nunified_buffers::UnifiedBuffers: Unified buffer struct containing pre-allocated arrays including:\ndist_buffer: Buffer for distance calculations (length ≥ wf.nOP)\nsorted_indices_buffer: Buffer for sorting indices (length ≥ wf.nOP)\n\nOutput Arguments\n\nintOPs::Vector{Matrix{Float64}}: Pre-allocated vector of matrices to store interpolation results\n\nInput Arguments\n\nwf::WindFarm: Wind farm object containing turbine positions and observation point data\n\nReturns\n\nnothing: The function modifies intOPs in-place, storing the interpolation results for each turbine\n\nExample\n\n# Create unified buffers\nunified_buffers = create_unified_buffers(wf)\n\n# Pre-allocate interpolation matrices\nintOPs = [zeros(length(wf.dep[iT]), 4) for iT in 1:wf.nT]\n\n# Non-allocating interpolation\ninterpolateOPs!(unified_buffers, intOPs, wf)\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.iterateOPs!","page":"High-Level Functions","title":"FLORIDyn.iterateOPs!","text":"iterateOPs!(iterate_mode::IterateOPs_model, wf::WindFarm, sim::Sim, floris::Floris, \n            floridyn::FloriDyn, buffers::IterateOPsBuffers) -> Nothing\n\nAdvance observation points through the wind field using the specified iteration strategy.\n\nThis function family implements different algorithms for moving observation points (OPs)  through space and time, which is essential for accurate wake propagation modeling in  wind farm simulations. The choice of iteration method affects computational efficiency,  numerical stability, and physical accuracy.\n\nSummary\n\nThe function modifies the following WindFarm fields:\n\nwf.States_OP: Updates observation point positions and states through temporal advancement\nwf.States_T: Updates turbine states through circular shifting and temporal evolution  \nwf.States_WF: Updates wind field states through circular shifting and temporal evolution\n\nInput/ Output Arguments\n\nwf::WindFarm: Wind farm object containing turbine and observation point data\n\nInput Arguments\n\niterate_mode::IterateOPs_model: Iteration strategy (e.g., IterateOPs_basic, IterateOPs_average)\nsim::Sim: Simulation configuration with time-stepping parameters\nfloris::Floris: FLORIS model parameters for wake calculations\nfloridyn::FloriDyn: FLORIDyn model parameters for wake dynamics\nbuffers::IterateOPsBuffers: Pre-allocated buffers for allocation-free execution\n\nAlgorithm Overview\n\nState Preservation: Save initial turbine observation point states\nDownwind Advection: Move OPs downstream based on local wind velocity\nCrosswind Deflection: Apply wake-induced lateral deflection using centerline calculations\nCoordinate Transformation: Convert to world coordinates using wind direction\nTemporal Advancement: Perform circular shifting to advance time steps\nSpatial Reordering: Maintain downstream position ordering of observation points\n\nAvailable Methods\n\niterateOPs!(::IterateOPs_basic, ...): Basic time-stepping with simple advection\n\nNotes\n\nDifferent iteration strategies provide trade-offs between accuracy and computational cost\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.angSOWFA2world","page":"High-Level Functions","title":"FLORIDyn.angSOWFA2world","text":"angSOWFA2world(deg_SOWFA) -> Float64\n\nConvert wind direction angle from SOWFA convention to world coordinate system.\n\nThis function performs coordinate transformation between different wind direction conventions used in wind farm simulations. SOWFA (Simulator fOr Wind Farm Applications) uses a different angular reference system than the standard world coordinate system used in calculations.\n\nArguments\n\ndeg_SOWFA::Real: Wind direction angle in SOWFA convention [degrees]\n\nReturns\n\nrad_World: Wind direction angle in world coordinate system [radians]\n\nCoordinate System Conversion\n\nThe transformation follows the relationship:\n\nθ_world = 270° - θ_SOWFA\n\nSOWFA Convention\n\nWind direction angles are defined clockwise from a reference direction\n\nWorld Convention\n\nWind direction angles are defined counterclockwise for mathematical calculations\nStandard convention used in wake models and analytical computations\n\nMathematical Description\n\nThe conversion process:\n\nAngular transformation: deg_World = 270 - deg_SOWFA\nUnit conversion: rad_World = deg2rad(deg_World)\n\nThe 270° offset accounts for the difference between clockwise (SOWFA) and  counterclockwise (world) angular conventions.\n\nExamples\n\n# Convert 90° SOWFA direction to world coordinates\nworld_angle = angSOWFA2world(90.0)  # Returns 3.141592... (180° in radians)\n\n# Convert 0° SOWFA direction  \nworld_angle = angSOWFA2world(0.0)   # Returns 4.712388... (270° in radians)\n\nNotes\n\nThe function handles the sign convention difference between coordinate systems\nOutput is always in radians for use in trigonometric calculations\nThis transformation is essential for proper wake modeling in wind farm simulations\nThe 270° offset ensures proper alignment between SOWFA and mathematical conventions\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.runFLORIDyn","page":"High-Level Functions","title":"FLORIDyn.runFLORIDyn","text":"runFLORIDyn(plt, set::Settings, wf::WindFarm, wind::Wind, sim, con, vis, floridyn, floris;\n            rmt_plot_fn=nothing, msr=VelReduction) -> (WindFarm, DataFrame, Matrix)\n\nMain entry point for the FLORIDyn closed-loop simulation.\n\nArguments\n\nplt: Plot object for live visualization during simulation\nset::Settings: Simulation settings and configuration parameters.\nwf::WindFarm: See: WindFarm simulation state, including turbine and wind farm states.\nwind::Wind: See: Wind field settings.\nsim::Sim: Simulation state or configuration object. See: Sim\ncon::Con: Controller object or control parameters. See: Con\nvis::Vis: Visualization settings controlling online plotting and animation. See: Vis\nfloridyn::FloriDyn: Parameters specific to the FLORIDyn model. See: FloriDyn\nfloris::Floris: Parameters specific to the FLORIS model. See: Floris\n\nKeyword Arguments\n\nrmt_plot_fn: Optional remote plotting function for intermediate simulation results. When provided, this function  is called remotely (using @spawnat 2) to plot flow field visualization on a separate worker process. The function should accept parameters (wf, X, Y, Z, vis, t_rel; msr=VelReduction) where wf is the wind farm state, X, Y, Z are flow field coordinates and velocities, vis contains visualization settings, and t_rel  is the relative simulation time. Defaults to nothing for local plotting.\nmsr: Measurement type for velocity reduction calculations. Defaults to VelReduction.\n\nReturns\n\nA tuple (wf, md, mi) containing:\n\nwf::WindFarm: Updated simulation state with final turbine positions, wind field states, and observation point data\nmd::DataFrame: Measurement data with columns:\n:Time: Simulation time steps\n:ForeignReduction: Wind speed reduction factors (%) due to wake effects from other turbines\n:AddedTurbulence: Additional turbulence intensity (%) induced by upstream turbines\n:EffWindSpeed: Effective wind speed (m/s) at each turbine after wake effects\n:FreeWindSpeed: Free-stream wind speed (m/s) without wake interference\n:PowerGen: Generated electrical power (MW) for each turbine\nmi::Matrix: Interaction matrix combining time data with turbine-to-turbine wake interaction coefficients                for each simulation step\n\nDescription\n\nRuns a closed-loop wind farm simulation using the FLORIDyn and FLORIS models,  applying control strategies and updating turbine states over time.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.run_floridyn","page":"High-Level Functions","title":"FLORIDyn.run_floridyn","text":"run_floridyn(plt, set, wf, wind, sim, con, vis, \n             floridyn, floris; msr=VelReduction) -> (WindFarm, DataFrame, Matrix)\n\nUnified function that automatically handles both multi-threading and single-threading modes for running FLORIDyn simulations with appropriate plotting callbacks.\n\nArguments\n\nplt: PyPlot instance, usually provided by ControlPlots\nset: Settings object. See: Settings\nwf: WindFarm struct. These are work arrays, not persistent objects. See: WindFarm\nwind: Wind field input settings. See: Wind\nsim: Simulation settings. See: Sim\ncon: Controller settings. See: Con\nvis: Visualization settings. See: Vis\nfloridyn: FLORIDyn model struct. See: FloriDyn\nfloris: Floris model struct. See: Floris\nmsr: Measurement index for online flow field plotting (VelReduction, AddedTurbulence or EffWind).         Default VelReduction. See: MSR\n\nReturns\n\nTuple (wf, md, mi): WindFarm, measurement data, and interaction matrix\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#Visualization","page":"High-Level Functions","title":"Visualization","text":"","category":"section"},{"location":"functions_II/#FLORIDyn.create_thread_buffers","page":"High-Level Functions","title":"FLORIDyn.create_thread_buffers","text":"create_thread_buffers(wf::WindFarm, nth::Int, floris::Floris) -> ThreadBuffers\n\nCreate thread-local buffers for parallel flow field computation with FLORIS parameters.\n\nThis function pre-allocates all necessary data structures for each thread to avoid race conditions and memory allocations during the parallel computation loop.\n\nArguments\n\nwf::WindFarm: Original wind farm object to use as template\nnth::Int: Number of threads to create buffers for\nfloris::Floris: FLORIS parameters for creating proper FLORIS buffers\n\nReturns\n\nThreadBuffers: Struct containing all thread-local buffers\n\nPerformance Notes\n\nEach thread gets its own copy of the WindFarm structure\nPre-allocates all arrays to minimize allocations during computation\nSets up dependency structure for virtual turbines at grid points\n\n\n\n\n\ncreate_thread_buffers(wf::WindFarm, nth::Int) -> ThreadBuffers\n\nCreate thread-local buffers for parallel flow field computation.\n\nThis function pre-allocates all necessary data structures for each thread to avoid race conditions and memory allocations during the parallel computation loop.\n\nArguments\n\nwf::WindFarm: Original wind farm object to use as template\nnth::Int: Number of threads to create buffers for\n\nReturns\n\nThreadBuffers: Struct containing all thread-local buffers\n\nPerformance Notes\n\nEach thread gets its own copy of the WindFarm structure\nPre-allocates all arrays to minimize allocations during computation\nSets up dependency structure for virtual turbines at grid points\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.getMeasurements","page":"High-Level Functions","title":"FLORIDyn.getMeasurements","text":"getMeasurements(buffers::ThreadBuffers, mx::Matrix, my::Matrix, nM::Int, zh::Real,\n                wf::WindFarm, set::Settings, floris::Floris, wind::Wind) -> Array{Float64,3}\n\nCalculate flow field measurements at specified grid points by treating them as virtual turbines.\n\nThis function computes flow field properties (velocity reduction, added turbulence, effective wind speed) at grid points by creating virtual turbines at each location and running the FLORIS wake model. Each grid point is treated as a turbine that depends on all real turbines in the wind farm, allowing wake effects to be captured in the flow field visualization.\n\nArguments\n\nbuffers::ThreadBuffers: Pre-allocated thread-local buffers created with create_thread_buffers;   for Julia 1.12 use create_thread_buffers(wf, nthreads() + 1, floris); for single-thread use create_thread_buffers(wf, 1, floris)\nmx::Matrix: X-coordinates of grid points (m)\nmy::Matrix: Y-coordinates of grid points (m)  \nnM::Int: Number of measurements to compute (typically 3)\nzh::Real: Hub height for measurements (m)\nwf::WindFarm: Wind farm object containing turbine data. See: WindFarm\nwf.nT: Number of real turbines\nwf.StartI: Starting indices for turbine data\nwf.posBase, wf.posNac: Turbine positions\nwf.States_*: Turbine state matrices\nset::Settings: Settings object containing simulation parameters. See: Settings\nfloris::Floris: FLORIS model parameters for wake calculations. See: Floris\nwind::Wind: Wind field configuration. See: Wind\n\nReturns\n\nmz::Array{Float64,3}: 3D array of measurements with dimensions (size(mx,1), size(mx,2), nM)\nmz[:,:,1]: Velocity reduction\nmz[:,:,2]: Added turbulence intensity\nmz[:,:,3]: Effective wind speed\n\nAlgorithm\n\nFor each grid point:\n\nCreates a temporary wind farm with all original turbines plus one virtual turbine at the grid point\nSets the virtual turbine to depend on all real turbines (to capture wake effects)\nRuns the FLORIS simulation to compute wake-affected flow properties\nExtracts the result for the virtual turbine position\n\nPerformance Notes\n\nMulti-threaded implementation using @threads for parallel processing of grid points when more than one buffer is provided\nWith a single buffer (length(buffers.thread_buffers) == 1), runs in a single-threaded loop\nEach grid point requires a full wind farm simulation, so computation time scales with grid size\nUses thread-local buffers created by create_thread_buffers to avoid race conditions\nOn Julia 1.12 create nthreads() + 1 buffers to accommodate thread indexing\n\nExample\n\n# Create a 10x10 grid from 0 to 1000m\nx_range = 0:100:1000\ny_range = 0:100:1000\nmx = repeat(collect(x_range)', length(y_range), 1)\nmy = repeat(collect(y_range), 1, length(x_range))\n\n# Calculate 3 measurements at 90m hub height (single-thread)\nbuffers = create_thread_buffers(wind_farm, 1, floris_model)\nmz = getMeasurements(buffers, mx, my, 3, 90.0, wind_farm, settings, floris_model, wind_config)\n\n# Extract effective wind speed field\nwind_speed_field = mz[:, :, 3]\n\nSee Also\n\ncalcFlowField: Higher-level function that uses this to create complete flow field data\nsetUpTmpWFAndRun!: Underlying simulation function used for each grid point\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.calcFlowField","page":"High-Level Functions","title":"FLORIDyn.calcFlowField","text":"calcFlowField(set::Settings, wf::WindFarm, wind::Wind, floris::Floris; plt=nothing)\n\nGenerate full flow field plot data by calculating measurements across a grid.\n\nThis function creates a rectangular grid over the wind farm domain and calculates flow field properties at each grid point by treating them as virtual turbines. The computation can be performed in parallel if set.threading is true.\n\nArguments\n\nset::Settings: Settings object containing simulation parameters\nset.threading: If true, uses multi-threaded computation with @threads\nset.parallel: If true, enables parallel-specific optimizations\nwf::WindFarm: Wind farm object containing turbine data\nwind::Wind: Wind field configuration  \nfloris::Floris: FLORIS model parameters\n\nKeyword Arguments\n\nplt=nothing: Plot object for garbage collection control. If provided and set.parallel is true, automatically calls plt.GC.enable(false) before multithreading and plt.GC.enable(true)  after completion to prevent PyCall-related segmentation faults during parallel execution with ControlPlots loaded. To take full advantage of multithreading, executed the plotting in a separate process.\nvis=nothing: Visualization configuration object containing field limits and resolution settings. If provided, uses vis.field_limits_min, vis.field_limits_max, and vis.field_resolution  to define the computational grid. If not provided, defaults to domain [0,0,0] to [3000,3000,400]  meters with 20m resolution.\n\nReturns\n\nZ::Array{Float64,3}: 3D array of flow field measurements with dimensions (ny, nx, 3)\nZ[:,:,1]: Velocity reduction factor\nZ[:,:,2]: Added turbulence intensity  \nZ[:,:,3]: Effective wind speed (m/s)\nX::Matrix{Float64}: X-coordinate grid (m)\nY::Matrix{Float64}: Y-coordinate grid (m)\n\nNotes\n\nGrid resolution and domain are configurable via the vis parameter, or use default values for backward compatibility\nHub height is taken from the first turbine in the wind farm\n\nExample\n\n# Calculate flow field with threading and GC control\nset.threading = true\nZ, X, Y = calcFlowField(set, wf, wind, floris; plt)\n\n# Extract velocity reduction field\nvelocity_reduction = Z[:, :, 1]\n\n# Extract effective wind speed field  \nwind_speed = Z[:, :, 3]\n\nSee Also\n\ngetMeasurements: Function used internally to compute the flow field\nplotFlowField: Visualization function for the generated data\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plotFlowField","page":"High-Level Functions","title":"FLORIDyn.plotFlowField","text":"plotFlowField(state::Union{Nothing, PlotState}, plt, wf, mx, my, mz, vis::Vis, t=nothing; \n              msr::MSR=EffWind, fig=nothing)\n\nPlot a 2D contour of the flow field data with support for animation.\n\nArguments\n\nstate::Union{Nothing, PlotState}: Animation state object. Pass nothing for the first call,  then pass the returned state for subsequent calls to maintain the same figure and layout.\nplt: Plotting package (e.g., ControlPlots.plt)\nwf: Wind farm object containing turbine data\nmx::Matrix: X-coordinate grid\nmy::Matrix: Y-coordinate grid  \nmz::Array{Float64,3}: 3D array of measurements with dimensions (rows, cols, nM)\nvis::Vis: Visualization settings including save options and color scale parameters\nt: Time value for display in the plot title or annotations\nmsr::MSR: Which measurement to plot. See: MSR\nvis.unit_test::Bool: Whether to automatically close plots for testing.\n\nReturns\n\nstate::PlotState: Updated or newly created plot state for use in subsequent calls\n\nDescription\n\nThis function supports creating animations by maintaining plot state across multiple calls:\n\nFirst Call (state = nothing)\n\nCreates new figure, axes, colorbar, and all plot elements\nInitializes and returns a PlotState object\n\nSubsequent Calls (state = PlotState)\n\nUpdates existing contour data, turbine positions, and observation points\nReuses the same figure and layout for smooth animation\n\nAnimation Example\n\nusing ControlPlots\n\n# Initialize state (first frame)\nstate = nothing\nvis = Vis(online=true, save=true)  # Enable saving to video folder\nfor t in time_steps\n    Z, X, Y = calcFlowField(settings, wind_farm, wind, floris)\n    state = plotFlowField(state, plt, wind_farm, X, Y, Z, vis, t; msr=EffWind)\n    plt.pause(0.01)  # Small delay for animation\nend\n\nNotes\n\nThe function automatically handles coordinate system transformations for turbine orientations\nObservation points are displayed as white scatter points for reference\nColor scales are kept consistent across animation frames when using the same measurement type\nThe time parameter t can be used for title updates or time annotations\nWhen vis.save=true, plots are saved as PNG files to the video/ directory\nSaved filenames include measurement type and time information (e.g., velocity_reduction_t0120s.png)\nThe video/ directory is automatically created if it doesn't exist\nThis function requires a plotting package like ControlPlots.jl to be loaded and available as plt\n\n\n\n\n\nplotFlowField(plt, wf, mx, my, mz, vis, t=nothing; msr=EffWind, fig=nothing)\n\nCompatibility method for the original plotFlowField interface.\n\nThis method provides backward compatibility by calling the new state-based version  with state=nothing, effectively creating a single plot without animation support.\n\nArguments\n\nplt: Plotting package (e.g., ControlPlots.plt)\nwf: Wind farm object containing turbine data\nmx::Matrix: X-coordinate grid\nmy::Matrix: Y-coordinate grid  \nmz::Array{Float64,3}: 3D array of measurements with dimensions (rows, cols, nM)\nvis::Vis: Visualization settings including save options and color scale parameters\nt: Time value for display in the plot title or annotations\nmsr::MSR: Which measurement to plot. See: MSR\nvis.unit_test::Bool: Whether to automatically close plots for testing.\n\nReturns\n\nnothing: For compatibility with the original interface\n\nNote\n\nThis method is provided for backward compatibility. For animation support,  use the new interface with explicit state management.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plot_flow_field","page":"High-Level Functions","title":"FLORIDyn.plot_flow_field","text":"plot_flow_field(wf, X, Y, Z, vis; msr=VelReduction, plt=nothing, \n                fig=nothing) -> Nothing\n\nHigh-level plotting function that automatically dispatches to either parallel or  sequential plotting based on the number of available threads and processes.\n\nArguments\n\nwf: WindFarm object\nX, Y, Z: Flow field coordinate arrays\nvis: Visualization settings\nmsr: Measurement type, see: MSR\nplt: Matplotlib PyPlot instance (only used in sequential mode)\nfig: Figure name (optional)\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plotMeasurements","page":"High-Level Functions","title":"FLORIDyn.plotMeasurements","text":"plotMeasurements(plt, wf::WindFarm, md::DataFrame, vis::Vis; \n                 separated=false, msr=VelReduction, pltctrl=nothing) -> Nothing\n\nPlot measurement data from FLORIDyn simulation results.\n\nArguments\n\nplt: Plotting package (e.g., PyPlot, which is exported from ControlPlots); nothing for remote plotting\nwf::WindFarm: Wind farm object with field nT (number of turbines). See WindFarm\nmd::DataFrame: Measurements DataFrame containing time series data with columns:\nTime: Simulation time [s]\nForeignReduction: Foreign reduction [%] (for VelReduction)\nAddedTurbulence: Added turbulence [%] (for AddedTurbulence)\nEffWindSpeed: Effective wind speed [m/s] (for EffWind)\nvis::Vis: Visualization settings including unit_test parameter. See Vis\nseparated::Bool: Whether to use separated subplot layout (default: false)\nmsr::MSR: Measurement type to plot, see: MSR. Options: VelReduction, AddedTurbulence, EffWind\npltctrl: ControlPlots module instance (optional, used for large turbine count plotting); nothing for remote plotting\n\nReturns\n\nnothing\n\nDescription\n\nThis function creates time series plots of measurement data from FLORIDyn simulations. It handles:\n\nTime normalization by subtracting the start time\nMultiple measurement types (velocity reduction, added turbulence, effective wind speed)\nAutomatic layout selection based on turbine count\nBoth separated (subplot) and combined plotting modes\n\nPlotting Modes\n\nSeparated mode (separated=true): Creates individual subplots for each turbine\nFor ≤9 turbines: Traditional subplot grid\nFor >9 turbines: Uses helper function with grouped subplots via plot_x\nCombined mode (separated=false): Plots all turbines on a single figure with different colors\n\nExamples\n\nusing ControlPlots # For single-threaded plotting\n\n# Plot velocity reduction for all turbines in combined mode\nplotMeasurements(plt, wind_farm, measurements_df, vis; msr=VelReduction)\n\n# Plot added turbulence with separated subplots\nplotMeasurements(plt, wind_farm, measurements_df, vis; separated=true, msr=AddedTurbulence)\n\n# Plot effective wind speed with ControlPlots module for large farms\nplotMeasurements(plt, wind_farm, measurements_df, vis; separated=true, msr=EffWind, pltctrl=ControlPlots)\n\nSee Also\n\nplotFlowField: For flow field visualization\ngetMeasurements: For generating measurement data\nprepare_large_plot_inputs: Helper for large turbine counts\nplot_x: Multi-subplot plotting function\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plot_measurements","page":"High-Level Functions","title":"FLORIDyn.plot_measurements","text":"plot_measurements(wf, md, vis; separated=true, msr=VelReduction, plt=nothing) -> Nothing\n\nHigh-level measurements plotting function that automatically dispatches to either  parallel or sequential plotting based on the number of available threads and processes.\n\nArguments\n\nwf: WindFarm object\nmd: Measurement data\nvis: Visualization settings\nseparated: Whether to use separated subplots\nmsr: Measurement type, see: MSR \nplt: Matplotlib PyPlot instance (only used in sequential mode)\n\nReturns\n\nnothing\n\nSee Also\n\nplotMeasurements: The underlying plotting function used in sequential mode\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plot_x","page":"High-Level Functions","title":"FLORIDyn.plot_x","text":"plot_x(times, plot_data...; ylabels=nothing, labels=nothing, fig=\"Wind Direction\", \n       xlabel=\"rel_time [s]\", ysize=10, bottom=0.02, legend_size=nothing, pltctrl=nothing, \n       loc=nothing) -> Nothing\n\nHigh-level time series plotting function that automatically dispatches to either  parallel or sequential plotting based on the number of available threads and processes.\n\nArguments\n\ntimes:        Time vector for x-axis\nplot_data...: Variable number of data arrays to plot\nylabels:      Labels for y-axes (optional)\nlabels:       Labels for subplots (optional)\nfig:          Figure title (default: \"Wind Direction\")\nxlabel:       X-axis label (default: \"rel_time [s]\")\nysize:        Size of the Y-axis labels in points (default: 10)\nbottom:       Bottom margin (default: 0.02)\nlegend_size:  Legend font size in points (optional)\npltctrl:      ControlPlots instance (only used in sequential mode)\n\nReturns\n\nnothing\n\nDescription\n\nWhen running with multiple threads and processes, it uses remote plotting  capabilities via rmt_plotx ONLY if no local pltctrl is provided. If a pltctrl argument is supplied (e.g. during unit tests with a mock), it forces the sequential path so tests can observe side-effects without needing remote worker setup.\n\nExample\n\nplot_x(times, data1, data2; ylabels=[\"Turbine 1\", \"Turbine 2\"], \n       labels=[\"Wind Speed\", \"Power\"], legend_size=8, pltctrl=pltctrl)\n\nSee Also\n\nplotx: The underlying plotting function from ControlPlots used in sequential mode\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.prepare_large_plot_inputs","page":"High-Level Functions","title":"FLORIDyn.prepare_large_plot_inputs","text":"prepare_large_plot_inputs(wf, md, data_column, ylabel) -> (times, plot_data, turbine_labels, subplot_labels)\n\nPrepare grouped plotting inputs for large numbers of turbines when separated=true.\n\nReturns\n\ntimes::Vector{Float64}: Time vector (one entry per recorded time step)\nplot_data::Vector{Any}: Each element is either a Vector (single line subplot) or Vector{Vector{Float64}} (multiple lines)\nturbine_labels::Vector{String}: Y-axis labels per subplot (same ylabel repeated)\nsubplot_labels::Vector{Vector{String}}: Line labels per subplot\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.close_all","page":"High-Level Functions","title":"FLORIDyn.close_all","text":"close_all(plt)\n\nClose all matplotlib figure windows.\n\nThis function automatically dispatches to either parallel or sequential plotting based on the number of available threads and processes.\n\nArguments\n\nplt: Matplotlib PyPlot instance (only used in sequential mode)\n\nDescription\n\nWhen running with multiple threads and processes, it uses remote plotting  capabilities to close all figures on the remote worker. Otherwise, it directly calls plt.close(\"all\") to close all figures in the current process.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#Video-Creation","page":"High-Level Functions","title":"Video Creation","text":"","category":"section"},{"location":"functions_II/#FLORIDyn.cleanup_video_folder","page":"High-Level Functions","title":"FLORIDyn.cleanup_video_folder","text":"cleanup_video_folder() -> Nothing\n\nClean up existing PNG files in the video folder before creating new videos.\n\nDescription\n\nThis function removes all PNG files from the \"video\" directory to ensure a clean slate  before generating new video frames. It is typically called before running simulations  that create video output to prevent mixing old frames with new ones.\n\nBehavior\n\nChecks if the \"video\" directory exists\nScans the directory for files with \".png\" extension\nAttempts to delete each PNG file found\nReports the number of files deleted\nIssues warnings for any files that cannot be deleted\n\nReturns\n\nNothing\n\nExample\n\n# Clean up before creating new video frames\ncleanup_video_folder()\n\n# Run simulation that generates PNG frames\n# ...\n\n# Create video from frames\ncreateVideo()\n\nSee Also\n\ncreateVideo: Create MP4 video from PNG frames\ncreateAllVideos: Create videos for all measurement types\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.createVideo","page":"High-Level Functions","title":"FLORIDyn.createVideo","text":"createVideo(prefix::String; video_dir=\"video\", output_dir=\"video\", fps=2, delete_frames=false)\n\nConvert PNG files in a directory starting with a given prefix into an MP4 video.\n\nArguments\n\nprefix::String: The prefix string that PNG files must start with (e.g., \"velocityreduction\", \"windspeed\")\nvideo_dir::String: Directory containing the PNG files (default: \"video\")\noutput_dir::String: Directory where the output video will be saved (default: \"video\")\nfps::Int: Frames per second for the output video (default: 2)\ndelete_frames::Bool: Whether to delete the PNG files after creating the video (default: false)\n\nReturns\n\nString: Path to the created video file, or empty string if creation failed\n\nDescription\n\nThis function searches for PNG files in the specified directory that start with the given prefix, sorts them naturally (handling numeric sequences correctly), and combines them into an MP4 video using FFmpeg. The function requires FFmpeg to be installed on the system.\n\nExamples\n\n# Create video from velocity reduction frames\nvideo_path = createVideo(\"velocity_reduction\"; fps=4)\n\n# Create video from wind speed frames and delete source frames\nvideo_path = createVideo(\"wind_speed\"; fps=6, delete_frames=true)\n\n# Create video from custom directory\nvideo_path = createVideo(\"added_turbulence\"; video_dir=\"custom_plots\", output_dir=\"videos\")\n\nRequirements\n\nFFmpeg must be installed and available in the system PATH\nPNG files should follow a consistent naming pattern with the prefix\nRecommended naming: \"prefixt0000s.png\", \"prefixt0012s.png\", etc.\n\nNotes\n\nFiles are sorted naturally to handle numeric sequences correctly (e.g., t0001s, t0010s, t0100s)\nThe output video filename will be \"prefix_animation.mp4\"\nIf no matching files are found, the function returns an empty string\nFFmpeg parameters are optimized for good quality and reasonable file size\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.createAllVideos","page":"High-Level Functions","title":"FLORIDyn.createAllVideos","text":"createAllVideos(; video_dir=\"video\", output_dir=\"video\", fps=2, delete_frames=false)\n\nCreate videos for all common measurement types found in the video directory.\n\nArguments\n\nvideo_dir::String: Directory containing the PNG files (default: \"video\")\noutput_dir::String: Directory where output videos will be saved (default: \"video\")\nfps::Int: Frames per second for output videos (default: 2)\ndelete_frames::Bool: Whether to delete PNG files after creating videos (default: false)\n\nReturns\n\nVector{String}: Paths to created video files\n\nDescription\n\nThis convenience function automatically detects common measurement type prefixes in the video directory and creates videos for each type found. It looks for the following prefixes:\n\n\"velocity_reduction\"\n\"added_turbulence\" \n\"wind_speed\"\n\nExample\n\n# Create videos for all measurement types found\nvideo_paths = createAllVideos(fps=4, delete_frames=true)\nprintln(\"Created videos: \", video_paths)\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.natural_sort_key","page":"High-Level Functions","title":"FLORIDyn.natural_sort_key","text":"natural_sort_key(filename::String)\n\nGenerate a sort key for natural sorting of filenames containing numbers.\n\nArguments\n\nfilename::String: The filename to generate a sort key for\n\nReturns\n\nVector: Sort key that handles numeric sequences naturally\n\nDescription\n\nThis function creates a sort key that handles numeric sequences in filenames correctly. For example, it will sort [\"file1.png\", \"file10.png\", \"file2.png\"] as  [\"file1.png\", \"file2.png\", \"file10.png\"] rather than alphabetically.\n\nExamples\n\nfiles = [\"velocity_reduction_t0001s.png\", \"velocity_reduction_t0010s.png\", \"velocity_reduction_t0002s.png\"]\nsorted_files = sort(files, by=natural_sort_key)\n# Result: [\"velocity_reduction_t0001s.png\", \"velocity_reduction_t0002s.png\", \"velocity_reduction_t0010s.png\"]\n\n\n\n\n\n","category":"function"},{"location":"functions/#Low-Level-Functions","page":"Low-Level Functions","title":"Low-Level Functions","text":"","category":"section"},{"location":"functions/#Calculating-the-wind-directions","page":"Low-Level Functions","title":"Calculating the wind directions","text":"","category":"section"},{"location":"functions/#FLORIDyn.getWindDirT","page":"Low-Level Functions","title":"FLORIDyn.getWindDirT","text":"getWindDirT(::Direction_Constant, wind_dir, iT, _)\n\nReturn wind direction in SOWFA-degrees for the requested turbine(s).\n\nArguments\n\nwind_dir: The wind direction (scalar).\niT: Index or indices of the turbines (can be an integer or vector).\n_: Placeholder for unused argument.\n\nReturns\n\nphi: Array of wind direction values, same size as iT.\n\n\n\n\n\ngetWindDirT(::Direction_Constant_wErrorCov, wind_dir::WindDirType, iT, t)\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::WindDirType: WindDirType\niT: Vector of turbine indices (can be any indexable collection)\nt: Time step\n\nReturns\n\nphi: Vector of wind directions for the selected turbines, including random perturbation\n\n\n\n\n\ngetWindDirT(::Direction_Interpolation, wind_dir::AbstractMatrix, iT, t)\n\nDirection_Interpolation\n\nReturns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.\n\nArguments:\n\nwind_dir::Matrix: columns are time and phi (wind direction)\niT: single value or vector with turbine index/indices\nt: time of request\n\nReturns:\n\nphi: Vector of wind directions for each turbine in iT [°]\n\n\n\n\n\ngetWindDirT(::Direction_Interpolation_wErrorCov, wind_dir::WindDirMatrix, iT, t)\n\nReturns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.\n\nArguments:\n\nwind_dir::WindDirMatrix: WindDirMatrix\niT: single value or vector with turbine index/indices\nt: time of request\n\nReturns:\n\nphi: Vector of wind directions for each turbine in iT [°]\n\n\n\n\n\ngetWindDirT(::Direction_InterpTurbine, wind_dir, iT, t)\n\nReturn wind direction in SOWFA-degrees for the requested turbine(s).\n\nArguments\n\nwind_dir::Matrix: Each row is [time, phi_T0, phi_T1, ...].\n`iT: Index or indices of turbines.\nt: Time of request. [s]\n\nReturns\n\nphi::Vector{Float64}: Wind direction(s) for the selected turbine(s) at time t. [°]\n\n\n\n\n\ngetWindDirT(::Direction_InterpTurbine_wErrorCov, wind_dir::WindDirMatrix, iT, t)\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::WindDirMatrix: See: WindDirMatrix\niT: Index or indices of the turbines (can be integer or vector)\nt: Time of request (Float64) [s]\n\nReturns\n\nphi: Wind direction(s) for requested turbine(s), perturbed with noise. [°]\n\n\n\n\n\ngetWindDirT(::Direction_RW_with_Mean, wind_dir_now, wind_dir::WindDirTriple)\n\nReturns the wind direction at the respective turbine(s).\n\nArguments\n\nwind_dir_now: Current value (vector)\nwind_dir::WindDirTriple: WindDirTriple\n\nReturns\n\nphi: Updated wind direction(s) (vector) [°]\n\n\n\n\n\ngetWindDirT(::Direction_RW_with_Mean, wind_dir::WindDirTriple, iT, t)\n\nRandom walk with mean reversion model for wind direction.\n\nArguments\n\n::Direction_RW_with_Mean: Direction mode indicator\nwind_dir::WindDirTriple: Wind direction data containing Init, CholSig, and MeanPull\niT: Turbine index or indices\nt: Time value (unused in this implementation) [s]\n\nReturns\n\nphi: Wind direction(s) for the requested turbine(s) [°]\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getWindDirT_EnKF","page":"Low-Level Functions","title":"FLORIDyn.getWindDirT_EnKF","text":"getWindDirT_EnKF(::Direction_EnKF_InterpTurbine, wind_dir::AbstractMatrix, iT, t)\n\nDirectionEnKFInterpTurbine\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::Matrix: Matrix where each row is [time, phi_T0, phi_T1, ... phi_Tn]\niT: Index or indices of the turbines (can be integer or vector)\nt: Time of request (scalar)\n\nReturns\n\nphi: Wind direction(s) at time t for turbine(s) iT [°]\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getDataDir","page":"Low-Level Functions","title":"FLORIDyn.getDataDir","text":"getDataDir(set::Settings, wind::Wind, wf::WindFarm, t)\n\nRetrieve wind direction data for all turbines at the current simulation time.\n\nArguments\n\nset::Settings: Simulation settings containing the direction mode configuration\nwind::Wind: Wind field data structure containing direction information and input type\nwf::WindFarm: Wind farm object containing turbine states and configuration\nt: Current simulation time for temporal interpolation\n\nReturns\n\nphi: Wind direction values (typically in radians) for all turbines at the specified time\n\nDescription\n\nThis function reads wind direction data and returns the current wind direction angle (phi) for all  turbines in the wind farm. The function handles two different input modes:\n\nRandom Walk with Mean mode (wind.input_dir == \"RW_with_Mean\"): Uses the current wind farm  state from wf.States_WF[wf.StartI, 2] along with the wind direction data to compute direction.\nStandard temporal interpolation mode: Uses the wind direction data directly with temporal  interpolation for all turbines at the specified simulation time.\n\nThe function dispatches to getWindDirT with appropriate parameters based on the input mode,  ensuring consistent wind direction estimation across different modeling approaches.\n\nExamples\n\n# Get wind direction for all turbines at current simulation time\nphi = getDataDir(settings, wind_data, wind_farm, 100.0)\n\n# The returned phi contains direction values for all turbines\ndirection_turbine_1 = phi[1]\n\nNotes\n\nThe function automatically handles different wind input modes through conditional logic\nFor random walk mode, uses existing wind farm state as reference\nFor standard mode, performs temporal interpolation across all turbines\n\nSee also\n\ngetWindDirT: Underlying function for wind direction temporal interpolation\nSettings: Configuration structure containing direction mode settings\nWind: Wind field data structure containing direction information and input type\nWindFarm: Wind farm configuration structure\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.correctDir!","page":"Low-Level Functions","title":"FLORIDyn.correctDir!","text":"correctDir!(::Direction_All, set::Settings, wf::WindFarm, wind::Wind, t)\n\nApply direction correction to all turbines in the wind farm using the Direction_All strategy.\n\nArguments\n\n::Direction_All: The direction correction strategy type that applies corrections to all turbines\nset::Settings: Simulation settings containing the direction mode configuration\nwf::WindFarm: Wind farm object containing turbine states and configuration (modified in-place)\nwind::Wind: Wind field data structure containing direction information and input type\nt: Current simulation time for temporal interpolation\n\nReturns\n\nnothing: This function modifies the wind farm state in-place and returns nothing\n\nDescription\n\nThis function applies a direction correction using the Direction_All strategy, which updates the  wind direction for all turbines in the wind farm. The function performs the following operations:\n\nData Retrieval: Calls getDataDir to obtain current wind direction data for all turbines\nState Update: Updates the wind direction in the wind farm state (wf.States_WF[:, 2])\nObservation Point Orientation: If the state matrix has 4 columns, also updates the  observation point orientation (wf.States_WF[wf.StartI, 4]) to match the wind direction\n\nThe correction is applied uniformly to all turbines using the first direction value from the  retrieved direction data.\n\nExamples\n\n# Apply direction correction to all turbines\ncorrectDir!(Direction_All(), settings, wind_farm, wind_data, 100.0)\n\n# The wind farm state is modified in-place\ncurrent_direction = wind_farm.States_WF[1, 2]  # Updated direction for first turbine\n\nNotes\n\nThis function modifies the wind farm state in-place (indicated by the ! suffix)\nAll turbines receive the same direction correction value (phi[1])\nThe observation point orientation is only updated if the state matrix has 4 columns\nDirection values are typically in radians following standard wind engineering conventions\n\nSee also\n\ngetDataDir: Function for retrieving wind direction data\nDirection_All: Direction correction strategy type\nSettings: Simulation settings structure\nWindFarm: Wind farm configuration structure\nWind: Wind field data structure\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-velocity","page":"Low-Level Functions","title":"Calculating the wind velocity","text":"","category":"section"},{"location":"functions/#FLORIDyn.getDataVel","page":"Low-Level Functions","title":"FLORIDyn.getDataVel","text":"    getDataVel(set::Settings, wind::Wind, wf::WindFarm, t, tmp_m, floris::Floris)\n\nReturn the wind speed vector u for all turbines at simulation time t according to the configured input / model mode. Also returns (potentially updated) wind.\n\nArguments\n\nset::Settings: simulation settings (uses set.vel_mode)\nwind::Wind: wind field state (wind.input_vel selects special branches)\nwf::WindFarm: wind farm (uses wf.nT, wf.States_WF)\nt: current simulation time\ntmp_m: temporary matrix (only used for IandI wake reduction)\nfloris::Floris: FLORIS parameters (yaw exponent etc., only IandI branch)\n\nSupported (unit tested in test_getDataVel_branches.jl)\n\nStandard interpolation / constant variants via set.vel_mode:   Velocity_Constant, Velocity_Interpolation, Velocity_Constant_wErrorCov,   Velocity_Interpolation_wErrorCov, Velocity_InterpTurbine,   Velocity_InterpTurbine_wErrorCov, Velocity_ZOH_wErrorCov.\nEnKF turbine interpolation branch: wind.input_vel == \"EnKF_InterpTurbine\" calling   getWindSpeedT_EnKF(Velocity_EnKF_InterpTurbine(), ...) with clamping of out-of-range times.\n\nNot yet fully integrated (guarded / broken tests)\n\n\"I_and_I\": an internal estimator state struct (WSEStruct in windfield_velocity.jl) already exists   and the low-level update routine WindSpeedEstimatorIandI_FLORIDyn runs, but a public, documented   construction path (export, convenience constructor, validation of required fields, tests) is missing.   The branch is therefore kept experimental and the test remains @test_broken until we provide a   stable API (e.g. build_IandI_estimator(wf, data; kwargs...)).\n\"RW_with_Mean\": random-walk-with-mean model commented out; current call raises MethodError.\n\nPlanned cleanups / TODO\n\nProvide concrete exported estimator type & finalize I_and_I logic.\nRe-introduce Random Walk with Mean model (Velocity_RW_with_Mean).\n\nBehavior summary\n\nDefault: u = getWindSpeedT(set.vel_mode, wind.vel, 1:nT, t).\nEnKF: per-turbine linear interpolation table with time clamping.\nIandI: (future) estimator integration plus optional wake reduction using tmp_m[:,1].\nRWwithMean: (future) stochastic update around mean with mean-pull term.\n\nAll returned velocities are in m/s. Only IandI may mutate wind.vel estimator state.\n\nExample\n\nu, wind = getDataVel(set, wind, wf, 100.0, tmp_m, floris)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-shear","page":"Low-Level Functions","title":"Calculating the wind shear","text":"","category":"section"},{"location":"functions/#FLORIDyn.getWindShearT","page":"Low-Level Functions","title":"FLORIDyn.getWindShearT","text":"getWindShearT(::Shear_Interpolation, wind_shear::AbstractMatrix, z)\n\nCompute the wind shear at a given height z using the specified wind_shear model.\n\nArguments\n\n::Shear_Interpolation: (Type only) Use interpolation to determine the wind shear.\nwind_shear: A matrix describing the wind shear profile.\nz: The height (in meters) at which to evaluate the wind shear.\n\nReturns\n\nThe wind shear value at height z.\n\nREMARKS\n\nExpects a .csv file called \"WindShearProfile.csv\" with a normalized wind speed profile for different heights:\n\nz, (u_z/u0)\nz, (u_z/u0)\nz, (u_z/u0)\n\nThere is a linear interpolation between every pair. In case z is out of bounds the function will use the closest available setpoint.\n\n\n\n\n\ngetWindShearT(::Shear_PowerLaw, wind_shear::WindShear, z_norm)\n\nReturn the shear factor u_eff = shear * u_referenceHeight using the power law.\n\nArguments\n\nShear_PowerLaw: (type only, unused) Specifies that this method applies to the power law model\nwind_shear: A struct of type (WindShear)(@ref)\nz0: Reference height (not used in this function)\nalpha: WindShear coefficient\nz_norm: Height(s) (can be scalar or array)\n\nReturns\n\nshear: The shear factor at the given height(s)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-turbulence","page":"Low-Level Functions","title":"Calculating the wind turbulence","text":"","category":"section"},{"location":"functions/#FLORIDyn.getDataTI","page":"Low-Level Functions","title":"FLORIDyn.getDataTI","text":"getDataTI(set::Settings, wind::Wind, wf::WindFarm, t) -> Vector\n\nRetrieve turbulence intensity data for all turbines at the current simulation time.\n\nThis function obtains turbulence intensity values for all turbines in the wind farm using the configured turbulence model and wind field data. It serves as a wrapper around the underlying turbulence intensity retrieval system.\n\nArguments\n\nset::Settings: Settings object containing simulation configuration\nset.turb_mode: Turbulence model configuration specifying the retrieval method\nwind::Wind: Wind configuration object containing turbulence intensity data\nwind.ti: Turbulence intensity data, parameters, or model configuration\nwf::WindFarm: Wind farm object containing turbine information\nwf.nT: Number of turbines in the wind farm\nt: Current simulation time for time-dependent turbulence intensity models\n\nReturns\n\nVector: Turbulence intensity values for all turbines (dimensionless, typically 0.05-0.25)\n\nBehavior\n\nThe function creates a vector of all turbine indices [1, 2, ..., nT] and retrieves the corresponding turbulence intensity values using the specified turbulence model. The actual retrieval method depends on the set.turb_mode configuration and can include:\n\nConstant turbulence intensity\nTime-interpolated values from data files\nTurbine-specific interpolation\nRandom walk models with covariance\n\nExample\n\n# Get turbulence intensity for all turbines at t=100s\nTI_values = getDataTI(settings, wind_config, wind_farm, 100.0)\nprintln(\"TI for turbine 1: \", TI_values[1])\n\nSee Also\n\ngetWindTiT: Underlying function for turbulence intensity retrieval\ncorrectTI!: Function that uses this data to update wind farm states\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getWindTiT","page":"Low-Level Functions","title":"FLORIDyn.getWindTiT","text":"getWindTiT(::TI_Constant, wind_ti, iT, _)\n\nReturn turbulence intensity for the requested turbine(s).\n\nArguments\n\n::TI_Constant: Type parameter to indicate constant wind turbulence\nwind_ti:       Constant value (turbulence intensity)\niT:            Index or indices of the turbines\n_:             will be ignored\n\nReturns\n\nTi: Array of turbulence intensity values for each turbine index\n\n\n\n\n\ngetWindTiT(::TI_Interpolation, wind_ti::AbstractMatrix, iT, t)\n\nInterpolates the wind turbulence intensity (TI) at a given time t using the specified TI_Interpolation method.\n\nArguments\n\n::TI_Interpolation: Use linear interpolation to calculate the turbulence intensity.\nwind_ti::Matrix: Matrix containing wind turbulence intensity values over time.\niT: Index/indices of the turbines (can be Int or array).\nt: The specific time at which to interpolate the turbulence intensity.\n\nReturns\n\nThe interpolated turbulence for the requested turbine(s) at time t.\n\nNotes\n\nThe function assumes that wind_ti contains the necessary data for interpolation as (time, TI) pairs (n×2 matrix)\nUniform interpolation version - all turbines experience the same changes.\n\n\n\n\n\ngetWindTiT(::TI_InterpTurbine, wind_ti::AbstractMatrix, iT, t)\n\nRetrieve the wind turbulence intensity (TI) for a specific turbine at a given time.\n\nArguments\n\n::TI_InterpTurbine: The turbulence intensity interpolation object for the turbine.\nwind_ti::AbstractMatrix: Matrix containing wind turbulence intensity values.\niT: Index of the turbine for which the TI is requested.\nt: Time at which the TI value is needed.\n\nReturns\n\nThe interpolated wind turbulence intensity value for the specified turbine at time t.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.correctTI!","page":"Low-Level Functions","title":"FLORIDyn.correctTI!","text":"correctTI!(::TI_None, set::Settings, wf::WindFarm, wind::Wind, t) -> Nothing\n\nUpdate turbulence intensity values in the wind farm state matrix without correction.\n\nThis function implements the \"no correction\" strategy for turbulence intensity, where  the wind farm turbulence intensity values are updated with fresh data from the wind  field model without applying any correction algorithms. It serves as the baseline  approach for turbulence intensity handling in FLORIDyn simulations.\n\nArguments\n\n::TI_None: Dispatch type indicating no turbulence intensity correction algorithm\nset::Settings: Settings object containing simulation configuration and turbulence model parameters\nset.turb_mode: Turbulence model configuration specifying the retrieval method\nwf::WindFarm: Wind farm object containing the state matrices to be updated\nwf.States_WF: Wind field states matrix where column 3 contains turbulence intensity values\nwf.StartI: Starting indices for each turbine's observation points\nwf.nT: Number of turbines\nwind::Wind: Wind configuration object containing turbulence intensity data\nwind.ti: Turbulence intensity data or model parameters\nt: Current simulation time for time-dependent turbulence intensity retrieval\n\nReturns\n\nNothing: The function modifies the wind farm state in-place\n\nBehavior\n\nRetrieves current turbulence intensity values for all turbines using getDataTI\nUpdates the wind farm state matrix wf.States_WF at rows wf.StartI and column 3\nTransposes the turbulence intensity vector to match the matrix structure\nProvides error handling for matrix update operations\n\nExample\n\n# Update turbulence intensity without correction at t=50s\ncorrectTI!(TI_None(), settings, wf, wind, 50.0)\n\n# The wind farm state matrix is now updated with new TI values\ncurrent_ti = wf.States_WF[wf.StartI, 3]\n\nNotes\n\nThe function modifies the wind farm object in-place (indicated by the ! suffix)\nThis \"no correction\" approach provides baseline turbulence intensity without  applying wake-induced corrections or measurement-based adjustments\nError handling ensures graceful failure if matrix dimensions are incompatible\n\nSee Also\n\ngetDataTI: Function used to retrieve turbulence intensity data\nTI_None: Dispatch type for no correction strategy\n\n\n\n\n\n","category":"function"},{"location":"functions/#Controller-functions","page":"Low-Level Functions","title":"Controller functions","text":"","category":"section"},{"location":"functions/#FLORIDyn.getYaw","page":"Low-Level Functions","title":"FLORIDyn.getYaw","text":"getYaw(::Yaw_SOWFA, con_yaw_data::AbstractMatrix, iT, t) -> Float64 or Vector{Float64}\n\nReturn the yaw angle at time t for the specified turbine(s) using linear interpolation.\n\nArguments\n\n::Yaw_SOWFA: Controller type dispatch parameter for SOWFA-style yaw control\ncon_yaw_data::Matrix{Float64}: Control data matrix where:\nFirst column contains time values (in seconds)\nSubsequent columns contain yaw angles for each turbine (in degrees)\niT: Turbine index or indices to query:\nInteger: Single turbine index (1-based)\nAbstractVector{<:Integer}: Vector of turbine indices for multiple turbines\nt::Real: Requested time (in seconds)\n\nReturns\n\nFloat64: Single yaw angle (in degrees) if iT is an integer\nVector{Float64}: Vector of yaw angles (in degrees) if iT is a vector\n\nBehavior\n\nInterpolation: Uses linear interpolation between time points with flat extrapolation\nOut-of-bounds handling: If t is outside the time range, the function:\nIssues a warning message\nClamps t to the nearest boundary (first or last time point)\nSingle time point: If only one time point exists, returns the corresponding yaw value directly\nError handling: Throws an error if iT is not an integer or vector of integers\n\nData Format\n\nThe con_yaw_data matrix should have the structure:\n\n[time₁  yaw₁₁  yaw₁₂  ...  yaw₁ₙ]\n[time₂  yaw₂₁  yaw₂₂  ...  yaw₂ₙ]\n[  ⋮      ⋮      ⋮    ⋱     ⋮  ]\n[timeₘ  yawₘ₁  yawₘ₂  ...  yawₘₙ]\n\nwhere m is the number of time steps and n is the number of turbines.\n\nExamples\n\n# Example control data: 3 time points, 2 turbines\ncon_yaw_data = [0.0  10.0  5.0;   # t=0s: T1=10°, T2=5°\n                1.0  15.0  10.0;  # t=1s: T1=15°, T2=10°\n                2.0  20.0  15.0]  # t=2s: T1=20°, T2=15°\n\n# Get yaw for turbine 1 at t=0.5s (interpolated)\nyaw1 = getYaw(Yaw_SOWFA(), con_yaw_data, 1, 0.5)  # Returns 12.5°\n\n# Get yaw for multiple turbines at t=1.5s\nyaws = getYaw(Yaw_SOWFA(), con_yaw_data, [1, 2], 1.5)  # Returns [17.5°, 12.5°]\n\n# Out-of-bounds time (will issue warning)\nyaw_oob = getYaw(Yaw_SOWFA(), con_yaw_data, 1, 5.0)  # Returns 20.0° with warning\n\nSee Also\n\nYaw_SOWFA: Controller type for SOWFA-style yaw control\nInterpolations.linear_interpolation: Underlying interpolation method used\n\n\n\n\n\n","category":"function"},{"location":"functions/#Helper-functions","page":"Low-Level Functions","title":"Helper functions","text":"","category":"section"},{"location":"functions/#FLORIDyn.toMSR","page":"Low-Level Functions","title":"FLORIDyn.toMSR","text":"toMSR(s::String)\n\nConverts the input string s to a MSR (Measurement System Representation) enumeration.\n\nSupports the following string formats:\n\nEnum names: \"VelReduction\", \"AddedTurbulence\", \"EffWind\"\nFlow field names: \"flowfieldvelreduction\", \"flowfieldaddedturbulence\", \"flowfieldeffwindspeed\"\nMeasurement names: \"msrvelreduction\", \"msraddedturbulence\", \"msreffwind_speed\"\n\nSee also MSR.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.now_microseconds","page":"Low-Level Functions","title":"FLORIDyn.now_microseconds","text":"now_microseconds()::String\n\nReturns current timestamp as a string with microsecond resolution. Format: \"YYYY-mm-ddTHH-MM-SS.uuuuuu\"\n\nExamples\n\njulia> now_microseconds()\n\"2025-08-08T16-58-55.494911\"\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.now_nanoseconds","page":"Low-Level Functions","title":"FLORIDyn.now_nanoseconds","text":"now_nanoseconds()::String\n\nReturns current timestamp as a string with nanosecond resolution. Format: \"YYYY-mm-ddTHH-MM-SS.nnnnnnnnn\"\n\nExamples\n\njulia> now_nanoseconds()\n\"2025-08-08T16-58-55.494911123\"\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.precise_now","page":"Low-Level Functions","title":"FLORIDyn.precise_now","text":"precise_now()::String\n\nAlias for now_microseconds() - returns current timestamp with microsecond resolution.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.unique_name","page":"Low-Level Functions","title":"FLORIDyn.unique_name","text":"unique_name()::String\n\nCreates a unique directory name for storing simulation results.\n\nThis function generates a unique directory name by combining the prefix \"floridynrun\" with a high-resolution timestamp. The timestamp includes microsecond precision to ensure uniqueness even when multiple simulations are started in quick succession.\n\nReturns\n\nString: A unique directory name in the format \"floridyn_run_YYYY-mm-ddTHH-MM-SS.uuuuuu\"\n\nExamples\n\njulia> unique_name()\n\"floridyn_run_2025-08-08T16-58-55.494911\"\n\njulia> unique_name()\n\"floridyn_run_2025-08-08T16-58-55.495123\"\n\nNotes\n\nThe generated name is suitable for use as a directory name on all operating systems\nUses hyphens instead of colons in the time portion for filesystem compatibility\nMicrosecond precision ensures uniqueness for rapid successive calls\nUsed to create separate output directories for each run\n\nSee Also\n\nnow_microseconds: The underlying timestamp function used\nVis: Visualization settings that may use unique names for output directories\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.isdelftblue","page":"Low-Level Functions","title":"FLORIDyn.isdelftblue","text":"isdelftblue() -> Bool\n\nCheck if the current environment is the Delft Blue supercomputer.\n\nThis function determines whether the code is running on the Delft Blue supercomputer by checking for the existence of the ~/scratch directory, which is a characteristic feature of the Delft Blue file system.\n\nReturns\n\nBool: true if running on Delft Blue (i.e., ~/scratch directory exists),          false otherwise.\n\nUsage\n\nThis function is used throughout FLORIDyn.jl to automatically adapt file paths  to the computing environment. On Delft Blue, output files are stored in the  scratch directory, which can be accessed remotely and offers lots of space.\n\nExample\n\nif isdelftblue()\n    output_path = joinpath(homedir(), \"scratch\", \"out\")\nelse\n    output_path = joinpath(pwd(), \"out\")\nend\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.find_floridyn_runs","page":"Low-Level Functions","title":"FLORIDyn.find_floridyn_runs","text":"find_floridyn_runs(directory::String = pwd())\n\nFind all directories starting with \"floridyn_run\" in the specified directory.\n\nArguments\n\ndirectory::String: Directory to search in (default: current working directory)\n\nReturns\n\nVector{String}: List of full paths to floridyn_run directories, sorted by name\n\nExamples\n\n# Find floridyn_run directories in current directory\ndirs = find_floridyn_runs()\n\n# Find in specific directory\ndirs = find_floridyn_runs(\"out\")\n\n# Count how many exist\ncount = length(find_floridyn_runs())\n\nSee Also\n\ndelete_results: Function that uses this to find directories to delete\nunique_name: Function that creates these directories\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.delete_results","page":"Low-Level Functions","title":"FLORIDyn.delete_results","text":"delete_results(vis::Vis, n::Int=1; dry_run::Bool = false)\n\nDelete the newest n directories starting with \"floridyn_run\" from both the visualization  output directory and video directory.\n\nThis function provides comprehensive cleanup by removing the most recent floridyn_run directories from both output and video paths simultaneously. It's particularly useful for removing failed runs,  test runs, or managing disk space by keeping only the most relevant simulation outputs across both directory types.\n\nArguments\n\nvis::Vis: Visualization settings object containing both output and video path configurations\nn::Int: Number of newest directories to delete from each directory (must be positive, default: 1)  \ndry_run::Bool: Preview mode - shows what would be deleted without actually deleting (default: false)\n\nReturns\n\nVector{String}: Absolute paths of directories that were deleted from both locations combined. Returns empty vector if no matching directories found or if n ≤ 0.\n\nBehavior\n\nDirectory Search: Searches both vis.output_path and vis.video_path for directories matching floridyn_run_* pattern\nDual Cleanup: Operates on both output and video directories in sequence\nSorting: Sorts directories by modification time (newest first) within each directory\nSelection: Selects up to n newest directories for deletion from each location\nDry Run: When dry_run=true, logs what would be deleted but performs no actual deletion\n\nExamples\n\n# Create visualization settings\nvis = Vis(\"data/vis_default.yaml\")\n\n# Delete the single newest floridyn_run directory from both output and video directories\ndeleted = delete_results(vis)\nprintln(\"Deleted: \", length(deleted), \" directories total\")\n\n# Delete the 3 newest floridyn_run directories from each location\ndeleted = delete_results(vis, 3)\nprintln(\"Deleted directories: \", basename.(deleted))\n\nImportant Notes\n\nDual Operation: This function operates on BOTH output and video directories\nIndependent Processing: Each directory is processed separately - n directories from output AND n directories from video\nNon-existent Directories: Silently skips directories that don't exist rather than creating them\n\nSee Also\n\nVis: Visualization settings struct with output and video path configuration\nunique_name(): Creates timestamped floridyn_run directories\nfind_floridyn_runs(): Lists existing floridyn_run directories in a given path\n\n\n\n\n\n","category":"function"},{"location":"developer/#Developer-notes","page":"Developer notes","title":"Developer notes","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"This page contains information for developers who want to contribute to or extend FLORIDyn.jl.","category":"page"},{"location":"developer/#Project-structure","page":"Developer notes","title":"Project structure","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The FLORIDyn.jl package is organized into several modules:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"src/ - Main source code\ncontroller/    - Controller implementations\ncorrection/    - Wake correction models\nfloridyn_cl/   - Main simulation loop\nfloris/        - FLORIS model implementations\nwindfield/     - Wind field modeling\nvisualisation/ - Plotting and helper functions\ntest/ - Test suite\nexamples/ - Example scripts\nexamples_dev/ - Examples for developers\ndocs/  - Documentation source\ndata/  - Example data files and configuration settings\nvideo/ - Intermediate PNG output files\nout/   - Final PNG and MP4 output files, one folder per test run\nbin/   - Bash scripts to start Julia, analyze allocation and statistics","category":"page"},{"location":"developer/#Development-workflow","page":"Developer notes","title":"Development workflow","text":"","category":"section"},{"location":"developer/#Setting-up-the-development-environment","page":"Developer notes","title":"Setting up the development environment","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"On Linux, make sure that Python3 and Matplotlib are installed:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"sudo apt install python3-matplotlib","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Make sure that ControlPlots.jl works as explained here.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Clone the repository:\ngit clone https://github.com/ufechner7/FLORIDyn.jl.git\ncd FLORIDyn.jl\nActivate the project environment and update the packages:\nusing Pkg\nPkg.activate(\".\")\nPkg.up()","category":"page"},{"location":"developer/#Running-tests","page":"Developer notes","title":"Running tests","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To run the full test suite:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"using Pkg\nPkg.test()","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To run specific tests:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"test/test_floris.jl\")","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"You get a menu with the available test sets and benchmarks using:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"test/runtest.jl\")","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Be aware that the tests should be run both single threaded and multithreaded. So for a full test do:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"jl\n]test\nexit()\njl2\n]test\nexit()","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Make sure you have followed the steps in the section The advanced way of the user guide.","category":"page"},{"location":"developer/#Using-Revise","page":"Developer notes","title":"Using Revise","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Using Revise allows you to edit and run code that is part of FLORIDyn.jl without restarting Julia. Limitation before Julia 1.12: If you modify structs, you still have to restart Julia for the changes to become into effect.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To enable Revise type","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"source ./bin/revise_on","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"to disable it","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"source ./bin/revise_off","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Be aware that the environment variable USE_REVISE has only an impact if Julia is launched using jl or jl2.","category":"page"},{"location":"developer/#Debugging","page":"Developer notes","title":"Debugging","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Suggestion: Use Infiltrator.jl for debugging.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Add two lines to your .bashrc script (create one if it does not exist yet):","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"alias jl='./bin/run_julia'\nalias jl2='./bin/run_julia2'","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Install the packages Infiltrator.jl and Revise.jl in your global environment:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"julia -e 'using Pkg; Pkg.add(\"Revise\"); Pkg.add(\"Infiltrator\")'","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Now you can launch Julia by typing jl, and for debugging type jl2.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Debugging session:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"bash> jl2\njulia> using FLORIDyn\nAdd the line Main.@infiltrate at the location where you want to set a break point.\njulia> include(\"examples/main.jl\")","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Now the program should run into your breakpoint. You should see the prompt:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"infil> ","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"and by typing the name of any local or global variable you can inspect the content. You can also execute any statement that fails and modify it until it works.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Important: When executing STEP 2, the line Main.@infiltrate must not exist or must be commented.","category":"page"},{"location":"developer/#Building-documentation","page":"Developer notes","title":"Building documentation","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To build the documentation locally:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"scripts/build_docu.jl\")","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"You can get an overview over the exported methods by running the script:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"scripts/stats.jl\")","category":"page"},{"location":"developer/#Checking-the-memory-allocations","page":"Developer notes","title":"Checking the memory allocations","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"For a good performance, in particular when using multi-threading, the amount of memory allocations should be low. As a general rule, if you use a benchmark script and the time that the garbage collector (GC) needs is less than 10%, that should be good enough.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"For fixing allocations it is most of the time sufficient to fix the most inner functions or loops. To find them, two Bash scripts are provided: test_alloc and analyze_alloc . The second script has an output like this:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"ufechner@ufryzen:~/repos/FLORIDyn.jl/bin$ ./analyze_alloc \nFound 19 .mem files\nAnalyzing memory allocations...\n\n=== TOP 20 MEMORY ALLOCATIONS ===\n\n190.67 MB    ./windfield/windfield_shear.jl.61012:74 shear = z_norm .^ wind_shear.alpha\n93.94 MB     ./floridyn_cl/floridyn_cl.jl.61012:492 runFLORIS!(\n5.57 MB      ./floridyn_cl/floridyn_cl.jl.61012:604 T_addedTI = sqrt(sum(T_aTI_arr .^ 2))\n4.48 MB      ./floridyn_cl/floridyn_cl.jl.61012:681 wf.Weight[iT] = wf.Weight[iT] ./ wS\n3.48 MB      ./visualisation/calc_flowfield.jl.61012:246 GP.posNac[end, :] = [0.0, 0.0, zh] # Update grid point nacelle position\n3.48 MB      ./visualisation/calc_flowfield.jl.61012:245 GP.posBase[end, :] = [xGP, yGP, 0.0] # Update grid point base position\n269.10 KB    ./floridyn_cl/iterate.jl.61012:50 return IterateOPsBuffers(\n168.77 KB    ./settings.jl.61012:654 diff = sum(\n164.61 KB    ./visualisation/plot_flowfield.jl.61012:434 rm(joinpath(\"video\", file))\n128.70 KB    ./floris/gaussian.jl.61012:180 Ct = calcCt(states_t[:, 1], states_t[:, 2])\n127.60 KB    ./floris/gaussian.jl.61012:170 RPs = Matrix{Float64}(undef, n, 3)\n85.78 KB     ./floris/gaussian.jl.61012:181 yaw = -deg2rad.(states_t[:, 2])\n84.46 KB     ./floris/gaussian.jl.61012:264 states_op = copy(wf.States_OP)\n...\n\n=== ALLOCATION SUMMARY BY FILE ===\n\n190.67 MB    1    lines ./windfield/windfield_shear.jl.61012\n103.99 MB    15   lines ./floridyn_cl/floridyn_cl.jl.61012\n6.96 MB      3    lines ./visualisation/calc_flowfield.jl.61012\n980.55 KB    32   lines ./floris/gaussian.jl.61012\n287.91 KB    29   lines ./visualisation/plot_flowfield.jl.61012\n269.10 KB    1    lines ./floridyn_cl/iterate.jl.61012\n191.23 KB    25   lines ./floridyn_cl/prepare_simulation.jl.61012\n190.89 KB    28   lines ./settings.jl.61012\n20.30 KB     20   lines ./FLORIDyn.jl.61012\n...","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"So you can clearly see where the largest allocations happen and refactor those functions or lines.","category":"page"},{"location":"developer/#Code-style-and-conventions","page":"Developer notes","title":"Code style and conventions","text":"","category":"section"},{"location":"developer/#Naming-conventions","page":"Developer notes","title":"Naming conventions","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Use descriptive variable names\nFollow Julia naming conventions (lowercase with underscores for functions and variables)\nType names should use CamelCase\nConstants should be ALL_CAPS","category":"page"},{"location":"developer/#Code-organization","page":"Developer notes","title":"Code organization","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Keep functions focused and small\nUse meaningful docstrings for all exported functions\nInclude type annotations where helpful for clarity\nFollow the existing module structure","category":"page"},{"location":"developer/#Testing","page":"Developer notes","title":"Testing","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Write tests for new functionality\nEnsure all tests pass before submitting pull requests\nInclude edge cases in test coverage\nUse descriptive test names","category":"page"},{"location":"developer/#Contributing","page":"Developer notes","title":"Contributing","text":"","category":"section"},{"location":"developer/#Pull-requests","page":"Developer notes","title":"Pull requests","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Fork the repository\nCreate a feature branch\nMake your changes\nAdd tests for new functionality\nEnsure all tests pass\nUpdate documentation if needed\nSubmit a pull request","category":"page"},{"location":"developer/#Issues","page":"Developer notes","title":"Issues","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"When reporting issues, please include:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Julia version\nFLORIDyn.jl version\nMinimal working example\nError messages and stack traces","category":"page"},{"location":"developer/#Architecture-overview","page":"Developer notes","title":"Architecture overview","text":"","category":"section"},{"location":"developer/#Core-simulation-loop","page":"Developer notes","title":"Core simulation loop","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The main simulation is handled by the floridyn_cl module, which implements the time-stepping algorithm for wake evolution.","category":"page"},{"location":"developer/#Wake-models","page":"Developer notes","title":"Wake models","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The package supports multiple wake models through abstract types:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"VelModel - Velocity deficit models\nDirModel - Wake deflection models\nTurbulenceModel - Turbulence intensity models","category":"page"},{"location":"developer/#Settings-system","page":"Developer notes","title":"Settings system","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Configuration is handled through YAML files that are parsed into Julia structs. See the Settings documentation for details.","category":"page"},{"location":"developer/#Performance-considerations","page":"Developer notes","title":"Performance considerations","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The simulation uses in-place operations where possible to minimize allocations\nKey loops are optimized for performance\nConsider using @profile and BenchmarkTools.jl when optimizing code\nRead the performance tips","category":"page"},{"location":"analysis/#Column-Major-Access-Pattern-Analysis-for-FLORIDyn.jl","page":"-","title":"Column-Major Access Pattern Analysis for FLORIDyn.jl","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Based on my analysis of the src folder, I found several performance-critical patterns that could be slow in Julia due to column-major access:","category":"page"},{"location":"analysis/#**Summary-of-Issues-Found:**","page":"-","title":"Summary of Issues Found:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Column Access Patterns: 52 instances of [:, N] column access patterns\nTranspose Operations: Multiple instances of unnecessary transpose operations\nMemory Layout Issues: Several patterns that fight against Julia's column-major memory layout","category":"page"},{"location":"analysis/#**Major-Performance-Issues-Identified:**","page":"-","title":"Major Performance Issues Identified:","text":"","category":"section"},{"location":"analysis/#1.-**Column-wise-Operations-on-Large-Matrices**","page":"-","title":"1. Column-wise Operations on Large Matrices","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 180, 185, 190)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Column-wise access on potentially large matrices\nwf.States_WF[:, 1] .+= Wind.perturbation.vel_sigma * randn(wf.nOP *wf.nT)\nwf.States_WF[:, 2] .+= Wind.perturbation.dir_sigma * randn(wf.nOP *wf.nT)  \nwf.States_WF[:, 3] .+= Wind.perturbation.ti_sigma * randn(wf.nOP *wf.nT)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: High - These are in perturbationOfTheWF!() which runs every simulation step.","category":"page"},{"location":"analysis/#2.-**Unnecessary-Transpose-Repeat-Operations**","page":"-","title":"2. Unnecessary Transpose + Repeat Operations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 514-516)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Multiple transpose operations with repeat\ntmp_Tpos = repeat(wf.posBase[iT,:]' + wf.posNac[iT,:]', tmp_nT)\ntmp_WF   = repeat(iTWFState', tmp_nT)\ntmp_Tst  = repeat((wf.States_T[wf.StartI[iT], :])', tmp_nT)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Medium-High - In critical simulation loop, causes unnecessary memory allocations.","category":"page"},{"location":"analysis/#3.-**Column-Access-in-Distance-Calculations**","page":"-","title":"3. Column Access in Distance Calculations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 258, 361)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Transpose in distance calculations\ndistOP_iiT = sum((wf.posBase[iiT, 1:2]' .-wf.States_OP[idx_range, 1:2]).^2, dims=2)\ndist = sqrt.(sum((OP_positions' .- turb_pos).^2, dims=2))","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Medium - Called for every turbine pair interaction.","category":"page"},{"location":"analysis/#4.-**Column-wise-Access-in-FLORIS-Calculations**","page":"-","title":"4. Column-wise Access in FLORIS Calculations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: gaussian.jl (Lines 492-493, 499, 501, 528)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Multiple column accesses on rotor point matrices\ncw_y = tmp_RPs[:, 2] .- delta[:, 1]\ncw_z = tmp_RPs[:, 3] .- delta[:, 2]\n# ... and many more column accesses","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: High - Core wake calculation, runs frequently with large rotor point matrices.","category":"page"},{"location":"analysis/#5.-**Data-Loading-Column-Access**","page":"-","title":"5. Data Loading Column Access","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Files: src/windfield/windfield_*.jl (Multiple lines)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Column-wise data access during file reading\ntimes = WindDir[:, 1]\nphis = WindDir[:, 2]\nspeeds = WindVel[:, 2]","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Low-Medium - Mainly during initialization, but still inefficient.","category":"page"},{"location":"analysis/#**Performance-Impact-Assessment:**","page":"-","title":"Performance Impact Assessment:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"High Impact (Critical):\nStates_WF[:, N] operations in perturbationOfTheWF!() - ~15-20% simulation slowdown\nColumn access in gaussian.jl FLORIS calculations - ~10-15% wake calculation slowdown\nMedium Impact (Important):\nTranspose + repeat operations in setUpTmpWFAndRun() - ~5-10% per turbine setup\nDistance calculation transposes - ~5% turbine interaction overhead\nLow Impact (Optimization):\nData loading column access - ~1-2% initialization time","category":"page"},{"location":"analysis/#**Estimated-Total-Performance-Impact:**","page":"-","title":"Estimated Total Performance Impact:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"The column-major access patterns likely cause 20-35% overall performance degradation in the simulation, with the worst impact during:","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Wind field perturbation operations (every time step)\nWake interaction calculations (most computationally intensive part)\nMulti-turbine setup operations (scales with number of turbines)","category":"page"},{"location":"analysis/#**Recommendations-for-Fixes:**","page":"-","title":"Recommendations for Fixes:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Restructure data layout to be row-major for frequently accessed operations\nUse views instead of column slices where possible  \nPre-allocate and reuse temporary arrays instead of transpose operations\nConsider using StaticArrays.jl for small fixed-size operations\nBatch operations to work on contiguous memory when possible","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"The good news is that most of these issues are localized to specific functions and can be fixed systematically without major architectural changes.","category":"page"},{"location":"faq/#Frequently-asked-questions-FAQ","page":"FAQ","title":"Frequently asked questions FAQ","text":"","category":"section"},{"location":"faq/#Why-should-I-use-Julia?","page":"FAQ","title":"Why should I use Julia?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Short answer: Speed (this code is 5-8 times faster than Matlab and 10-50 times faster than Python), which is very useful for example for solving optimization problems. Long answer: Read Why am I using Julia.","category":"page"},{"location":"faq/#How-can-I-start-Julia?","page":"FAQ","title":"How can I start Julia?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"There are different options. Suggested way:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Use a Bash terminal. On Linux this is the default, on Windows Bash is included in Git for Windows. You can launch Bash from VSCode from the menu with View->Terminal. There is a small drop-down menu at the top left of the terminal window where you might have to select Bash if it is not the default.\nBasic method to launch Julia: Type julia --project in the Bash terminal.\nImproved method: Type ./bin/run_julia. This script installs missing packages if needed and loads Revise and FLORIDyn.\nExpert method: Add the line alias jl='bin/run_julia' to your .bashrc file. Now you can start Julia by just typing jl.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Do NOT use the run button from VSCode to run Julia.","category":"page"},{"location":"faq/#Where-can-I-find-Julia-packages?","page":"FAQ","title":"Where can I find Julia packages?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you need extra packages to solve your tasks, look at: https://juliahub.com/ui/Packages . They have a good search function. Don't ask AI, they often suggest outdated packages. If there are multiple packages for your problem, you can also ask on Discourse for suggestions.","category":"page"},{"location":"faq/#What-is-a-Julia-environment?","page":"FAQ","title":"What is a Julia environment?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A Julia environment is a folder that contains a Project.toml and a Manifest.toml file. The Project.toml contains a list of the packages that are needed to run your code. It can also contain a list of the compatible package versions and more. It is important to use separate projects for each of your pieces of software that you develop, if you are not doing that (and use only the global environment), the things will break after some time. Further reading: Working with Julia projects.","category":"page"},{"location":"faq/#What-should-be-in-the-global-environment?","page":"FAQ","title":"What should be in the global environment?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Start Julia with julia. On my PC I have:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> using Pkg; Pkg.status()\nStatus `~/.julia/environments/v1.11/Project.toml`\n  [23c2ee80] ControlPlots v0.2.7\n  [5903a43b] Infiltrator v1.9.2\n  [16fef848] LiveServer v1.5.0\n  [295af30f] Revise v3.8.1\n  [0c614874] TerminalPager v0.6.4\n  [1e6cf692] TestEnv v1.102.1\n  [21f18d07] Timers v0.1.5","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can have a few more packages in there. But if you have 20 packages in your global environment you did something wrong.","category":"page"},{"location":"faq/#What-should-be-in-my-project-environment?","page":"FAQ","title":"What should be in my project environment?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you followed the developer guide and launched Julia with jl or julia --project, you should see something like:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> using Pkg; Pkg.status()\nProject FLORIDyn v0.1.0\nStatus `~/repos/FLORIDyn.jl/Project.toml`\n  [336ed68f] CSV v0.10.15\n  [a93c6f00] DataFrames v1.7.0\n  [8bb1440f] DelimitedFiles v1.9.1\n  [ffbed154] DocStringExtensions v0.9.5\n  [a98d9a8b] Interpolations v0.16.1\n  [033835bb] JLD2 v0.5.15\n  [b964fa9f] LaTeXStrings v1.4.0\n  [d96e819e] Parameters v0.12.3\n⌅ [aea7be01] PrecompileTools v1.2.1\n  [90137ffa] StaticArrays v1.9.14\n  [10745b16] Statistics v1.11.1\n  [7c3b921d] StructMapping v0.2.3\n  [ddb6d928] YAML v0.4.14\n  [37e2e46d] LinearAlgebra v1.11.0\n  [56ddb016] Logging v1.11.0\n  [44cfe95a] Pkg v1.11.0\n  [9a3f8284] Random v1.11.0\nInfo Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated`","category":"page"},{"location":"faq/#Which-operating-systems-are-supported?","page":"FAQ","title":"Which operating systems are supported?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Linux, Windows and Mac are supported. In some of the examples you might have to replace / with \\\\ on Windows. If you still have a problem, create an issue on https://github.com/ufechner7/FLORIDyn.jl/issues.","category":"page"},{"location":"faq/#How-to-create-a-new-simulation?","page":"FAQ","title":"How to create a new simulation?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"in the folder data, copy 2021_9T_Data.yaml to a new file in the same folder. \ncopy the subfolder 2021_9T_Data with the .csv files to a new folder with the same name as your new .yaml file (but without the suffix .yaml)\ncopy the file examples/main.jl to a new file\nedit the line settings_file = \"data/2021_9T_Data.yaml\" to match the name of your new configuration file\nedit the new input files to match your test case\nrun your new example using \"include(\"examples/<new_main.jl>\")\"","category":"page"},{"location":"faq/#Can-I-use-other-plotting-packages?","page":"FAQ","title":"Can I use other plotting packages?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ControlPlots.jl is an easy-to-use, powerful plotting package, suitable for teaching. Furthermore it is based on Matplotlib, so you can leverage your knowledge of Matplotlib if you have used Python before. ControlPlots.jl exports the variable plt, and you can use any Matplotlib command by using the prefix plt.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can use other plotting packages, but then you have to adapt the plotting scripts that can be found here yourself. Pull requests to support other plotting packages like Plots.jl or Makie.jl are welcome.","category":"page"},{"location":"faq/#Can-I-use-this-package-with-Python?","page":"FAQ","title":"Can I use this package with Python?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can easily use Python packages in your own Julia project. I would suggest PyCall.jl to do that. You can use Conda.jl to install the required Python packages. They become part of your Julia environment and can be managed by the Julia package manager.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The other way, to use FLORIDyn.jl from Python is - in theory - possible using PythonCall.jl. This was not yet tested. ","category":"page"},{"location":"faq/#I-have-a-Problem.-Where-can-I-get-help?","page":"FAQ","title":"I have a Problem. Where can I get help?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Ask your question at Discourse. Most of the times you will get an answer in 15 min. Half of the people who answer are scientists.","category":"page"},{"location":"video_creation/#Video-Creation-from-Simulation-Plots","page":"Video Creation","title":"Video Creation from Simulation Plots","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"This document describes how to create videos from saved FLORIDyn simulation plots.","category":"page"},{"location":"video_creation/#Overview","page":"Video Creation","title":"Overview","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"FLORIDyn.jl now includes functionality to automatically convert series of PNG plot files into MP4 videos. This is particularly useful for creating animations of flow field evolution over time.","category":"page"},{"location":"video_creation/#Prerequisites","page":"Video Creation","title":"Prerequisites","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"FFmpeg: Must be installed and available in your system PATH\nUbuntu/Debian: sudo apt install ffmpeg\nMacOS: brew install ffmpeg\nWindows: Download from https://ffmpeg.org/","category":"page"},{"location":"video_creation/#Basic-Usage","page":"Video Creation","title":"Basic Usage","text":"","category":"section"},{"location":"video_creation/#1.-Generate-Plot-Frames","page":"Video Creation","title":"1. Generate Plot Frames","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"First, run your simulation with vis.save=true to save plot frames:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"using FLORIDyn\n\n# Enable plot saving\nvis = Vis(online=true, save=true, rel_v_min=20.0, up_int=12)\n\n# Run simulation - this will save frames to the 'video/' folder\nwf, md, mi = runFLORIDyn(plt, set, wf, wind, sim, con, vis, floridyn, floris)","category":"page"},{"location":"video_creation/#2.-Create-Videos","page":"Video Creation","title":"2. Create Videos","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Create videos from the saved frames:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"# Create video from velocity reduction frames\nvideo_path = createVideo(\"velocity_reduction\"; fps=4)\n\n# Custom video creation with options\ncustom_video = createVideo(\"wind_speed\"; \n                          video_dir=\"video\", \n                          output_dir=\"animations\", \n                          fps=8, \n                          delete_frames=true)","category":"page"},{"location":"video_creation/#Functions","page":"Video Creation","title":"Functions","text":"","category":"section"},{"location":"video_creation/#createVideo(prefix;-kwargs...)","page":"Video Creation","title":"createVideo(prefix; kwargs...)","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Convert PNG files starting with a given prefix into an MP4 video.","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Arguments:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"prefix::String: Prefix of PNG files to include (e.g., \"velocity_reduction\")\nvideo_dir::String: Input directory (default: \"video\")\noutput_dir::String: Output directory (default: \"video\") \nfps::Int: Frames per second (default: 2)\ndelete_frames::Bool: Delete PNG files after creating video (default: false)","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Returns: Path to created video file, or empty string if failed","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Supported prefixes:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"\"velocity_reduction\" - Velocity reduction animations\n\"added_turbulence\" - Added turbulence animations  \n\"wind_speed\" - Wind speed animations","category":"page"},{"location":"video_creation/#File-Naming-Convention","page":"Video Creation","title":"File Naming Convention","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"The video creation functions expect PNG files to follow this naming pattern:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"velocity_reduction_t0000s.png\nvelocity_reduction_t0012s.png\nwind_speed_t0024s.png\netc.","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Output videos are named:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"velocity_reduction_animation.mp4\nadded_turbulence_animation.mp4\nwind_speed_animation.mp4","category":"page"},{"location":"video_creation/#Tips","page":"Video Creation","title":"Tips","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Frame Rate: Start with low FPS (2-4) for overview videos, use higher FPS (8-12) for detailed analysis\nStorage: Use delete_frames=true to save disk space after video creation\nQuality: Videos are created with good quality settings (CRF 23) suitable for presentations\nTroubleshooting: If video creation fails, check that FFmpeg is installed and PNG files exist","category":"page"},{"location":"video_creation/#Integration-with-main.jl","page":"Video Creation","title":"Integration with main.jl","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"The example main.jl includes video creation as PLT option 7:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"# Set PLT=7 to create videos from saved frames\nPLT = 7\ninclude(\"examples/main.jl\")","category":"page"},{"location":"user_guide/#User-guide","page":"User Guide","title":"User guide","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"This page contains information for users of FLORIDyn.jl.","category":"page"},{"location":"user_guide/#Installation-of-FLORIDyn","page":"User Guide","title":"Installation of FLORIDyn","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"How to install FLORIDyn is explained in the section Installation.","category":"page"},{"location":"user_guide/#Launching-Julia","page":"User Guide","title":"Launching Julia","text":"","category":"section"},{"location":"user_guide/#Launching-Julia-in-the-global-environment","page":"User Guide","title":"Launching Julia in the global environment","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"Just type julia. ","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.11.6 (2025-07-09)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> ","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"If you now type ] and then st you can see the name of the environment and which packages it contains:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"(@v1.11) pkg> st\nStatus `~/.julia/environments/v1.11/Project.toml`\n  [23c2ee80] ControlPlots v0.2.7\n  [fab6aee4] DistributedNext v1.1.0\n  [5903a43b] Infiltrator v1.9.2\n  [16fef848] LiveServer v1.5.0\n  [5f6e1e16] LocalCoverage v0.8.3\n  [295af30f] Revise v3.8.1\n  [0c614874] TerminalPager v0.6.4\n  [1e6cf692] TestEnv v1.102.1\n  [21f18d07] Timers v0.1.5","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"If there are unused packages in your global environment, then remove them by typing rm <PACKAGE_NAME>, if packages are outdated update them with up. You can leave the package manager mode by typing <BACK> and quit Julia by typing <CTRL>+<D>.","category":"page"},{"location":"user_guide/#Launching-Julia-in-the-local-environment","page":"User Guide","title":"Launching Julia in the local environment","text":"","category":"section"},{"location":"user_guide/#The-standard-way","page":"User Guide","title":"The standard way","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"Launch a terminal in the correct folder, and then type julia --project. If you now enter the package manager mode with ], you should see:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"(FLORIDyn) pkg> st\nProject FLORIDyn v0.1.0\nStatus `~/repos/FLORIDyn.jl/Project.toml`\n  [336ed68f] CSV v0.10.15\n  [a93c6f00] DataFrames v1.7.0\n  [8bb1440f] DelimitedFiles v1.9.1\n  [fab6aee4] DistributedNext v1.1.0\n  [ffbed154] DocStringExtensions v0.9.5\n  [a98d9a8b] Interpolations v0.16.1\n  [033835bb] JLD2 v0.5.15\n  [b964fa9f] LaTeXStrings v1.4.0\n  [d96e819e] Parameters v0.12.3\n⌅ [aea7be01] PrecompileTools v1.2.1\n  [90137ffa] StaticArrays v1.9.14\n  [10745b16] Statistics v1.11.1\n  [7c3b921d] StructMapping v0.2.3\n  [ddb6d928] YAML v0.4.14\n  [37e2e46d] LinearAlgebra v1.11.0\n  [56ddb016] Logging v1.11.0\n  [44cfe95a] Pkg v1.11.0\n  [de0858da] Printf v1.11.0\n  [9a3f8284] Random v1.11.0\nInfo Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated`","category":"page"},{"location":"user_guide/#The-advanced-way","page":"User Guide","title":"The advanced way","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"It is faster and gives better results if you start Julia using a script. Currently, two user scripts are provided:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"The script ./bin/run_julia checks for missing dependencies and starts Julia with 11 threads. Adapt the script such that this number matches the number of fast cores of your CPU.\nThe script ./bin/run_julia2 checks for missing dependencies and starts Julia with one thread.","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"To make these scripts easier to use, you can create bash aliases. ","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"On Linux or Windows: Add the following lines to your ~/.bashrc file:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"alias jl='./bin/run_julia'\nalias jl2='./bin/run_julia2'","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"After adding these aliases, reload your bash configuration:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"source ~/.bashrc","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"On Mac: Add the following lines to your ~/.zshrc file (for zsh, which is the default shell on modern macOS) or ~/.bash_profile file (for bash):","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"alias jl='./bin/run_julia'\nalias jl2='./bin/run_julia2'","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"After adding these aliases, reload your shell configuration:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"source ~/.zshrc    # for zsh\n# or\nsource ~/.bash_profile    # for bash","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"Now you can launch Julia with multithreading by simply typing jl or with single threading by typing jl2.","category":"page"},{"location":"user_guide/#Multithreading","page":"User Guide","title":"Multithreading","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"Modern CPUs can have many cores. Threading is one way to split calculations so that they are calculated in parallel on multiple cores. In Julia, the @threads macro can be used in front of a for loop to do calculations in parallel. This only works if the iterations are independent of each other, it will not work if iteration n+1 depends on results calculated by iteration n. Threads - in contrast to processes - share the same memory. If the input data is immutable and accessed in a read only way, the threads can use the same input data. Each thread needs its own buffer for mutable data. If each thread writes to a unique, non-overlapping portion of an output array,  this operation is thread-safe and does not require locks or other synchronization mechanisms.","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"If the functions that are executed in parallel allocate memory, then the pressure on the garbage collector increases with the number of threads. This creates a practical limit for the number of threads that can be used in one process, unless the parallel code is allocation free.","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"In this simulation software, currently only the function getMeasurements uses multithreading. It can increase  the performance of the simulation with flow field calculation by a factor of four to five.","category":"page"},{"location":"user_guide/#Multitasking","page":"User Guide","title":"Multitasking","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"Running a simulation with online visualization is problematic, because firstly updating the GUI costs time,  and secondly the currently used visualization library is not thread safe. Therefore we use a second process for visualization. The second process is started at the beginning, which increases the time-to-first-plot by about five seconds. The line @spawnat 2 Main.rmt_plot_flow_field(wf, X, Y, Z, vis; msr=msr) calls the remote plotting function on the second process and transfers the required data. This is safe and very fast.","category":"page"},{"location":"user_guide/#Running-the-examples","page":"User Guide","title":"Running the examples","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"To run the examples, launch Julia with one of the start scripts and then type menu(). You should see:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"julia> menu()\n\nChoose function to execute or `q` to quit:\n > select_project();                  print(CLEAR_SCR)\n   select_measurement();              print(CLEAR_SCR)\n   \"plot_flow_field\";                 PLT=1; include(\"main.jl\")\n   \"plot_measurements\";               = PLT=4; include(\"main.jl\")\n   \"plot_measurements_lineplot\";      = PLT=5; include(\"main.jl\")\n   \"flow_field_vel_reduction_online\"; = PLT=6; include(\"main.jl\")\n   \"create_video_from_saved_frames\";  = PLT=7; include(\"main.jl\")\n   \"run_all_visualisations\";          include(\"main_all.jl\")\n   \"read_results\";                    include(\"read_results.jl\")\n   \"plot_wind_direction\";             include(\"plot_wind_dir.jl\")\n   \"play_videos\";                     = include(\"play_video.jl\")\n   open_documentation()\n   quit","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"or similar. First, select a project and a measurement by choosing the first menu entries. Then, you can show any of the visualizations by selecting one of them with the cursor keys and then pressing <ENTER>. There might be additional examples that are not yet integrated in the menu. You can execute them with include(\"examples/<MY_EXAMPLE.jl>\"). Some examples require that Julia runs in single-threaded mode. If you want to run such an example, start Julia with jl2.","category":"page"},{"location":"user_guide/#Running-a-custom-simulation","page":"User Guide","title":"Running a custom simulation","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"To run your own simulation you need to follow these steps:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"Create a copy of an existing YAML files in the data folder. Give them a good name. The file turbine-specs.yaml does not have to be copied. If you need additional turbine definitions, just add them to this file.\nModify the custom YAML file according to your needs, following the comments in the YAML file.\nCreate a subfolder with the name of the custom YAML file and copy all required CSV files.\nUpdate/ generate the CSV files according to your needs.\nCopy the script main_mini.jl and adapt it according to your needs.\nRun your new script using the command include(\"examples/<my_script.jl>\")","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Basic-example","page":"Examples","title":"Basic example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example uses 9 turbines in a 3x3 configuration. It is used for verification purposes. One of the three flow field visualisations is the turbulence animation, showed here:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<style> .video-container2 {\n  position: relative;\n  width: 510px;\n  max-width: 100%;\n  aspect-ratio: 510 / 436; /* width / height */\n  overflow: hidden;\n  margin: 0 auto;\n} .responsive-iframe2 { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; clip-path: inset(7px 1px 7px 1px);} </style> <div class=\"video-container2\"> <iframe src=\"https://www.dropbox.com/scl/fi/e5uonvron9eoa1vupsxgm/ff_added_turbulence_animation.mp4?rlkey=nk1fgm9d2xwurdldycwa8ih9w&st=2s7c2sm3&raw=1\" class=\"responsive-iframe2\" allowfullscreen frameborder=\"0\"></iframe> </div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The configuration file is 2021_9T_Data.yaml in the data folder.","category":"page"},{"location":"examples/#Nordsee-One","page":"Examples","title":"Nordsee One","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Below is the wind farm layout used in the Nordsee One example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Windfarm layout: Nordsee One)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Source: https://www.nordseeone.com/windfarm","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The configuration file is 2021_54T_NordseeOne.yaml in the data folder.","category":"page"},{"location":"examples/#Velocity-reduction-visualization","page":"Examples","title":"Velocity reduction visualization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following video shows the velocity reduction field produced by the example workflow (first selecting the second project using the first menu entry, then selecting the second menu entry):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<video\n  src=\"https://www.dropbox.com/scl/fi/ckfdr9ap6hdfgxkpz36jd/ff_velocity_reduction_animation.mp4?rlkey=kgbxb9pvhx997c3b4vgytc8lf&st=ijcbs1xt&raw=1\"\n  controls\n  playsinline\n  preload=\"metadata\"\n  style=\"display:block;max-width:100%;height:auto;margin:0 auto;background:#000;\"\n></video>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example assumes an inflow with constant wind speed and no turbulence. The wind direction changes during the simulation from 255° to 195°. The windfield was simulated for 20 minutes, while running the simulation on a laptop with an 7840U CPU took only 1.56s (without visualization). The wind direction is the direction where the wind is coming from, clockwise positive, with 0° defined as wind from the North.","category":"page"},{"location":"#FLORIDyn","page":"Home","title":"FLORIDyn","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A dynamic wind farm simulation software, translated from FLORIDyn_Matlab, which was written by Marcus Becker. The code uses the Gaussian wake model derived in [3].","category":"page"},{"location":"#Model-features","page":"Home","title":"Model features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulate wind farms dynamically at a low computational cost\nEstimate the power generated, added turbulence, and wake-induced losses.\nApply heterogeneous and time-varying wind speeds and directions\nTest different modeling approaches","category":"page"},{"location":"","page":"Home","title":"Home","text":"<style> .video-container {\n  position: relative;\n  width: 510px;\n  max-width: 100%;\n  aspect-ratio: 510 / 436; /* width / height */\n  overflow: hidden;\n  margin: 0 auto;\n} .responsive-iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; clip-path: inset(1px 1px 1px 1px);} </style> <div class=\"video-container\"> <iframe src=\"https://www.dropbox.com/scl/fi/85ujwjfcjtg6hcanhkhso/ff_wind_speed_animation.mp4?rlkey=97srxqybootd5f0exkdbmnv4s&st=boe1fhtk&raw=1\" class=\"responsive-iframe\" allowfullscreen frameborder=\"0\"></iframe> </div>","category":"page"},{"location":"#Status","page":"Home","title":"Status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All examples work, most key examples are selectable via a menu:","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"examples/menu.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The other examples can be executed directly using the include statement. Often, more than 30x the performance of the Matlab version can be achieved. Currently, only IterateOPs_basic is implemented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Python version of FLORIDyn is available at https://github.com/TUDelft-DataDrivenControl/OFF .","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia 1.11, if you haven't already. Julia 1.10 is still supported. On Linux, make sure that Python3 and Matplotlib are installed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sudo apt install python3-matplotlib","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make sure that ControlPlots.jl works as explained here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Before installing this software it is suggested to create a new project, for example like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mkdir test\ncd test\njulia --project=.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Don't forget to type the dot at the end of the last command.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then add FLORIDyn from  Julia's package manager, by typing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add https://github.com/ufechner7/FLORIDyn.jl\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"at the Julia prompt. You can run the unit tests with the command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg\"test FLORIDyn\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can install the examples using the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FLORIDyn\ninstall_examples()","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you now quit Julia with <ctrl><d> and restart it with","category":"page"},{"location":"","page":"Home","title":"Home","text":"./bin/run_julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"then you can get the example menu by typing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"menu()","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can select any of the examples with the <UP> and <DOWN> keys, and then press <ENTER>.","category":"page"},{"location":"#Installation-using-GIT","page":"Home","title":"Installation using GIT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For developers, follow the developer notes.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Citation of the FLORIDyn model:\n[1] FLORIDyn - A dynamic and flexible framework for real-time wind farm control, M. Becker, D. Allaerts, J.W. van Wingerden, 2022, DOI 10.1088/1742-6596/2265/3/032103","category":"page"},{"location":"","page":"Home","title":"Home","text":"Used FLORIS model:\n[2] Experimental and theoretical study of wind turbine wakes in yawed conditions, M. Bastankhah, F. Porté-Agel, 2020, DOI 10.1017/jfm.2016.595","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gaussian wake model:\n[3] Experimental and theoretical study of wind turbine wakes in yawed conditions\", M. Bastankhah, F. Porté-Agel, 2016, Journal of Fluid Mechanics. 2016;806:506-541. DOI 10.1017/jfm.2016.595","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional references for smaller subcomponents can be found in the code or in the related publications.","category":"page"},{"location":"types/#Exported-Types","page":"Exported Types","title":"Exported Types","text":"","category":"section"},{"location":"types/#The-Wind-Farm-Simulation-struct","page":"Exported Types","title":"The Wind Farm Simulation struct","text":"","category":"section"},{"location":"types/#FLORIDyn.WindFarm","page":"Exported Types","title":"FLORIDyn.WindFarm","text":"WindFarm\n\nA mutable struct representing a wind farm. Fields can be specified using keyword arguments.\n\nThis struct supports convenient DataFrame access through property syntax:\n\nwf.turbines: Returns a DataFrame with turbine state data (columns: turbine state names)\nwf.windfield: Returns a DataFrame with wind field data (columns: wind field variables)  \nwf.ops: Returns a DataFrame with operating point data (columns: operating point variables)\n\nFields\n\nnT::Int64: Number of turbines\nnOP::Int64: Number of operating points\nStates_WF::Matrix{Float64}: States of the wind farm (states × wind field variables)\nStates_OP::Matrix{Float64}: States of the operating points (states × operating point variables)\nStates_T::Matrix{Float64}: States of the turbines (states × turbines variables)\nposBase::Matrix{Float64}: Base positions of the turbines (2 × nT matrix: [x-coords; y-coords])\nposNac::Matrix{Float64}: Positions of the nacelles\nD::Vector{Float64}: Diameters of the turbines\nStartI::Matrix{Int}: Start indices for each turbine\nintOPs::Vector{Matrix{Float64}}: Interpolated operating points\nWeight::Vector{Vector{Float64}}: Weights for the operating points\ndep::Vector{Vector{Int}}: Dependencies between turbines\nred_arr::Matrix{Float64}: Reduced array for each turbine\nNames_T::Vector{String}: Names of the turbine state variables\nNames_WF::Vector{String}: Names of the wind field variables\nNames_OP::Vector{String}: Names of the operating point variables\n\nExamples\n\n# Create a wind farm\nwf = WindFarm(nT=3, nOP=100, ...)\n\n# Access data as DataFrames\nturbine_data = wf.turbines      # DataFrame with turbine states\nwindfield_data = wf.windfield   # DataFrame with wind field states\nops_data = wf.ops               # DataFrame with operating point states\n\n\n\n\n\n","category":"type"},{"location":"types/#Abstract-types","page":"Exported Types","title":"Abstract types","text":"","category":"section"},{"location":"types/#FLORIDyn.VelModel","page":"Exported Types","title":"FLORIDyn.VelModel","text":"VelModel\n\nAbstract type representing a velocity model in the wind field module. Subtypes of VelModel implement specific velocity field representations or models.\n\nSee also: \n\nDefining the wind velocity model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.DirModel","page":"Exported Types","title":"FLORIDyn.DirModel","text":"DirModel\n\nAn abstract type representing a directional wind field model.  Subtypes of DirModel should implement specific models for wind directionality.\n\nSee: Defining the wind direction model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.ShearModel","page":"Exported Types","title":"FLORIDyn.ShearModel","text":"ShearModel\n\nAn abstract type representing a wind shear model for vertical wind profiles. Subtypes of ShearModel should implement specific models for wind shear calculations.\n\nSee: Defining the wind shear model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TurbulenceModel","page":"Exported Types","title":"FLORIDyn.TurbulenceModel","text":"TurbulenceModel\n\nAn abstract type representing a turbulence model for wind field calculations. Subtypes of TurbulenceModel should implement specific models for wind turbulence intensity.\n\nSee: Defining the wind turbulence model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.VelCorrection","page":"Exported Types","title":"FLORIDyn.VelCorrection","text":"VelCorrection\n\nAn abstract type representing a velocity correction model for wind field adjustments. Subtypes of VelCorrection should implement specific correction methods for wind velocity.\n\nSee: Defining the velocity correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.DirCorrection","page":"Exported Types","title":"FLORIDyn.DirCorrection","text":"DirCorrection\n\nAn abstract type representing a direction correction model for wind field adjustments. Subtypes of DirCorrection should implement specific correction methods for wind direction.\n\nSee: Defining the direction correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TurbulenceCorrection","page":"Exported Types","title":"FLORIDyn.TurbulenceCorrection","text":"TurbulenceCorrection\n\nAn abstract type representing a turbulence correction model for wind field adjustments. Subtypes of TurbulenceCorrection should implement specific correction methods for turbulence intensity.\n\nSee: Defining the turbulence correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_model","page":"Exported Types","title":"FLORIDyn.IterateOPs_model","text":"IterateOPs_model\n\nAbstract supertype for all observation point iteration algorithms in FLORIDyn.\n\nThis abstract type defines the interface for different strategies used to advance  observation points through the wind field during time-stepping simulations. All  concrete iteration models must be subtypes of this abstract type.\n\nPurpose\n\nThe iteration models determine how observation points (OPs) move through space  and time, affecting:\n\nWake propagation dynamics\nSpatial discretization accuracy\nComputational efficiency\nPhysical representation of wind farm interactions\n\nImplementation\n\nConcrete subtypes implement specific iteration strategies through method dispatch  on functions like iterateOPs!. Each model represents a different  approach to handling the temporal and spatial evolution of observation points.\n\nAvailable Models\n\nIterateOPs_basic: Basic time-stepping with simple advection\nIterateOPs_average: Averaged dynamics for stability\nIterateOPs_buffer: Buffered approach for memory efficiency\nIterateOPs_maximum: Maximum value-based iteration\nIterateOPs_weighted: Weighted interpolation method\n\nWARNING\n\nCurrently, only IterateOPs_basic is fully implemented and tested.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.ControllerModel","page":"Exported Types","title":"FLORIDyn.ControllerModel","text":"ControllerModel\n\nAn abstract type representing a controller model for wind turbines. Subtypes of ControllerModel should implement specific control strategies for turbine operation.\n\nSee: Defining the controller for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-velocity-model","page":"Exported Types","title":"Defining the wind velocity model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind velocity. They are all subtypes of VelModel","category":"page"},{"location":"types/#FLORIDyn.Velocity_Constant","page":"Exported Types","title":"FLORIDyn.Velocity_Constant","text":"Velocity_Constant <: VelModel\n\nA velocity model representing a constant wind velocity field. This struct is used as a type marker  to indicate that the wind velocity does not vary in space or time.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Constant_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_Constant_wErrorCov","text":"Velocity_Constant_wErrorCov <: VelModel\n\nA velocity model representing a constant wind field with associated  error covariance. This struct is a subtype of VelModel and is used  to model wind velocity with an constant value and an error covariance  for uncertainty quantification.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Velocity_EnKF_InterpTurbine","text":"Velocity_EnKF_InterpTurbine <: VelModel\n\nA velocity model type representing an interpolated turbine velocity field using the  Ensemble Kalman Filter (EnKF) approach.\n\nDescription\n\nThis struct is used within the wind field modeling framework to represent the velocity at a turbine location,  where the velocity is estimated or interpolated using EnKF-based techniques.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_I_and_I","page":"Exported Types","title":"FLORIDyn.Velocity_I_and_I","text":"Velocity_I_and_I <: VelModel\n\nA velocity model implementing an interpolation and integration approach for wind velocity estimation.\n\nDescription\n\nThis struct represents a velocity model that combines interpolation techniques with integration methods  to estimate wind velocity fields, typically used for advanced wind field reconstruction scenarios.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\nWARNING\n\nThis model is not yet implemented!\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Interpolation","page":"Exported Types","title":"FLORIDyn.Velocity_Interpolation","text":"Velocity_Interpolation <: VelModel\n\nA velocity model that uses spatial interpolation techniques to estimate wind velocity fields.\n\nDescription\n\nThis struct represents a velocity model that employs interpolation methods to determine wind velocities  at arbitrary spatial locations based on available measurement data or model predictions.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Interpolation_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_Interpolation_wErrorCov","text":"Velocity_Interpolation_wErrorCov <: VelModel\n\nA velocity model that uses spatial interpolation with associated error covariance information.\n\nDescription\n\nThis struct represents a velocity model that employs interpolation methods to determine wind velocities  and includes error covariance matrices for uncertainty quantification and probabilistic analysis.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Velocity_InterpTurbine","text":"Velocity_InterpTurbine <: VelModel\n\nA velocity model for interpolating wind velocities specifically at turbine locations.\n\nDescription\n\nThis struct represents a velocity model that focuses on estimating wind velocities at turbine hub heights  and rotor positions using interpolation techniques from surrounding measurement points or model data.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_InterpTurbine_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_InterpTurbine_wErrorCov","text":"Velocity_InterpTurbine_wErrorCov <: VelModel\n\nA velocity model for interpolating wind velocities at turbine locations with error covariance information.\n\nDescription\n\nThis struct represents a velocity model that estimates wind velocities at turbine positions using  interpolation techniques and includes associated error covariance matrices for uncertainty analysis  and robust wind farm control applications.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_RW_with_Mean","page":"Exported Types","title":"FLORIDyn.Velocity_RW_with_Mean","text":"Velocity_RW_with_Mean <: VelModel\n\nA velocity model implementing a random walk process with a mean trend component.\n\nDescription\n\nThis struct represents a velocity model that combines a random walk stochastic process with a  deterministic mean component, typically used for modeling wind velocity evolution over time  with both predictable trends and random fluctuations.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\nWARNING\n\nThis model is not yet implemented!\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_ZOH_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_ZOH_wErrorCov","text":"Velocity_ZOH_wErrorCov <: VelModel\n\nA velocity model using Zero-Order Hold (ZOH) interpolation with error covariance information.\n\nDescription\n\nThis struct represents a velocity model that employs zero-order hold interpolation (piecewise constant)  for wind velocity estimation between measurement points, and includes error covariance matrices for  uncertainty quantification and statistical analysis.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-direction-model","page":"Exported Types","title":"Defining the wind direction model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind direction. They are all subtypes of DirModel","category":"page"},{"location":"types/#FLORIDyn.Direction_Constant","page":"Exported Types","title":"FLORIDyn.Direction_Constant","text":"Direction_Constant <: DirModel\n\nA marker struct used to represent a constant wind direction.\n\nExample:\n\ndir_mode = Direction_constant()\nphi = getWindDirT(dir_mode, 270, [1,2,3], nothing)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Constant_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_Constant_wErrorCov","text":"Direction_Constant_wErrorCov <: DirModel\n\nA marker struct used to indicate a wind direction that is constant with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Direction_EnKF_InterpTurbine","text":"Direction_EnKF_InterpTurbine <: DirModel\n\nA marker struct used to indicate the use of direction-aware Ensemble Kalman Filter (EnKF) interpolation for turbine modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Interpolation","page":"Exported Types","title":"FLORIDyn.Direction_Interpolation","text":"Direction_Interpolation <: DirModel\n\nA marker struct used to represent direction interpolation functionality within the FLORIDyn framework.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Interpolation_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_Interpolation_wErrorCov","text":"Direction_Interpolation_wErrorCov <: DirModel\n\nA marker struct representing a direction interpolation method with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Direction_InterpTurbine","text":"Direction_InterpTurbine <: DirModel\n\nA marker struct used to indicate direction interpolation for turbines.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_InterpTurbine_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_InterpTurbine_wErrorCov","text":"Direction_InterpTurbine_wErrorCov <: DirModel\n\nA marker struct used to indicate the use of direction interpolation for turbines with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_RW_with_Mean","page":"Exported Types","title":"FLORIDyn.Direction_RW_with_Mean","text":"Direction_RW_with_Mean <: DirModel\n\nA marker struct used to indicate the use of a random walk direction model with a mean component.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-shear-model","page":"Exported Types","title":"Defining the wind shear model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind shear.","category":"page"},{"location":"types/#FLORIDyn.Shear_Interpolation","page":"Exported Types","title":"FLORIDyn.Shear_Interpolation","text":"Shear_Interpolation <: ShearModel\n\nA marker struct used to represent the linear interpolation for wind shear profiles.\n\nSee also\n\nShear_PowerLaw\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Shear_PowerLaw","page":"Exported Types","title":"FLORIDyn.Shear_PowerLaw","text":"Shear_PowerLaw <: ShearModel\n\nA marker struct representing the logarithmic law for modeling wind shear profiles.\n\nSee also\n\nShear_Interpolation\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-turbulence-model","page":"Exported Types","title":"Defining the wind turbulence model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind turbulence.","category":"page"},{"location":"types/#FLORIDyn.TI_Constant","page":"Exported Types","title":"FLORIDyn.TI_Constant","text":"TI_Constant <: TurbulenceModel\n\nA marker struct representing a constant turbulence intensity. \n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.TI_EnKF_InterpTurbine","text":"TI_EnKF_InterpTurbine <: TurbulenceModel\n\nA marker struct representing the Turbulence Intensity (TI) Ensemble Kalman Filter (EnKF) interpolation model.\n\nWARNING\n\nThis model is not yet implemented!\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_Interpolation","page":"Exported Types","title":"FLORIDyn.TI_Interpolation","text":"TI_Interpolation <: TurbulenceModel\n\nA marker struct representing the interpolation method for modeling the turbulence.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_InterpTurbine","page":"Exported Types","title":"FLORIDyn.TI_InterpTurbine","text":"TI_InterpTurbine <: TurbulenceModel\n\nA marker struct representing an interpolated turbine model for turbulence intensity calculations.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-velocity-correction","page":"Exported Types","title":"Defining the velocity correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct wind velocity. They are all subtypes of VelCorrection","category":"page"},{"location":"types/#FLORIDyn.Velocity_Influence","page":"Exported Types","title":"FLORIDyn.Velocity_Influence","text":"Velocity_Influence <: VelCorrection\n\nA marker struct used to represent velocity correction based on influence modeling.\n\nWARNING\n\nThis correction type is not yet implemented!\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_None","page":"Exported Types","title":"FLORIDyn.Velocity_None","text":"Velocity_None <: VelCorrection\n\nA marker struct used to indicate that no velocity corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-direction-correction","page":"Exported Types","title":"Defining the direction correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct wind direction. They are all subtypes of DirCorrection","category":"page"},{"location":"types/#FLORIDyn.Direction_All","page":"Exported Types","title":"FLORIDyn.Direction_All","text":"Direction_All <: DirCorrection\n\nA marker struct used to indicate that all direction corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Influence","page":"Exported Types","title":"FLORIDyn.Direction_Influence","text":"Direction_Influence <: DirCorrection\n\nA marker struct used to represent direction correction based on influence modeling.\n\nWARNING\n\nThis correction type is not yet implemented!\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_None","page":"Exported Types","title":"FLORIDyn.Direction_None","text":"Direction_None <: DirCorrection\n\nA marker struct used to indicate that no direction corrections should be applied.\n\nWARNING\n\nThis correction type is not yet implemented!\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-turbulence-correction","page":"Exported Types","title":"Defining the turbulence correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct turbulence intensity. They are all subtypes of TurbulenceCorrection","category":"page"},{"location":"types/#FLORIDyn.TI_Influence","page":"Exported Types","title":"FLORIDyn.TI_Influence","text":"TI_Influence <: TurbulenceCorrection\n\nA marker struct used to represent turbulence intensity correction based on influence modeling.\n\nWARNING\n\nThis correction type is not yet implemented!\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_None","page":"Exported Types","title":"FLORIDyn.TI_None","text":"TI_None <: TurbulenceCorrection\n\nA marker struct used to indicate that no turbulence intensity corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-controller","page":"Exported Types","title":"Defining the controller","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that control turbine behavior. They are all subtypes of ControllerModel","category":"page"},{"location":"types/#FLORIDyn.Yaw_Constant","page":"Exported Types","title":"FLORIDyn.Yaw_Constant","text":"Yaw_Constant <: ControllerModel\n\nA marker struct used to represent a constant yaw control strategy. In this mode, turbines maintain a fixed yaw angle throughout the simulation.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Yaw_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Yaw_InterpTurbine","text":"Yaw_InterpTurbine <: ControllerModel\n\nA marker struct used to indicate yaw control with turbine interpolation. This mode allows for interpolated yaw angles across different turbine positions.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Yaw_SOWFA","page":"Exported Types","title":"FLORIDyn.Yaw_SOWFA","text":"Yaw_SOWFA <: ControllerModel\n\nA marker struct used to represent yaw control compatible with SOWFA (Simulator fOr Wind Farm Applications). This mode is specifically designed for integration with SOWFA simulation data.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-OP-iteration-model","page":"Exported Types","title":"Defining the OP iteration model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that iterate observation points (OPs) through the wind field. They are all subtypes of IterateOPs_model","category":"page"},{"location":"types/#FLORIDyn.IterateOPs_average","page":"Exported Types","title":"FLORIDyn.IterateOPs_average","text":"IterateOPs_average <: IterateOPs_model\n\nObservation point iteration model using averaged dynamics.\n\nThis iteration strategy employs averaging techniques to advance observation  points through the wind field, providing enhanced numerical stability and  smoother wake evolution compared to basic methods.\n\nAlgorithm Characteristics\n\nStability: Improved numerical stability through temporal averaging\nSmoothness: Reduces oscillations in wake dynamics\nComputational Cost: Moderate overhead due to averaging operations\nAccuracy: Good balance between stability and physical representation\n\nUse Cases\n\nRecommended for:\n\nSimulations requiring smooth wake evolution\nCases with high turbulence or complex wind conditions\nLong-duration simulations where stability is critical\nResearch applications focusing on ensemble statistics\n\nMathematical Approach\n\nThe averaging process involves temporal or spatial averaging of  relevant quantities (velocities, deflections, turbulence) before applying  the advancement step, resulting in more stable observation point trajectories.\n\nNotes\n\nThis model may require additional computational resources compared to basic  methods but provides better stability characteristics for challenging  simulation scenarios.\n\nWARNING\n\nNot yet implemented\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_basic","page":"Exported Types","title":"FLORIDyn.IterateOPs_basic","text":"IterateOPs_basic <: IterateOPs_model\n\nBasic observation point iteration model with simple time-stepping.\n\nThis is the fundamental iteration strategy that advances observation points  using direct time-stepping based on local wind velocities and wake deflection  effects. It provides the core functionality for FLORIDyn simulations.\n\nAlgorithm Characteristics\n\nSimplicity: Straightforward implementation with minimal overhead\nPerformance: Fastest execution among available iteration models\nAccuracy: Direct physical representation of wake advection\nMemory: Minimal memory requirements\n\nImplementation\n\nThe basic algorithm performs:\n\nDownwind advection based on local wind speed\nCrosswind deflection using wake centerline calculations\nCoordinate transformation to world coordinates\nTemporal advancement through circular shifting\nSpatial reordering to maintain downstream position order\n\nUse Cases\n\nRecommended for:\n\nStandard wind farm simulations\nPerformance-critical applications\nValidation studies against reference data\nInitial model development and testing\n\nMathematical Foundation\n\nUses explicit time-stepping with:\n\nΔx = U × Δt × advection_factor\n\nwhere observation points move downstream based on local wind conditions.\n\nNotes\n\nThis model serves as the reference implementation and baseline for  comparison with other iteration strategies. See iterateOPs! for detailed implementation.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_buffer","page":"Exported Types","title":"FLORIDyn.IterateOPs_buffer","text":"IterateOPs_buffer <: IterateOPs_model\n\nObservation point iteration model with buffered memory management.\n\nThis iteration strategy implements buffering techniques to optimize memory  usage and computational efficiency during observation point advancement,  particularly beneficial for large-scale wind farm simulations.\n\nAlgorithm Characteristics\n\nMemory Efficiency: Optimized memory access patterns\nScalability: Better performance for large numbers of observation points\nCaching: Intelligent buffering of frequently accessed data\nComputational Cost: Reduced overhead for memory-intensive operations\n\nUse Cases\n\nRecommended for:\n\nLarge wind farms with many turbines\nMemory-constrained computing environments\nHigh-resolution simulations with dense observation point grids\nProduction simulations requiring optimal resource utilization\n\nImplementation Strategy\n\nThe buffering approach manages observation point data through:\n\nEfficient memory allocation patterns\nReduced data copying operations\nOptimized access to state matrices\nStrategic caching of intermediate results\n\nPerformance Benefits\n\nImproved cache locality for better CPU performance\nReduced memory bandwidth requirements\nBetter scaling with problem size\nLower memory fragmentation\n\nNotes\n\nThis model is particularly effective when computational resources are  limited or when dealing with very large simulation domains.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_maximum","page":"Exported Types","title":"FLORIDyn.IterateOPs_maximum","text":"IterateOPs_maximum <: IterateOPs_model\n\nObservation point iteration model using maximum value selection.\n\nThis iteration strategy employs maximum value-based decision making during  observation point advancement, potentially useful for conservative estimates  or worst-case scenario analysis in wind farm simulations.\n\nAlgorithm Characteristics\n\nConservative Approach: Tends toward maximum/conservative values\nRobustness: Provides bounds on simulation behavior\nSpecial Cases: Handles extreme conditions effectively\nAnalysis: Useful for sensitivity and worst-case studies\n\nUse Cases\n\nRecommended for:\n\nConservative design analysis\nWorst-case scenario evaluation\nRisk assessment studies\nValidation of simulation bounds\nResearch on extreme wind conditions\n\nMathematical Approach\n\nThe maximum selection process applies maximum operators to relevant  quantities during the iteration step, which may include:\n\nMaximum wind speeds in the vicinity\nMaximum deflection values\nMaximum turbulence intensities\nConservative time step selection\n\nApplications\n\nParticularly useful in:\n\nSafety factor determination\nConservative power estimation\nExtreme load analysis\nUncertainty quantification studies\n\nNotes\n\nThis model may produce more conservative results compared to other  iteration strategies and should be used when understanding bounds  on simulation behavior is important.\n\nWARNING\n\nNot yet implemented\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_weighted","page":"Exported Types","title":"FLORIDyn.IterateOPs_weighted","text":"IterateOPs_weighted <: IterateOPs_model\n\nObservation point iteration model using weighted interpolation.\n\nThis iteration strategy employs sophisticated weighted interpolation  techniques to advance observation points, providing enhanced accuracy  through spatial and temporal weighting of relevant physical quantities.\n\nAlgorithm Characteristics\n\nHigh Accuracy: Superior interpolation accuracy\nSmoothness: Smooth transitions between observation points\nComputational Cost: Higher due to interpolation calculations\nFlexibility: Adaptable weighting schemes\n\nUse Cases\n\nRecommended for:\n\nHigh-accuracy research simulations\nDetailed wake interaction studies\nValidation against experimental data\nApplications requiring smooth field representations\nAdvanced control algorithm development\n\nInterpolation Strategy\n\nThe weighted approach typically involves:\n\nDistance-based spatial weighting\nTemporal interpolation of quantities\nMulti-point interpolation schemes\nAdaptive weight calculation based on local conditions\n\nMathematical Foundation\n\nUses interpolation weights w_i such that:\n\nquantity_interpolated = Σ w_i × quantity_i\n\nwhere weights satisfy Σ w_i = 1 and are computed based on distance,  time, or other relevant metrics.\n\nAccuracy Benefits\n\nReduced numerical diffusion\nBetter preservation of wake structures\nImproved representation of turbulence effects\nEnhanced spatial resolution\n\nNotes\n\nThis model provides the highest accuracy among available iteration  strategies but requires additional computational resources. Best suited  for applications where accuracy is prioritized over computational speed.\n\nWARNING\n\nNot yet implemented\n\n\n\n\n\n","category":"type"},{"location":"types/#Types-for-storing-wind-field-params","page":"Exported Types","title":"Types for storing wind field params","text":"","category":"section"},{"location":"types/#FLORIDyn.WindDirType","page":"Exported Types","title":"FLORIDyn.WindDirType","text":" WindDirType\n\nFields\n\nData::Float64: wind direction value\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindDirMatrix","page":"Exported Types","title":"FLORIDyn.WindDirMatrix","text":"struct WindDirMatrix\n\nFields\n\nData::Matrix{Float64}:    Columns [time, phi] or [time, phi_T0, phi_T1, ... phi_Tn]\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindDirTriple","page":"Exported Types","title":"FLORIDyn.WindDirTriple","text":"WindDirTriple\n\nA structure representing a wind direction triple. \n\nFields\n\nInit::Vector{Float64}:    Mean direction (vector or scalar)\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\nMeanPull::Float64:        Scalar mean reversion factor\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindVelType","page":"Exported Types","title":"FLORIDyn.WindVelType","text":" WindVelType\n\nFields\n\nData::Float64: wind speed\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindVelMatrix","page":"Exported Types","title":"FLORIDyn.WindVelMatrix","text":"struct WindVelMatrix\n\nFields\n\nData::Matrix{Float64}:    Nx2 matrix: column 1 = time, column 2 = wind speed\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindShear","page":"Exported Types","title":"FLORIDyn.WindShear","text":"WindShear\n\nA struct representing the wind shear profile. This type is used to model the variation of wind speed with height,  which is important in atmospheric and wind energy simulations.\n\nFields\n\nz0::Float64: Reference height (not used in the getWindShearT)\nalpha::Float64: WindShear coefficient\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindPerturbation","page":"Exported Types","title":"FLORIDyn.WindPerturbation","text":"WindPerturbation\n\nA mutable struct for configuring stochastic wind perturbations in wind farm simulations.\n\nThis struct controls whether perturbations are applied to different wind parameters and defines the magnitude of these perturbations using standard deviations. Wind perturbations are used to  model uncertainty in wind measurements or to perform sensitivity analysis.\n\nFields\n\nvel::Bool: Enable/disable velocity perturbations. When true, random perturbations are applied to wind velocity.\nvel_sigma::Float64: Standard deviation for velocity perturbations [m/s]. Determines the magnitude of random variations added to the wind velocity.\ndir::Bool: Enable/disable direction perturbations. When true, random perturbations are applied to wind direction.\ndir_sigma::Float64: Standard deviation for direction perturbations [degrees]. Determines the magnitude of random variations added to the wind direction.\nti::Bool: Enable/disable turbulence intensity perturbations. When true, random perturbations are applied to turbulence intensity.\nti_sigma::Float64: Standard deviation for turbulence intensity perturbations [-]. Determines the magnitude of random variations added to the turbulence intensity.\n\nNotes\n\nPerturbations are typically applied as additive Gaussian noise with zero mean and the specified standard deviation\nThe perturbation flags (vel, dir, ti) act as switches to enable or disable specific types of perturbations\nSetting a flag to false will disable perturbations for that parameter regardless of the sigma value\nStandard deviations should be positive values.\n\n\n\n\n\n","category":"type"},{"location":"types/#Other-types","page":"Exported Types","title":"Other types","text":"","category":"section"},{"location":"types/#FLORIDyn.MSR","page":"Exported Types","title":"FLORIDyn.MSR","text":"MSR `VelReduction` `AddedTurbulence` `EffWind`\n\nEnumeration that selects which (scalar) quantity is visualised / stored when plotting or saving flow field measurements. The acronym stands for Measurement System Representation. Passed via the msr keyword to run_floridyn and the plotting helpers plot_flow_field, plot_measurements.\n\nElements\n\nVelReduction    (1): Velocity reduction (1 - u / u_ref) downstream of turbines.\nAddedTurbulence (2): Added turbulence intensity contributed by wakes (ΔTI component).\nEffWind         (3): Effective wind speed at turbine locations (including wake effects).\n\nUsage\n\n# Use default (VelReduction)\nrun_floridyn(plt, set, wf, wind, sim, con, vis, floridyn, floris)\n\n# Explicitly request added turbulence visualisation\nrun_floridyn(plt, set, wf, wind, sim, con, vis, floridyn, floris; msr=AddedTurbulence)\n\n# Convert from a user string (e.g. parsed CLI / YAML value)\nmsr = toMSR(\"EffWind\")\nrun_floridyn(plt, set, wf, wind, sim, con, vis, floridyn, floris; msr)\n\nSee also: toMSR\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.States","page":"Exported Types","title":"FLORIDyn.States","text":"States\n\nLightweight container for state variable names and counts used in wind farm simulations.\n\nThis mutable struct organizes the state variables into three categories: turbine states, observation point (OP) states, and wind field (WF) states. It provides both the variable names and their counts for efficient memory allocation and state management.\n\nFields\n\nT_names::Vector{String}: Names of turbine state variables [\"a\", \"yaw\", \"TI\"]\nTurbine::Int: Number of turbine state variables (3)\nOP_names::Vector{String}: Names of observation point variables [\"x0\", \"y0\", \"z0\", \"x1\", \"y1\", \"z1\"]\nOP::Int: Number of observation point variables (6)\nWF_names::Vector{String}: Names of wind field variables [\"windvel\", \"winddir\", \"TI0\"]\nWF::Int: Number of wind field variables (3)\n\nConstructor\n\nUse the default constructor States() to create an instance with predefined variable names and counts currently used by FLORIDyn.jl.\n\nExample\n\nstates = States()\nprintln(\"Turbine states: \", states.T_names)\nprintln(\"Number of turbine states: \", states.Turbine)\n\nState Variable Definitions\n\nTurbine States (T_names)\n\n\"a\": Axial induction factor [-]\n\"yaw\": Yaw angle [degrees]\n\"TI\": Local turbulence intensity [-]\n\nObservation Point States (OP_names)\n\n\"x0\", \"y0\", \"z0\": Initial position coordinates [m]\n\"x1\", \"y1\", \"z1\": Final position coordinates [m]\n\nWind Field States (WF_names)\n\n\"wind_vel\": Wind velocity [m/s]\n\"wind_dir\": Wind direction [degrees]\n\"TI0\": Ambient turbulence intensity [-]\n\nSee also: States()\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.UnifiedBuffers","page":"Exported Types","title":"FLORIDyn.UnifiedBuffers","text":"UnifiedBuffers\n\nUnified buffer struct containing all arrays needed by interpolateOPs! and setUpTmpWFAndRun!.\n\nFields\n\ndist_buffer::Vector{Float64}: Distance calculations for interpolateOPs!\nsorted_indices_buffer::Vector{Int}: Sorted indices for interpolateOPs!\nM_buffer::Matrix{Float64}: Main result buffer for setUpTmpWFAndRun!\niTWFState_buffer::Vector{Float64}: Turbine wind field state buffer\ntmp_Tpos_buffer::Matrix{Float64}: Temporary turbine position buffer\ntmp_WF_buffer::Matrix{Float64}: Temporary wind field buffer\ntmp_Tst_buffer::Matrix{Float64}: Temporary turbine state buffer\ndists_buffer::Vector{Float64}: Distance buffer for setUpTmpWFAndRun!\nplot_WF_buffer::Matrix{Float64}: Wind field plotting buffer\nplot_OP_buffer::Matrix{Float64}: Observation point plotting buffer\nfloris_buffers: Pre-allocated FLORIS computation buffers for wind wake calculations\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPsBuffers","page":"Exported Types","title":"FLORIDyn.IterateOPsBuffers","text":"IterateOPsBuffers\n\nA struct containing pre-allocated buffers for allocation-free execution of iterateOPs!.\n\nThis struct eliminates all allocations during the observation point iteration by  pre-allocating all necessary temporary arrays. It should be created once and reused across multiple calls to iterateOPs! for maximum performance.\n\nFields\n\ntmpOPStates::Matrix{Float64}: Buffer for saving turbine observation point states  \ntmpTStates::Matrix{Float64}: Buffer for saving turbine states\ntmpWFStates::Matrix{Float64}: Buffer for saving wind farm states\nstep_dw::Vector{Float64}: Buffer for downwind step calculations\ndeflection::Matrix{Float64}: Buffer for centerline deflection calculations  \nstep_cw::Matrix{Float64}: Buffer for crosswind step calculations\ntemp_states_op::Matrix{Float64}: Temporary buffer for States_OP circular shifting\ntemp_states_t::Matrix{Float64}: Temporary buffer for States_T circular shifting  \ntemp_states_wf::Matrix{Float64}: Temporary buffer for States_WF circular shifting\nsort_buffer::Vector{Int}: Buffer for sorting observation points\n\nConstructor\n\nIterateOPsBuffers(wf::WindFarm)\n\nCreates buffers appropriately sized for the given WindFarm object.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.FLORISBuffers","page":"Exported Types","title":"FLORIDyn.FLORISBuffers","text":"FLORISBuffers\n\nPre-allocated buffers for the runFLORIS! computation to minimize allocations.\n\nThis struct also persists result arrays so callers can read outputs without allocations. After calling runFLORIS!, the following fields contain results:\n\nOutput Fields\n\nT_red_arr::Vector{Float64}: Per-turbine velocity reduction factors. For a   single-turbine run, length is 1 and T_red_arr[1] is the scalar reduction.\nT_aTI_arr::Vector{Float64}: Added turbulence intensity from upstream wakes.   For N turbines, length is max(N-1, 0). Empty for single-turbine runs.\nT_Ueff::Vector{Float64}: Effective wind speed at the last turbine as a   length-1 vector (multi-turbine case). Empty for single-turbine runs.\nT_weight::Vector{Float64}: Gaussian weight factors used for wake overlap.   For N turbines, length is max(N-1, 0). Empty for single-turbine runs.\n\n\n\n\n\n","category":"type"}]
}
