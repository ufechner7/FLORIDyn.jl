var documenterSearchIndex = {"docs":
[{"location":"video_creation/#Video-Creation-from-Simulation-Plots","page":"Video Creation","title":"Video Creation from Simulation Plots","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"This document describes how to create videos from saved FLORIDyn simulation plots.","category":"page"},{"location":"video_creation/#Overview","page":"Video Creation","title":"Overview","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"FLORIDyn.jl now includes functionality to automatically convert series of PNG plot files into MP4 videos. This is particularly useful for creating animations of flow field evolution over time.","category":"page"},{"location":"video_creation/#Prerequisites","page":"Video Creation","title":"Prerequisites","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"FFmpeg: Must be installed and available in your system PATH\nUbuntu/Debian: sudo apt install ffmpeg\nMacOS: brew install ffmpeg\nWindows: Download from https://ffmpeg.org/","category":"page"},{"location":"video_creation/#Basic-Usage","page":"Video Creation","title":"Basic Usage","text":"","category":"section"},{"location":"video_creation/#1.-Generate-Plot-Frames","page":"Video Creation","title":"1. Generate Plot Frames","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"First, run your simulation with vis.save=true to save plot frames:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"using FLORIDyn\n\n# Enable plot saving\nvis = Vis(online=true, save=true, rel_v_min=20.0, up_int=12)\n\n# Run simulation - this will save frames to the 'video/' folder\nwf, md, mi = runFLORIDyn(plt, set, wf, wind, sim, con, vis, floridyn, floris)","category":"page"},{"location":"video_creation/#2.-Create-Videos","page":"Video Creation","title":"2. Create Videos","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Create videos from the saved frames:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"# Create video from velocity reduction frames\nvideo_path = createVideo(\"velocity_reduction\"; fps=4)\n\n# Custom video creation with options\ncustom_video = createVideo(\"wind_speed\"; \n                          video_dir=\"video\", \n                          output_dir=\"animations\", \n                          fps=8, \n                          delete_frames=true)","category":"page"},{"location":"video_creation/#Functions","page":"Video Creation","title":"Functions","text":"","category":"section"},{"location":"video_creation/#createVideo(prefix;-kwargs...)","page":"Video Creation","title":"createVideo(prefix; kwargs...)","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Convert PNG files starting with a given prefix into an MP4 video.","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Arguments:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"prefix::String: Prefix of PNG files to include (e.g., \"velocity_reduction\")\nvideo_dir::String: Input directory (default: \"video\")\noutput_dir::String: Output directory (default: \"video\") \nfps::Int: Frames per second (default: 2)\ndelete_frames::Bool: Delete PNG files after creating video (default: false)","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Returns: Path to created video file, or empty string if failed","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Supported prefixes:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"\"velocity_reduction\" - Velocity reduction animations\n\"added_turbulence\" - Added turbulence animations  \n\"wind_speed\" - Wind speed animations","category":"page"},{"location":"video_creation/#File-Naming-Convention","page":"Video Creation","title":"File Naming Convention","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"The video creation functions expect PNG files to follow this naming pattern:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"velocity_reduction_t0000s.png\nvelocity_reduction_t0012s.png\nwind_speed_t0024s.png\netc.","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Output videos are named:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"velocity_reduction_animation.mp4\nadded_turbulence_animation.mp4\nwind_speed_animation.mp4","category":"page"},{"location":"video_creation/#Tips","page":"Video Creation","title":"Tips","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"Frame Rate: Start with low FPS (2-4) for overview videos, use higher FPS (8-12) for detailed analysis\nStorage: Use delete_frames=true to save disk space after video creation\nQuality: Videos are created with good quality settings (CRF 23) suitable for presentations\nTroubleshooting: If video creation fails, check that FFmpeg is installed and PNG files exist","category":"page"},{"location":"video_creation/#Integration-with-main.jl","page":"Video Creation","title":"Integration with main.jl","text":"","category":"section"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"The example main.jl includes video creation as PLT option 7:","category":"page"},{"location":"video_creation/","page":"Video Creation","title":"Video Creation","text":"# Set PLT=7 to create videos from saved frames\nPLT = 7\ninclude(\"examples/main.jl\")","category":"page"},{"location":"functions/#Low-Level-Functions","page":"Low-Level Functions","title":"Low-Level Functions","text":"","category":"section"},{"location":"functions/#Calculating-the-wind-directions","page":"Low-Level Functions","title":"Calculating the wind directions","text":"","category":"section"},{"location":"functions/#FLORIDyn.getWindDirT","page":"Low-Level Functions","title":"FLORIDyn.getWindDirT","text":"getWindDirT(::Direction_Constant, wind_dir, iT, _)\n\nReturn wind direction in SOWFA-degrees for the requested turbine(s).\n\nArguments\n\nwind_dir: The wind direction (scalar).\niT: Index or indices of the turbines (can be an integer or vector).\n_: Placeholder for unused argument.\n\nReturns\n\nphi: Array of wind direction values, same size as iT.\n\n\n\n\n\ngetWindDirT(::Direction_Constant_wErrorCov, wind_dir::WindDirType, iT, t)\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::WindDirType: WindDirType\niT: Vector of turbine indices (can be any indexable collection)\nt: Time step\n\nReturns\n\nphi: Vector of wind directions for the selected turbines, including random perturbation\n\n\n\n\n\ngetWindDirT(::Direction_Interpolation, wind_dir::AbstractMatrix, iT, t)\n\nDirection_Interpolation\n\nReturns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.\n\nArguments:\n\nwind_dir::Matrix: columns are time and phi (wind direction)\niT: single value or vector with turbine index/indices\nt: time of request\n\nReturns:\n\nphi: Vector of wind directions for each turbine in iT [°]\n\n\n\n\n\ngetWindDirT(::Direction_Interpolation_wErrorCov, wind_dir::WindDirMatrix, iT, t)\n\nReturns the wind direction at the respective turbine(s). Uniform interpolation version - all turbines experience the same changes.\n\nArguments:\n\nwind_dir::WindDirMatrix: WindDirMatrix\niT: single value or vector with turbine index/indices\nt: time of request\n\nReturns:\n\nphi: Vector of wind directions for each turbine in iT [°]\n\n\n\n\n\ngetWindDirT(::Direction_InterpTurbine, wind_dir::AbstractMatrix iT, t)\n\nReturn wind direction in SOWFA-degrees for the requested turbine(s).\n\nArguments\n\nwind_dir::Matrix: Each row is [time, phi_T0, phi_T1, ...].\n`iT: Index or indices of turbines.\nt: Time of request. [s]\n\nReturns\n\nphi::Vector{Float64}: Wind direction(s) for the selected turbine(s) at time t. [°]\n\n\n\n\n\ngetWindDirT(::Direction_InterpTurbine_wErrorCov, wind_dir::WindDirMatrix, iT, t)\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::WindDirMatrix: See: WindDirMatrix\niT: Index or indices of the turbines (can be integer or vector)\nt: Time of request (Float64) [s]\n\nReturns\n\nphi: Wind direction(s) for requested turbine(s), perturbed with noise. [°]\n\n\n\n\n\ngetWindDirT(::Direction_RW_with_Mean, wind_dir_now, wind_dir::WindDirTriple)\n\nReturns the wind direction at the respective turbine(s).\n\nArguments\n\nwind_dir_now: Current value (vector)\nwind_dir::WindDirTriple: WindDirTriple\n\nReturns\n\nphi: Updated wind direction(s) (vector) [°]\n\n\n\n\n\ngetWindDirT(::Direction_RW_with_Mean, wind_dir::WindDirTriple, iT, t)\n\nRandom walk with mean reversion model for wind direction.\n\nArguments\n\n::Direction_RW_with_Mean: Direction mode indicator\nwind_dir::WindDirTriple: Wind direction data containing Init, CholSig, and MeanPull\niT: Turbine index or indices\nt: Time value (unused in this implementation) [s]\n\nReturns\n\nphi: Wind direction(s) for the requested turbine(s) [°]\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getWindDirT_EnKF","page":"Low-Level Functions","title":"FLORIDyn.getWindDirT_EnKF","text":"getWindDirT_EnKF(::Direction_EnKF_InterpTurbine, wind_dir::AbstractMatrix, iT, t)\n\nDirectionEnKFInterpTurbine\n\nReturn wind direction in SOWFA-deg for the requested turbine(s).\n\nArguments\n\nwind_dir::Matrix: Matrix where each row is [time, phi_T0, phi_T1, ... phi_Tn]\niT: Index or indices of the turbines (can be integer or vector)\nt: Time of request (scalar)\n\nReturns\n\nphi: Wind direction(s) at time t for turbine(s) iT [°]\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getDataDir","page":"Low-Level Functions","title":"FLORIDyn.getDataDir","text":"getDataDir(set::Settings, wind::Wind, wf::WindFarm, t)\n\nRetrieve wind direction data for all turbines at the current simulation time.\n\nArguments\n\nset::Settings: Simulation settings containing the direction mode configuration\nwind::Wind: Wind field data structure containing direction information and input type\nwf::WindFarm: Wind farm object containing turbine states and configuration\nt: Current simulation time for temporal interpolation\n\nReturns\n\nphi: Wind direction values (typically in radians) for all turbines at the specified time\n\nDescription\n\nThis function reads wind direction data and returns the current wind direction angle (phi) for all  turbines in the wind farm. The function handles two different input modes:\n\nRandom Walk with Mean mode (wind.input_dir == \"RW_with_Mean\"): Uses the current wind farm  state from wf.States_WF[wf.StartI, 2] along with the wind direction data to compute direction.\nStandard temporal interpolation mode: Uses the wind direction data directly with temporal  interpolation for all turbines at the specified simulation time.\n\nThe function dispatches to getWindDirT with appropriate parameters based on the input mode,  ensuring consistent wind direction estimation across different modeling approaches.\n\nExamples\n\n# Get wind direction for all turbines at current simulation time\nphi = getDataDir(settings, wind_data, wind_farm, 100.0)\n\n# The returned phi contains direction values for all turbines\ndirection_turbine_1 = phi[1]\n\nNotes\n\nThe function automatically handles different wind input modes through conditional logic\nFor random walk mode, uses existing wind farm state as reference\nFor standard mode, performs temporal interpolation across all turbines\n\nSee also\n\ngetWindDirT: Underlying function for wind direction temporal interpolation\nSettings: Configuration structure containing direction mode settings\nWind: Wind field data structure containing direction information and input type\nWindFarm: Wind farm configuration structure\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.correctDir!","page":"Low-Level Functions","title":"FLORIDyn.correctDir!","text":"correctDir!(::Direction_All, set::Settings, wf::WindFarm, wind::Wind, t)\n\nApply direction correction to all turbines in the wind farm using the Direction_All strategy.\n\nArguments\n\n::Direction_All: The direction correction strategy type that applies corrections to all turbines\nset::Settings: Simulation settings containing the direction mode configuration\nwf::WindFarm: Wind farm object containing turbine states and configuration (modified in-place)\nwind::Wind: Wind field data structure containing direction information and input type\nt: Current simulation time for temporal interpolation\n\nReturns\n\nnothing: This function modifies the wind farm state in-place and returns nothing\n\nDescription\n\nThis function applies a direction correction using the Direction_All strategy, which updates the  wind direction for all turbines in the wind farm. The function performs the following operations:\n\nData Retrieval: Calls getDataDir to obtain current wind direction data for all turbines\nState Update: Updates the wind direction in the wind farm state (wf.States_WF[:, 2])\nOperational Point Orientation: If the state matrix has 4 columns, also updates the  operational point orientation (wf.States_WF[wf.StartI, 4]) to match the wind direction\n\nThe correction is applied uniformly to all turbines using the first direction value from the  retrieved direction data.\n\nExamples\n\n# Apply direction correction to all turbines\ncorrectDir!(Direction_All(), settings, wind_farm, wind_data, 100.0)\n\n# The wind farm state is modified in-place\ncurrent_direction = wind_farm.States_WF[1, 2]  # Updated direction for first turbine\n\nNotes\n\nThis function modifies the wind farm state in-place (indicated by the ! suffix)\nAll turbines receive the same direction correction value (phi[1])\nThe operational point orientation is only updated if the state matrix has 4 columns\nDirection values are typically in radians following standard wind engineering conventions\n\nSee also\n\ngetDataDir: Function for retrieving wind direction data\nDirection_All: Direction correction strategy type\nSettings: Simulation settings structure\nWindFarm: Wind farm configuration structure\nWind: Wind field data structure\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-velocity","page":"Low-Level Functions","title":"Calculating the wind velocity","text":"","category":"section"},{"location":"functions/#FLORIDyn.getDataVel","page":"Low-Level Functions","title":"FLORIDyn.getDataVel","text":"getDataVel(set::Settings, wind::Wind, wf::WindFarm, t, tmp_m, floris::Floris)\n\nRetrieve wind velocity data for all turbines at the current simulation time using various input modes.\n\nArguments\n\nset::Settings: Simulation settings containing the velocity mode configuration\nwind::Wind: Wind field data structure containing velocity information and input type\nwf::WindFarm: Wind farm object containing turbine states and configuration\nt: Current simulation time for temporal interpolation\ntmp_m: Temporary matrix containing reduction factors and other intermediate calculations\nfloris::Floris: FLORIS model parameters including wake model coefficients\n\nReturns\n\nu: Wind velocity values for all turbines at the specified time\nwind::Wind: Updated wind field data structure (may be modified for certain input modes)\n\nDescription\n\nThis function reads wind velocity data and returns the current wind speed (U) for all turbines  in the wind farm. The function handles multiple input modes through conditional logic:\n\nInterpolation and Integration mode (\"I_and_I\"): Uses getWindSpeedT with turbine positions,  wind direction, and FLORIS parameters. Applies wake effects reduction if the simulation time  exceeds the wind speed estimator offset.\nRandom Walk with Mean mode (\"RW_with_Mean\"): Uses the current wind farm state from  wf.States_WF[wf.StartI, 1] with the wind velocity model.\nEnsemble Kalman Filter mode (\"EnKF_InterpTurbine\"): Uses EnKF-based interpolation  at turbine locations via getWindSpeedT_EnKF.\nStandard temporal interpolation mode (default): Uses direct temporal interpolation  with getWindSpeedT for all turbines.\n\nExamples\n\n# Get wind velocity for all turbines at current simulation time\nu, updated_wind = getDataVel(settings, wind_data, wind_farm, 100.0, temp_matrix, floris_params)\n\n# The returned u contains velocity values for all turbines\nvelocity_turbine_1 = u[1]\n\nNotes\n\nThe function automatically handles different wind input modes through conditional logic\nFor IandI mode, wake effects are applied based on timing and reduction factors\nThe wind structure may be modified and returned for certain input modes\nVelocity values are in m/s\nWake reduction is only applied in IandI mode when sufficient time has elapsed\n\nSee also\n\nSettings: Simulation settings structure\nWind: Wind field data structure\nWindFarm: Wind farm configuration structure\nFloris: FLORIS model parameters structure\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-shear","page":"Low-Level Functions","title":"Calculating the wind shear","text":"","category":"section"},{"location":"functions/#FLORIDyn.getWindShearT","page":"Low-Level Functions","title":"FLORIDyn.getWindShearT","text":"getWindShearT(::Shear_Interpolation, WindShear::AbstractMatrix, z)\n\nCompute the wind shear at a given height z using the specified WindShear model.\n\nArguments\n\n::Shear_Interpolation: (Type only) Use interpolation to determine the wind shear.\nWindShear: A matrix describing the wind shear profile.\nz: The height (in meters) at which to evaluate the wind shear.\n\nReturns\n\nThe wind shear value at height z.\n\nREMARKS\n\nExpects a .csv file called \"WindShearProfile.csv\" with a normalized wind speed profile for different heights:\n\nz, (u_z/u0)\nz, (u_z/u0)\nz, (u_z/u0)\n\nThere is a linear interpolation between every pair. In case z is out of bounds the function will use the closest available setpoint.\n\n\n\n\n\ngetWindShearT(::Shear_PowerLaw, WindShear, z_norm)\n\nReturn the shear factor u_eff = shear * u_referenceHeight using the power law.\n\nArguments\n\nShear_PowerLaw: (type only, unused) Specifies that this method applies to the power law model\nWindShear: A struct of type (WindShear)(@ref)\nz0: Reference height (not used in this function)\nalpha: WindShear coefficient\nz_norm: Height(s) (can be scalar or array)\n\nReturns\n\nshear: The shear factor at the given height(s)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Calculating-the-wind-turbulence","page":"Low-Level Functions","title":"Calculating the wind turbulence","text":"","category":"section"},{"location":"functions/#FLORIDyn.getDataTI","page":"Low-Level Functions","title":"FLORIDyn.getDataTI","text":"getDataTI(set::Settings, wind::Wind, wf::WindFarm, t) -> Vector\n\nRetrieve turbulence intensity data for all turbines at the current simulation time.\n\nThis function obtains turbulence intensity values for all turbines in the wind farm using the configured turbulence model and wind field data. It serves as a wrapper around the underlying turbulence intensity retrieval system.\n\nArguments\n\nset::Settings: Settings object containing simulation configuration\nset.turb_mode: Turbulence model configuration specifying the retrieval method\nwind::Wind: Wind configuration object containing turbulence intensity data\nwind.ti: Turbulence intensity data, parameters, or model configuration\nwf::WindFarm: Wind farm object containing turbine information\nwf.nT: Number of turbines in the wind farm\nt: Current simulation time for time-dependent turbulence intensity models\n\nReturns\n\nVector: Turbulence intensity values for all turbines (dimensionless, typically 0.05-0.25)\n\nBehavior\n\nThe function creates a vector of all turbine indices [1, 2, ..., nT] and retrieves the corresponding turbulence intensity values using the specified turbulence model. The actual retrieval method depends on the set.turb_mode configuration and can include:\n\nConstant turbulence intensity\nTime-interpolated values from data files\nTurbine-specific interpolation\nRandom walk models with covariance\n\nExample\n\n# Get turbulence intensity for all turbines at t=100s\nTI_values = getDataTI(settings, wind_config, wind_farm, 100.0)\nprintln(\"TI for turbine 1: \", TI_values[1])\n\nSee Also\n\ngetWindTiT: Underlying function for turbulence intensity retrieval\ncorrectTI!: Function that uses this data to update wind farm states\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.getWindTiT","page":"Low-Level Functions","title":"FLORIDyn.getWindTiT","text":"getWindTiT(::TI_Constant, wind_ti::Number, iT, _)\n\nReturn turbulence intensity for the requested turbine(s).\n\nArguments\n\n::TI_Constant: type parameter to indicate constant wind turbulence\nwind_ti::Number: Constant value (turbulence intensity)\niT: Index or indices of the turbines\n_: will be ignored\n\nReturns\n\nTi: Array of turbulence intensity values for each turbine index\n\n\n\n\n\ngetWindTiT(::TI_Interpolation, wind_ti::AbstractMatrix, iT, t)\n\nInterpolates the wind turbulence intensity (TI) at a given time t using the specified TI_Interpolation method.\n\nArguments\n\n::TI_Interpolation: Use linear interpolation to calculate the turbulence intensity.\nwind_ti::Matrix: Matrix containing wind turbulence intensity values over time.\niT: Index/indices of the turbines (can be Int or array).\nt: The specific time at which to interpolate the turbulence intensity.\n\nReturns\n\nThe interpolated turbulence for the requested turbine(s) at time t.\n\nNotes\n\nThe function assumes that wind_ti contains the necessary data for interpolation as (time, TI) pairs (n×2 matrix)\nUniform interpolation version - all turbines experience the same changes.\n\n\n\n\n\ngetWindTiT(::TI_InterpTurbine, wind_ti::AbstractMatrix, iT, t)\n\nRetrieve the wind turbulence intensity (TI) for a specific turbine at a given time.\n\nArguments\n\n::TI_InterpTurbine: The turbulence intensity interpolation object for the turbine.\nwind_ti::AbstractMatrix: Matrix containing wind turbulence intensity values.\niT: Index of the turbine for which the TI is requested.\nt: Time at which the TI value is needed.\n\nReturns\n\nThe interpolated wind turbulence intensity value for the specified turbine at time t.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FLORIDyn.correctTI!","page":"Low-Level Functions","title":"FLORIDyn.correctTI!","text":"correctTI!(::TI_None, set::Settings, wf::WindFarm, wind::Wind, t) -> Nothing\n\nUpdate turbulence intensity values in the wind farm state matrix without correction.\n\nThis function implements the \"no correction\" strategy for turbulence intensity, where  the wind farm turbulence intensity values are updated with fresh data from the wind  field model without applying any correction algorithms. It serves as the baseline  approach for turbulence intensity handling in FLORIDyn simulations.\n\nArguments\n\n::TI_None: Dispatch type indicating no turbulence intensity correction algorithm\nset::Settings: Settings object containing simulation configuration and turbulence model parameters\nset.turb_mode: Turbulence model configuration specifying the retrieval method\nwf::WindFarm: Wind farm object containing the state matrices to be updated\nwf.States_WF: Wind field states matrix where column 3 contains turbulence intensity values\nwf.StartI: Starting indices for each turbine's operational points\nwf.nT: Number of turbines\nwind::Wind: Wind configuration object containing turbulence intensity data\nwind.ti: Turbulence intensity data or model parameters\nt: Current simulation time for time-dependent turbulence intensity retrieval\n\nReturns\n\nNothing: The function modifies the wind farm state in-place\n\nBehavior\n\nRetrieves current turbulence intensity values for all turbines using getDataTI\nUpdates the wind farm state matrix wf.States_WF at rows wf.StartI and column 3\nTransposes the turbulence intensity vector to match the matrix structure\nProvides error handling for matrix update operations\n\nExample\n\n# Update turbulence intensity without correction at t=50s\ncorrectTI!(TI_None(), settings, wf, wind, 50.0)\n\n# The wind farm state matrix is now updated with new TI values\ncurrent_ti = wf.States_WF[wf.StartI, 3]\n\nNotes\n\nThe function modifies the wind farm object in-place (indicated by the ! suffix)\nThis \"no correction\" approach provides baseline turbulence intensity without  applying wake-induced corrections or measurement-based adjustments\nError handling ensures graceful failure if matrix dimensions are incompatible\n\nSee Also\n\ngetDataTI: Function used to retrieve turbulence intensity data\nTI_None: Dispatch type for no correction strategy\n\n\n\n\n\n","category":"function"},{"location":"functions/#Controller-functions","page":"Low-Level Functions","title":"Controller functions","text":"","category":"section"},{"location":"functions/#FLORIDyn.getYaw","page":"Low-Level Functions","title":"FLORIDyn.getYaw","text":"getYaw(::Yaw_SOWFA, ConYawData::AbstractMatrix, iT, t) -> Float64 or Vector{Float64}\n\nReturn the yaw angle at time t for the specified turbine(s) using linear interpolation.\n\nArguments\n\n::Yaw_SOWFA: Controller type dispatch parameter for SOWFA-style yaw control\nConYawData::Matrix{Float64}: Control data matrix where:\nFirst column contains time values (in seconds)\nSubsequent columns contain yaw angles for each turbine (in degrees)\niT: Turbine index or indices to query:\nInteger: Single turbine index (1-based)\nAbstractVector{<:Integer}: Vector of turbine indices for multiple turbines\nt::Real: Requested time (in seconds)\n\nReturns\n\nFloat64: Single yaw angle (in degrees) if iT is an integer\nVector{Float64}: Vector of yaw angles (in degrees) if iT is a vector\n\nBehavior\n\nInterpolation: Uses linear interpolation between time points with flat extrapolation\nOut-of-bounds handling: If t is outside the time range, the function:\nIssues a warning message\nClamps t to the nearest boundary (first or last time point)\nSingle time point: If only one time point exists, returns the corresponding yaw value directly\nError handling: Throws an error if iT is not an integer or vector of integers\n\nData Format\n\nThe con_yaw_data matrix should have the structure:\n\n[time₁  yaw₁₁  yaw₁₂  ...  yaw₁ₙ]\n[time₂  yaw₂₁  yaw₂₂  ...  yaw₂ₙ]\n[  ⋮      ⋮      ⋮    ⋱     ⋮  ]\n[timeₘ  yawₘ₁  yawₘ₂  ...  yawₘₙ]\n\nwhere m is the number of time steps and n is the number of turbines.\n\nExamples\n\n# Example control data: 3 time points, 2 turbines\ncon_yaw_data = [0.0  10.0  5.0;   # t=0s: T1=10°, T2=5°\n                1.0  15.0  10.0;  # t=1s: T1=15°, T2=10°\n                2.0  20.0  15.0]  # t=2s: T1=20°, T2=15°\n\n# Get yaw for turbine 1 at t=0.5s (interpolated)\nyaw1 = getYaw(Yaw_SOWFA(), con_yaw_data, 1, 0.5)  # Returns 12.5°\n\n# Get yaw for multiple turbines at t=1.5s\nyaws = getYaw(Yaw_SOWFA(), con_yaw_data, [1, 2], 1.5)  # Returns [17.5°, 12.5°]\n\n# Out-of-bounds time (will issue warning)\nyaw_oob = getYaw(Yaw_SOWFA(), con_yaw_data, 1, 5.0)  # Returns 20.0° with warning\n\nSee Also\n\nYaw_SOWFA: Controller type for SOWFA-style yaw control\nInterpolations.linear_interpolation: Underlying interpolation method used\n\n\n\n\n\n","category":"function"},{"location":"settings/#Simulation-settings","page":"Settings","title":"Simulation settings","text":"","category":"section"},{"location":"settings/#Introduction","page":"Settings","title":"Introduction","text":"","category":"section"},{"location":"settings/","page":"Settings","title":"Settings","text":"The settings are defined in a .yaml file in the folder data. The function setup converts them into three settings structs, containing strings and numbers. The constructor Settings creates a struct of marker types from these settings structs. ","category":"page"},{"location":"settings/","page":"Settings","title":"Settings","text":"For each of these yaml files there must be a folder with the same name (without the .yaml extension) in the data directory. In this folder the required .csv files must be stored.","category":"page"},{"location":"settings/","page":"Settings","title":"Settings","text":"# FLORIDyn project configuration\n#\n# Flow conditions\n# Choose the input files for wind velocity, direction and ambient turbulence intensity as well as shear.\nwind:\n  # Velocity Input\n  # - I_and_I       uses the Immersion and Invariance effective wind speed estimator based on SOWFA data. \n  # - Interpolation linearly interpolates between set-points, the value is equally used for all turbines.\n  # - Interpolation_wErrorCov Same as above, but with error covariance. \n  # - InterpTurbine also linearly interpolates between set-points, but individually for every turbine. \n  # - InterpTurbine_wErrorCov Same as above, but with error covariance.\n  # - Constant      provides a constant velocity for all turbines.\n  # - Constant_wErrorCov      Same as above, but with error covariance.\n  # - EnKF_InterpTurbine\n  # - RW_with_Mean  random walk with mean\n  # - ZOH_wErrorCov\n  input_vel: Constant\n\n  # Wind Direction Input\n  # - Constant\n  # - Constant_wErrorCov\n  # - Interpolation\n  # - Interpolation_wErrorCov\n  # - InterpTurbine\n  # - InterpTurbine_wErrorCov\n  # - RW_with_mean             random walk with mean\n  input_dir: Interpolation\n  input_ti: Constant\n  input_shear: PowerLaw\n  correction:\n    vel: None\n    dir: All\n    ti: None\n  perturbation:\n    vel: 0\n    vel_sigma: 0.2\n    dir: 0\n    dir_sigma: 0.5\n    ti: 0\n    ti_sigma: 0.005\n\nsim:\n  # the used FLORIS model; currently, only 'gaussian' is supported\n  floris: gaussian\n  # start & end time of the simulation and the time resolution. \n  start_time: 20000       # [s]\n  end_time: 21200         # [s]\n  time_step: 4            # [s]\n\n  # The discretization method, 'sunflower' or 'isocell'. The latter provides a regular grid \n  # with equal sized cells. This is the favoured method! Downside is that the number of cells\n  # can not be chosen freely, the algorithm might correct the requested number of cells to \n  # the nearest possible number (3, 12, 27, 48, 75, 108, 147, ...).  \n  # Sunflower distributes based on an outgoing spiral, the number of cells can be freely chosen.\n  rotor_discret: isocell\n  rotor_points: 50 # number of points for the discretization of the rotor disk\n  \n  # Dynamic settings\n  dyn:\n    # Advection speed\n    # Multiplier of the travel speed of the OPs with their own wind speed. \n    # The published FLORIDyn models used 1, other literature suggests values as low as 0.6.\n    advection: 1\n    advection_mod: linear\n    # Operating point (OP) / wind field propagation\n    # 'Basic'    iterates the OPs based on their wind speed, OPs do not interact with each other. \n    # 'Averaged' is a weighted average between the new wind speed value and the old value. \n    #            This smoothes out turbulent inputs and reduces the occasions when one OP overtakes another OP. \n    # 'Maximum'  overwrites the state of a slower OP once the faster one overtakes it.\n    op_iteration: IterateOPs_basic\n    # In case the averaging is used, provide weights for the new value (first weight) \n    # and the old value (second value). They have to sum up to 1.\n    op_iter_weights: [0.7, 0.3]\n    vel:\n      # Spacial-Time-Averaged weight settings for the wind speed\n      #   Lejeune: 512 63 126\n      #   Becker Energies: 256 126 256\n      #   Becker CLC: 256 256 50\n      iter_sigma_dw: 256\n      iter_sigma_cw: 256\n      iter_sigma_time: 50\n    dir:\n      # Spacial-Time-Averaged weight settings for the wind direction\n      iter_sigma_dw: 512\n      iter_sigma_cw: 512\n      iter_sigma_time: 50\n  # Choose if simulation should be initialized, an initialized state should be loaded \n  # or should be started without initialization.\n  init: noinit # 'noinit' or 'load' (load requires initT.jld2)\n  path_to_data: \"data/2021_9T_Data\"\n  save_init_state: false  # if true, stores T_init.jld2\n  save_final_state: false # if true, stores T_final.jld2\n\n# Controller\n# Currently only the yaw angle can be set, the axial induction factor is always set to 1/3.\n# - 'Interpolate' per turbine reads an orientation file 'Control_YawInterpolation.csv' \n#                 to interpolate the turbines world orientation between different set-points. \n# - SOWFA         reads the file 'SOWFA_nacelleYaw.csv' which is directly the renamed file\n#                 from a SOWFA simulation. \n# - Constant      reads a single orientation and applies it to all turbines at all times.\ncon:\n  yaw: SOWFA\n\nfloris:\n  alpha: 2.32\n  beta: 0.154\n  k_a: 0.3837\n  k_b: 0.0037\n  k_fa: 0.73\n  k_fb: 0.8325\n  k_fc: 0.0325\n  k_fd: -0.32\n  eta: 1\n  p_p: 2.2\n  airDen: 1.225 # kg/m^3 (SOWFA)\n  TIexp: 3 # TI crosswind distribution is modelled as a factor of sigma_y and sigma_z.\n           # This is in contrast to previous literature which assumed a fixed box area and the\n           # turbines therein as source of higher TI.\n\nfloridyn:\n  n_op: 200\n  deltaUW: 10.0\n  deltaDW: 0.5\n  deltaCW: 3.0\n  dynStateChange: \"None\"\n  twf_model: \"heterogeneous\"\n\nturbines:\n    - id: 1\n      type: DTU 10MW\n      x: 600\n      y: 2400\n      z: 0\n      a: 0.33\n      yaw: 0\n      ti: 0.06\n...\n    - id: 9\n      type: DTU 10MW\n      x: 2400\n      y: 600\n      z: 0\n      a: 0.33\n      yaw: 0\n      ti: 0.06\n","category":"page"},{"location":"settings/#Types-created-from-the-yaml-file","page":"Settings","title":"Types created from the yaml file","text":"","category":"section"},{"location":"settings/#FLORIDyn.Sim","page":"Settings","title":"FLORIDyn.Sim","text":"Sim\n\nA mutable struct representing the simulation settings.\n\nFields\n\nfloris::String: The name of the FLORIS model to be used.\nstart_time::Int64: The start time of the simulation in seconds.\nend_time::Int64: The end time of the simulation in seconds.\ntime_step::Int64: The time step for the simulation in seconds.\nsim_step::Union{Nothing, Int64}: Optional simulation step size.\nn_sim_steps::Union{Nothing, Int64}: Optional number of simulation steps.\nrotor_discret::String: The rotor discretization method, e.g., \"Uniform\", \"Gaussian\".\nrotor_points::Int64: The number of rotor points for discretization.\ndyn::Dyn: The dynamic settings for the simulation.\ninit::String: The initialization method, e.g., \"init\", \"load\".\npath_to_data::String: The path to the directory where simulation data is stored.\nsave_init_state::Bool: Whether to save the initial state of the simulation.\nsave_final_state::Bool: Whether to save the final state of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Wind","page":"Settings","title":"FLORIDyn.Wind","text":"Wind\n\nA mutable struct representing wind settings.\n\nFields\n\ninput_vel::String: The type of wind velocity input, e.g., \"Constant\", \"Interpolation\".\ninput_dir::String: The type of wind direction input, e.g., \"Constant\", \"Interpolation\".\ninput_ti::String: The type of turbulence intensity input, e.g., \"Constant\", \"Interpolation\".\ninput_shear::String: The type of wind shear input, e.g., \"PowerLaw\", \"Interpolation\".\ncorrection::WindCorrection: Settings for wind corrections.\nperturbation::WindPerturbation: Settings for wind perturbations.\nvel::Union{Nothing, Float64}: Optional wind velocity value.\ndir::Union{Nothing, Matrix{Float64}, WindDirMatrix, WindDirType, WindDirTriple}: Optional wind direction matrix or covariance data.\nti::Union{Nothing, Float64}: Optional turbulence intensity value.\nshear::Union{Nothing, WindShear}: Optional wind shear profile.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Con","page":"Settings","title":"FLORIDyn.Con","text":"Con\n\nA mutable struct for configuration settings.\n\nFields\n\nyaw::String: The yaw control strategy, e.g., \"Constant\", \"Interpolation\".\nyaw_data::Union{Nothing, Matrix{Float64}}: Optional yaw data matrix.\ntanh_yaw::Bool: Whether to use hyperbolic tangent yaw control.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Floris","page":"Settings","title":"FLORIDyn.Floris","text":"Floris\n\nA mutable struct representing the settings for the FLORIDyn simulation. \n\nFields\n\nalpha::Float64: The alpha parameter for the FLORIS model.\nbeta::Float64: The beta parameter for the FLORIS model.\nk_a::Float64: The k_a parameter for the FLORIS model.\nk_b::Float64: The k_b parameter for the FLORIS model.\nk_fa::Float64: The k_fa parameter for the FLORIS model.\nk_fb::Float64: The k_fb parameter for the FLORIS model.\nk_fc::Float64: The k_fc parameter for the FLORIS model.\nk_fd::Float64: The k_fd parameter for the FLORIS model.\neta::Int: The eta parameter for the FLORIS model.\np_p::Float64: The p_p parameter for the FLORIS model.\nairDen::Float64: The air density for the FLORIS model.\nTIexp::Int: The turbulence intensity exponent for the FLORIS model.\nrotor_points::Union{Nothing, Int64}: Optional number of rotor points.\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.FloriDyn","page":"Settings","title":"FLORIDyn.FloriDyn","text":"FloriDyn\n\nA structure representing the settings for the FLORIDyn simulation environment.\n\nFields\n\nn_op::Int: The number of operating points.\ndeltaUW::Float64: The delta U wind speed perturbation.\ndeltaDW::Float64: The delta D wind direction perturbation.\ndeltaCW::Float64: The delta C wind turbulence intensity perturbation.\ndynStateChange::String: The type of dynamic state change, e.g., \"Constant\", \"Interpolation\".\ntwf_model::String: The type of TWF (Turbine Wake Flow) model used, e.g., \"Gaussian\", \"FLORIDyn\".\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.TurbineArray","page":"Settings","title":"FLORIDyn.TurbineArray","text":"TurbineArray\n\nA structure representing the configuration and properties of a wind turbine array.\n\nFields\n\npos::Matrix{Float64}: A matrix containing the positions of turbines. Each row represents                         a turbine with columns for x, y, and z coordinates (in meters).\ntype::Vector{String}: A vector of strings specifying the type/model of each turbine.\ninit_States::Matrix{Float64}: A matrix containing the initial states of each turbine.                                 Each row represents a turbine with columns for:                                 - Column 1: a - axial induction factor                                 - Column 2: yaw - initial yaw angle (in degrees)                                 - Column 3: ti - turbulence intensity\n\nExample\n\n# Create a simple 2-turbine array\npos = [0.0 0.0 0.0; 500.0 0.0 0.0]  # Two turbines 500m apart\ntype = [\"NREL_5MW\", \"NREL_5MW\"]\ninit_states = [0.33 0.0 0.1; 0.33 0.0 0.1]  # Both start with same initial conditions\nturbines = TurbineArray(pos, type, init_states)\n\n\n\n\n\n","category":"type"},{"location":"settings/#Types-created-manually","page":"Settings","title":"Types created manually","text":"","category":"section"},{"location":"settings/#FLORIDyn.Vis","page":"Settings","title":"FLORIDyn.Vis","text":"Vis\n\nA mutable struct for visualization settings in wind farm simulations.\n\nThis struct controls visualization options during simulation runtime, particularly for live plotting and animation features.\n\nFields\n\nonline::Bool: Enable/disable online visualization during simulation. When true,                  live plots and animations are displayed during the simulation run.                 When false, visualization is disabled for faster computation.\nsave::Bool: Enable/disable saving of plots to disk. When true, each plot is saved               after displaying it in the 'video' folder. When false, plots are only displayed.\nv_min::Float64: Minimum velocity value for color scale in flow field visualizations.                   Used to set consistent color scale limits across animation frames.\nv_max::Float64: Maximum velocity value for color scale in effective wind speed visualizations (msr=3).                   Used to set consistent upper limits across animation frames.\nrel_v_min::Float64: Minimum relative velocity value for velocity reduction visualizations.                       Controls the color scale for relative wind speed plots (msr=1). Range: [0, 100].\nrel_v_max::Float64: Maximum relative velocity value for velocity reduction visualizations (msr=1).                       Controls the upper limit for relative wind speed plots. Range: [0, 100].\nturb_max::Float64: Maximum turbulence value for added turbulence visualizations (msr=2).                      Controls the upper limit for turbulence plots.\nup_int::Int: Update interval - controls how frequently visualization updates occur.                Higher values result in less frequent updates for better performance.\n\nExample\n\n# Enable online visualization with plot saving and custom color scales\nvis = Vis(online=true, save=true, v_min=2.0, v_max=12.0, rel_v_min=20.0, rel_v_max=100.0, up_int=5)\n\n# Display only, no saving with default color scales\nvis = Vis(online=true, save=false, v_min=2.0, rel_v_min=20.0)\n\n# Disable online visualization for batch processing\nvis = Vis(online=false, save=false)\n\nNotes\n\nOnline visualization significantly slows down simulation performance\nUseful for debugging, monitoring simulation progress, or creating videos of the simulation\nWhen disabled, visualization functions are skipped to improve computational efficiency\nv_min helps maintain consistent color scales for effective wind speed visualizations (msr=3)\nrel_v_min helps maintain consistent color scales for velocity reduction visualizations (msr=1)\nup_int can be used to reduce visualization frequency and improve simulation speed\nsave=true will create a 'video' folder if it doesn't exist and save each plot frame for animation creation\nunit_test=true enables unit test mode for visualization functions (closes plots automatically after 1 second)\n\n\n\n\n\n","category":"type"},{"location":"settings/#Settings","page":"Settings","title":"Settings","text":"","category":"section"},{"location":"settings/#FLORIDyn.install_examples","page":"Settings","title":"FLORIDyn.install_examples","text":"install_examples(add_packages=true)\n\nInstall example files, executables, and data files for the FLORIDyn.jl package.\n\nThis function sets up a complete working environment by copying:\n\nExample Julia scripts from the package's examples directory (via copy_examples)\nExecutable scripts (like run_julia) to a local bin directory (via copy_bin)\nModel configuration files and data to a local data directory (via copy_model_settings)\n\nArguments\n\nadd_packages::Bool=true: Whether to automatically install additional required packages  (\"LaTeXStrings\", \"Timers\") that are commonly used in the examples\n\nExample\n\n# Install examples with automatic package installation\ninstall_examples()\n\n# Install examples without installing additional packages\ninstall_examples(false)\n\nAfter running this function, you can:\n\nRun example scripts from the created examples/ directory\nExecute ./bin/run_julia to start Julia with the project environment\nAccess model data files in the data/ directory\n\nSee also: copy_examples, copy_bin, copy_model_settings\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.copy_examples","page":"Settings","title":"FLORIDyn.copy_examples","text":"copy_examples()\n\nCopy all example scripts to the folder \"examples\" (it will be created if it doesn't exist).\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.copy_model_settings","page":"Settings","title":"FLORIDyn.copy_model_settings","text":"copy_model_settings()\n\nCopy model configuration files and data directories to the local data directory.\n\nThis function copies essential model configuration files and simulation data from the package's  data directory to a local data/ directory in the current working directory. \n\nFiles and Directories Copied\n\nConfiguration File\n\n2021_9T_Data.yaml: Main wind farm configuration file containing turbine layout, simulation parameters,  and model settings\n\nData Directory\n\n2021_9T_Data/: Complete SOWFA simulation data directory containing:\nSOWFA_bladePitch.csv: Blade pitch angle time series\nSOWFA_generatorPower.csv: Generator power output data\nSOWFA_generatorTorque.csv: Generator torque measurements\nSOWFA_nacelleYaw.csv: Nacelle yaw angle data\nSOWFA_rotorSpeedFiltered.csv: Filtered rotor speed measurements\nU.csv, WindVel.csv: Wind velocity data\nWindDir.csv, WindDirConstant.csv: Wind direction measurements\nWindTI.csv, WindTIConstant.csv: Turbulence intensity data\nAdditional covariance and profile files\n\nAutomatic Operations\n\nThe function automatically:\n\nCreates the data/ directory if it doesn't exist\nCopies the main YAML configuration file using copy_files\nRecursively copies the entire 2021_9T_Data/ subdirectory with all CSV files\nSets proper file permissions (0o774) on all copied files\n\nThis function is called as part of install_examples to set up a complete  working environment with all necessary configuration files and simulation data.\n\nSee also: copy_files, install_examples\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.copy_bin","page":"Settings","title":"FLORIDyn.copy_bin","text":"copy_bin()\n\nCopy the script run_julia to the folder \"bin\" (it will be created if it doesn't exist).\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.copy_files","page":"Settings","title":"FLORIDyn.copy_files","text":"copy_files(relpath, files)\n\nCopy a list of files from the package directory to a local directory.\n\nThis utility function copies files from the package's source directory structure to  a corresponding local directory. It automatically handles directory creation and  sets appropriate file permissions.\n\nArguments\n\nrelpath::String: The relative path (directory name) within both the package and  local filesystem where files should be copied\nfiles::Vector{String}: A vector of filenames to copy from the source to destination\n\nDetails\n\nThe function:\n\nCreates the destination directory (relpath) if it doesn't exist\nCopies each file from <package_dir>/<relpath>/<file> to ./<relpath>/<file>\nSets executable permissions (0o774) on all copied files\nOverwrites existing files (uses force=true)\n\nReturns\n\nVector{String}: The list of files that were copied (same as input files)\n\nExample\n\n# Copy specific example files to local examples directory\ncopy_files(\"examples\", [\"main.jl\", \"menu.jl\"])\n\n# Copy data files to local data directory  \ncopy_files(\"data\", [\"config.yaml\", \"turbine_data.csv\"])\n\nThis function is used internally by copy_examples, copy_model_settings,  and other file copying utilities.\n\nSee also: copy_examples, copy_model_settings, copy_bin\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.setup","page":"Settings","title":"FLORIDyn.setup","text":"setup(filename)\n\nInitializes or configures the system using the provided filename. The filename should specify the path to a configuration or settings file required for setup.\n\nArguments\n\nfilename::String: Path to the .yaml file to be used for setup.\n\nReturns\n\nThe tuple (wind, sim, con) where:\nwind: An instance of the Wind struct containing wind-related parameters.\nsim: An instance of the Sim struct containing simulation parameters.\ncon: An instance of the Con struct containing controller parameters.\nfloris: An instance of the Floris struct containing FLORIS model parameters.\nfloridyn: An instance of the FloriDyn struct containing FLORIDyn model parameters.\n\n\n\n\n\n","category":"function"},{"location":"settings/#FLORIDyn.Settings","page":"Settings","title":"FLORIDyn.Settings","text":"Settings\n\nA mutable struct that holds configuration parameters for the FLORIDyn simulation environment.\n\nFields\n\nvel_mode::VelModel: See: VelModel\ndir_mode::DirModel: See: DirModel\nturb_mode\nshear_mode\ncor_dir_mode\ncor_vel_mode\ncor_turb_mode\niterate_mode\ncontrol_mode\nparallel::Bool:  Run plotting in a separate process.\nthreading::Bool: Enable threading for parallel computation within a single process\n\n\n\n\n\n","category":"type"},{"location":"settings/#FLORIDyn.Settings-Tuple{Wind, Sim, Con}","page":"Settings","title":"FLORIDyn.Settings","text":"Settings(wind::Wind, sim::Sim, con::Con, parallel=false, threading=false)\n\nCreate and return a Settings object using the provided wind and sim parameters.\n\nArguments\n\nwind::Wind: An instance of the Wind struct containing wind-related parameters.\nsim::Sim: An instance of the Sim struct containing the simulation parameters.\ncon::Con: An instance of the Con struct containing the controller parameters.\nparallel::Bool:  Enable plotting in a separate process (default: false)\nthreading::Bool: Enable threading for parallel computation within a single process (default: false)\n\nReturns\n\nA Settings struct configured with the given wind and simulation parameters.\n\nNotes\n\nThe function uses the str2type helper to convert string representations of model types  into their corresponding Julia types.\nThe Settings struct encapsulates the model settings for velocity, direction,  turbulence intensity, shear, and correction modes.\n\n\n\n\n\n","category":"method"},{"location":"settings/#FLORIDyn.getTurbineData","page":"Settings","title":"FLORIDyn.getTurbineData","text":"getTurbineData(names::Vector{String}) -> NamedTuple\n\nRetrieve nacelle positions and rotor diameters for a given list of wind turbine types.\n\nArguments\n\nnames::Vector{String}: A vector of wind turbine type names. Supported types include:\n\"DTU 10MW\"\n\"DTU 5MW\"\n\"Senvion 6.2M\"\n\"V116\"\n\"V117\"\n\"V162\"\n\"GE Haliade X\"\n\nReturns\n\nA NamedTuple with the following fields:\nNacPos::Matrix{Float64}: An N × 3 matrix where each row corresponds to the (x, y, z) coordinates of the nacelle position for each turbine.\nD::Vector{Float64}: A vector of rotor diameters corresponding to each turbine.\n\nRaises\n\nArgumentError if an unknown or misspelled turbine name is encountered.\n\n\n\n\n\n","category":"function"},{"location":"developer/#Developer-notes","page":"Developer notes","title":"Developer notes","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"This page contains information for developers who want to contribute to or extend FLORIDyn.jl.","category":"page"},{"location":"developer/#Project-structure","page":"Developer notes","title":"Project structure","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The FLORIDyn.jl package is organized into several modules:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"src/ - Main source code\ncontroller/    - Controller implementations\ncorrection/    - Wake correction models\nfloridyn_cl/   - Main simulation loop\nfloris/        - FLORIS model implementations\nwindfield/     - Wind field modeling\nvisualisation/ - Plotting and helper functions\ntest/ - Test suite\nexamples/ - Example scripts\ndocs/  - Documentation source\ndata/  - Example data files and configuration settings\nvideo/ - PNG and MP4 output files\nbin/   - Bash scripts to start Julia and for statistics","category":"page"},{"location":"developer/#Development-workflow","page":"Developer notes","title":"Development workflow","text":"","category":"section"},{"location":"developer/#Setting-up-the-development-environment","page":"Developer notes","title":"Setting up the development environment","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"On Linux, make sure that Python3 and Matplotlib are installed:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"sudo apt install python3-matplotlib","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Make sure that ControlPlots.jl works as explained here.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Clone the repository:\ngit clone https://github.com/ufechner7/FLORIDyn.jl.git\ncd FLORIDyn.jl\nActivate the project environment and update the packages:\nusing Pkg\nPkg.activate(\".\")\nPkg.up()","category":"page"},{"location":"developer/#Running-tests","page":"Developer notes","title":"Running tests","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To run the full test suite:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"using Pkg\nPkg.test()","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To run specific tests:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"test/test_floris.jl\")","category":"page"},{"location":"developer/#Debugging","page":"Developer notes","title":"Debugging","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Suggestion: Use Infiltrator.jl for debugging.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Add two lines to your .bashrc script (create one if it does not exist yet):","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"alias jl='./bin/run_julia'\nalias jl2='./bin/run_julia2'","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Install the packages Infiltrator.jl and Revise.jl in your global environment:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"julia -e 'using Pkg; Pkg.add(\"Revise\"); Pkg.add(\"Infiltrator\")'","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Now you can launch Julia by typing jl, and for debugging type jl2.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Debugging session:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"bash> jl2\njulia> using FLORIDyn\nAdd the line Main.@infiltrate at the location where you want to set a break point.\njulia> include(\"examples/main.jl\")","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Now the program should run into your breakpoint. You should see the prompt:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"infil> ","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"and by typing the name of any local or global variable you can inspect the content. You can also execute any statement that fails and modify it until it works.","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Important: When executing STEP 2, the line Main.@infiltrate must not exist or must be commented.","category":"page"},{"location":"developer/#Building-documentation","page":"Developer notes","title":"Building documentation","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"To build the documentation locally:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"scripts/build_docu.jl\")","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"You can get an overview over the exported methods by running the script:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"include(\"scripts/stats.jl\")","category":"page"},{"location":"developer/#Code-style-and-conventions","page":"Developer notes","title":"Code style and conventions","text":"","category":"section"},{"location":"developer/#Naming-conventions","page":"Developer notes","title":"Naming conventions","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Use descriptive variable names\nFollow Julia naming conventions (lowercase with underscores for functions and variables)\nType names should use CamelCase\nConstants should be ALL_CAPS","category":"page"},{"location":"developer/#Code-organization","page":"Developer notes","title":"Code organization","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Keep functions focused and small\nUse meaningful docstrings for all exported functions\nInclude type annotations where helpful for clarity\nFollow the existing module structure","category":"page"},{"location":"developer/#Testing","page":"Developer notes","title":"Testing","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Write tests for new functionality\nEnsure all tests pass before submitting pull requests\nInclude edge cases in test coverage\nUse descriptive test names","category":"page"},{"location":"developer/#Contributing","page":"Developer notes","title":"Contributing","text":"","category":"section"},{"location":"developer/#Pull-requests","page":"Developer notes","title":"Pull requests","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Fork the repository\nCreate a feature branch\nMake your changes\nAdd tests for new functionality\nEnsure all tests pass\nUpdate documentation if needed\nSubmit a pull request","category":"page"},{"location":"developer/#Issues","page":"Developer notes","title":"Issues","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"When reporting issues, please include:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Julia version\nFLORIDyn.jl version\nMinimal working example\nError messages and stack traces","category":"page"},{"location":"developer/#Architecture-overview","page":"Developer notes","title":"Architecture overview","text":"","category":"section"},{"location":"developer/#Core-simulation-loop","page":"Developer notes","title":"Core simulation loop","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The main simulation is handled by the floridyn_cl module, which implements the time-stepping algorithm for wake evolution.","category":"page"},{"location":"developer/#Wake-models","page":"Developer notes","title":"Wake models","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The package supports multiple wake models through abstract types:","category":"page"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"VelModel - Velocity deficit models\nDirModel - Wake deflection models\nTurbulenceModel - Turbulence intensity models","category":"page"},{"location":"developer/#Settings-system","page":"Developer notes","title":"Settings system","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"Configuration is handled through YAML files that are parsed into Julia structs. See the Settings documentation for details.","category":"page"},{"location":"developer/#Performance-considerations","page":"Developer notes","title":"Performance considerations","text":"","category":"section"},{"location":"developer/","page":"Developer notes","title":"Developer notes","text":"The simulation uses in-place operations where possible to minimize allocations\nKey loops are optimized for performance\nConsider using @profile and BenchmarkTools.jl when optimizing code\nRead the performance tips","category":"page"},{"location":"analysis/#Column-Major-Access-Pattern-Analysis-for-FLORIDyn.jl","page":"-","title":"Column-Major Access Pattern Analysis for FLORIDyn.jl","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Based on my analysis of the src folder, I found several performance-critical patterns that could be slow in Julia due to column-major access:","category":"page"},{"location":"analysis/#**Summary-of-Issues-Found:**","page":"-","title":"Summary of Issues Found:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Column Access Patterns: 52 instances of [:, N] column access patterns\nTranspose Operations: Multiple instances of unnecessary transpose operations\nMemory Layout Issues: Several patterns that fight against Julia's column-major memory layout","category":"page"},{"location":"analysis/#**Major-Performance-Issues-Identified:**","page":"-","title":"Major Performance Issues Identified:","text":"","category":"section"},{"location":"analysis/#1.-**Column-wise-Operations-on-Large-Matrices**","page":"-","title":"1. Column-wise Operations on Large Matrices","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 180, 185, 190)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Column-wise access on potentially large matrices\nwf.States_WF[:, 1] .+= Wind.perturbation.vel_sigma * randn(wf.nOP *wf.nT)\nwf.States_WF[:, 2] .+= Wind.perturbation.dir_sigma * randn(wf.nOP *wf.nT)  \nwf.States_WF[:, 3] .+= Wind.perturbation.ti_sigma * randn(wf.nOP *wf.nT)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: High - These are in perturbationOfTheWF!() which runs every simulation step.","category":"page"},{"location":"analysis/#2.-**Unnecessary-Transpose-Repeat-Operations**","page":"-","title":"2. Unnecessary Transpose + Repeat Operations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 514-516)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Multiple transpose operations with repeat\ntmp_Tpos = repeat(wf.posBase[iT,:]' + wf.posNac[iT,:]', tmp_nT)\ntmp_WF   = repeat(iTWFState', tmp_nT)\ntmp_Tst  = repeat((wf.States_T[wf.StartI[iT], :])', tmp_nT)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Medium-High - In critical simulation loop, causes unnecessary memory allocations.","category":"page"},{"location":"analysis/#3.-**Column-Access-in-Distance-Calculations**","page":"-","title":"3. Column Access in Distance Calculations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: floridyn_cl.jl (Lines 258, 361)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Transpose in distance calculations\ndistOP_iiT = sum((wf.posBase[iiT, 1:2]' .-wf.States_OP[idx_range, 1:2]).^2, dims=2)\ndist = sqrt.(sum((OP_positions' .- turb_pos).^2, dims=2))","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Medium - Called for every turbine pair interaction.","category":"page"},{"location":"analysis/#4.-**Column-wise-Access-in-FLORIS-Calculations**","page":"-","title":"4. Column-wise Access in FLORIS Calculations","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"File: gaussian.jl (Lines 492-493, 499, 501, 528)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Multiple column accesses on rotor point matrices\ncw_y = tmp_RPs[:, 2] .- delta[:, 1]\ncw_z = tmp_RPs[:, 3] .- delta[:, 2]\n# ... and many more column accesses","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: High - Core wake calculation, runs frequently with large rotor point matrices.","category":"page"},{"location":"analysis/#5.-**Data-Loading-Column-Access**","page":"-","title":"5. Data Loading Column Access","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Files: src/windfield/windfield_*.jl (Multiple lines)","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"# PROBLEMATIC: Column-wise data access during file reading\ntimes = WindDir[:, 1]\nphis = WindDir[:, 2]\nspeeds = WindVel[:, 2]","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Impact: Low-Medium - Mainly during initialization, but still inefficient.","category":"page"},{"location":"analysis/#**Performance-Impact-Assessment:**","page":"-","title":"Performance Impact Assessment:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"High Impact (Critical):\nStates_WF[:, N] operations in perturbationOfTheWF!() - ~15-20% simulation slowdown\nColumn access in gaussian.jl FLORIS calculations - ~10-15% wake calculation slowdown\nMedium Impact (Important):\nTranspose + repeat operations in setUpTmpWFAndRun() - ~5-10% per turbine setup\nDistance calculation transposes - ~5% turbine interaction overhead\nLow Impact (Optimization):\nData loading column access - ~1-2% initialization time","category":"page"},{"location":"analysis/#**Estimated-Total-Performance-Impact:**","page":"-","title":"Estimated Total Performance Impact:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"The column-major access patterns likely cause 20-35% overall performance degradation in the simulation, with the worst impact during:","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"Wind field perturbation operations (every time step)\nWake interaction calculations (most computationally intensive part)\nMulti-turbine setup operations (scales with number of turbines)","category":"page"},{"location":"analysis/#**Recommendations-for-Fixes:**","page":"-","title":"Recommendations for Fixes:","text":"","category":"section"},{"location":"analysis/","page":"-","title":"-","text":"Restructure data layout to be row-major for frequently accessed operations\nUse views instead of column slices where possible  \nPre-allocate and reuse temporary arrays instead of transpose operations\nConsider using StaticArrays.jl for small fixed-size operations\nBatch operations to work on contiguous memory when possible","category":"page"},{"location":"analysis/","page":"-","title":"-","text":"The good news is that most of these issues are localized to specific functions and can be fixed systematically without major architectural changes.","category":"page"},{"location":"functions_II/#High-Level-Functions","page":"High-Level Functions","title":"High-Level Functions","text":"","category":"section"},{"location":"functions_II/#FLORIS","page":"High-Level Functions","title":"FLORIS","text":"","category":"section"},{"location":"functions_II/#FLORIDyn.calcCt","page":"High-Level Functions","title":"FLORIDyn.calcCt","text":"calcCt(a, _) -> Number or Vector\n\nCalculate the thrust coefficient ct for a wind turbine based on the axial induction factor a.\n\nArguments\n\na: Axial induction factor, typically between 0 and 0.5 (can be a scalar or vector)\n_: unused parameter\n\nReturns\n\nct::Number: The calculated thrust coefficient.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.centerline","page":"High-Level Functions","title":"FLORIDyn.centerline","text":"centerline(states_op, states_t, states_wf, floris, d_rotor) -> Matrix{Float64}\n\nCompute the centerline wake properties for a wind farm simulation.\n\nArguments\n\nstates_op: Operational states of the turbines (e.g., yaw, pitch, etc.).\nstates_t: Turbine-specific states (e.g., rotor speed, torque, etc.).\nstates_wf: Wind farm-level states (e.g., wind direction, wind speed, etc.).\nfloris: Parameters for the FLORIS wake model.\nd_rotor: Rotor diameter or characteristic length scale.\n\nReturns\n\nThe computed centerline wake properties delta, which includes the deflection in the y and z directions.\n\nNotes\n\nThis function is part of the Gaussian wake model implementation.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.discretizeRotor","page":"High-Level Functions","title":"FLORIDyn.discretizeRotor","text":"discretizeRotor(n_rp::Int) -> Tuple{Matrix{Float64}, Vector{Float64}}\n\nDiscretizes the rotor into a n_rp segments. The algorithm returns the normalized center location ∈ [-0.5, 0.5] and the relative area the segment represents.\n\nArguments\n\nn_rp::Int: The number of radial points to discretize the rotor into.\n\nReturns\n\nThe tuple (m_rp, w) where:\nm_rp: A matrix of size (nC, 3) where nC is the number of segments. The first column is all zeros,   the second and third columns contain the normalized radial positions.\nw: A vector of weights corresponding to each segment, summing to approximately 1.\n\nNotes\n\nThe algorithm returns the normalized center location in the range [-0.5, 0.5] and the relative area that each segment represents.\nThe isocell algorithm is used, which may not yield exactly n_rp cells but aims to achieve a similar number.\nFor details, see the publication by Masset et al.: Masset et al. (2009)\nThe choice of N1 = 3 is made here, but values of 4 or 5 are also viable options. The choice of 3 is close to optimal.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.init_states","page":"High-Level Functions","title":"FLORIDyn.init_states","text":"init_states(set::Settings, wf::WindFarm, wind::Wind, init_turb, \n            floris::Floris, sim::Sim) -> Tuple{Matrix, Matrix, Matrix}\n\nInitialize the state arrays for wind farm simulation using the Gaussian wake model.\n\nThis function sets up the initial conditions for turbines, observation points, and wind field  states based on the provided configuration parameters. It computes initial positions, wind  conditions, and wake properties for each turbine in the wind farm.\n\nArguments\n\nset::Settings: Simulation settings containing configuration options for velocity, direction, and turbulence models\nwf::WindFarm: Wind farm object containing turbine positions, dimensions, and state arrays (see WindFarm)\nwind::Wind: Wind conditions including velocity, direction, and turbulence intensity data (see Wind)\ninit_turb: Initial turbine state parameters (axial induction factor, yaw angle, turbulence intensity)\nfloris::Floris: FLORIS model parameters for wake calculations (see Floris)\nsim::Sim: Simulation parameters including time step and start time (see Sim)\n\nReturns\n\nA tuple (states_op, states_t, states_wf) containing:\n\nstates_op::Matrix: Observation point states with 3D coordinates and wake positions\nstates_t::Matrix: Turbine states including control parameters and operational conditions  \nstates_wf::Matrix: Wind field states with velocity, direction, and turbulence data\n\nDescription\n\nThe function performs the following initialization steps for each turbine:\n\nRetrieves wind field data (velocity, direction, turbulence intensity) based on the specified input methods\nInitializes wind field states at all observation points for the turbine\nCalculates downwind distances for wake coordinate system\nSets initial turbine states from provided parameters\nComputes crosswind wake deflections using the centerline function\nTransforms coordinates from wake-relative to world coordinate system\nUpdates observation point positions including turbine base and nacelle offsets\n\nNotes\n\nSupports multiple wind input methods including interpolation, constant values, and random walk models\nHandles both 3D and 4D wind field configurations (with optional orientation data)\nUses SOWFA coordinate system conventions for angle transformations\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.getVars","page":"High-Level Functions","title":"FLORIDyn.getVars","text":"getVars(rps::Union{Matrix, Adjoint}, c_t, yaw, ti, ti0, \n        floris::Floris, d_rotor) -> Tuple{Vector, Vector, Vector, Vector, Vector, Vector, Vector}\n\nCompute and return variables related to the Gaussian wake model for wind turbines.\n\nIn particular, it calculates the field width, the potential core data and the deflection. These values are needed for the calculation of the wake shape and speed  reduction. The values are based of the state of every individual OP.\n\nArguments\n\nrps: Matrix of reference points where the variables are evaluated.\nc_t: Thrust coefficient(s) for the turbine(s).\nyaw: Yaw angle(s) of the turbine(s) in radians or degrees.\nti: Turbulence intensity at the reference points.\nti0: Ambient turbulence intensity.\nfloris::Floris: FLORIS model parameters containing Gaussian wake model parameters (see Floris).\nd_rotor: Rotor diameter(s) of the turbine(s).\n\nReturns\n\nReturns the tuple\n\nsig_y::Vector: Gaussian variance in y direction (sqrt of)\nsig_z::Vector: Gaussian variance in z direction (sqrt of)\nc_t: Thrust coefficient, same as OP.Ct\nx_0: Potential core length\ndelta: Deflection\npc_y: Potential core boundary in y dir\npc_z: Potential core boundary in z dir\n\nSOURCES\n\n[1] Experimental and theoretical study of wind turbine wakes in yawed conditions - M. Bastankhah and F. Porté-Agel\n[2] Design and analysis of a spatially heterogeneous wake - A. Farrell, J. King et al.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.getPower","page":"High-Level Functions","title":"FLORIDyn.getPower","text":"getPower(wf::WindFarm, m::AbstractMatrix, floris::Floris, con::Con)\n\nCalculate the power output of wind turbines in a wind farm simulation.\n\nThis function computes the power generated by wind turbines based on their operational states, wind conditions, and control settings. It accounts for yaw angle effects and optional yaw range constraints using hyperbolic tangent functions for smooth operational limits.\n\nArguments\n\nwf::WindFarm: Wind farm object containing turbine states, dimensions, and operational data with current axial induction factors and yaw angles (see WindFarm)\nm::Matrix: Measurement or simulation data matrix where column 3 contains effective wind speeds at turbine locations [m/s]\nfloris::Floris: FLORIS model parameters containing air density, drivetrain efficiency, and power curve parameters (see Floris)\ncon::Con: Controller configuration object with yaw control settings and operational constraints (see Con)\n\nReturns\n\nP::Vector{Float64}: Power output for each turbine in the wind farm [W]\n\nDescription\n\nThe function calculates power using the standard wind turbine power equation with yaw corrections:\n\nP = 0.5 × ρ × A × Cp × U³ × η × cos(γ)^p_p × f_yaw_constraints\n\nWhere:\n\nρ is air density [floris.airDen] [kg/m³]\nA is rotor swept area π × (D/2)² [m²]\nCp is power coefficient calculated as 4a(1-a)² [-]\nU is effective wind speed from column 3 of matrix m [m/s]\nη is drivetrain efficiency [floris.eta] [-]\nγ is yaw angle [rad]\np_p is yaw power exponent [floris.p_p] [-]\nf_yaw_constraints is optional yaw range constraint factor [-]\n\nThe yaw constraint factor is applied when con.tanh_yaw is true:\n\nf_yaw_constraints = [0.5 × tanh((γ_max - γ) × 50) + 0.5] × \n                           [-0.5 × tanh((γ_min - γ) × 50) + 0.5]\n\nNotes\n\nPower coefficient is calculated from axial induction factor: Cp = 4a(1-a)²\nYaw effects reduce power output according to cos(γ)^p_p where p_p is typically 1.88\nOptional yaw range constraints use hyperbolic tangent functions with slope factor 50 for smooth transitions\nWhen con.tanh_yaw is enabled, power is smoothly constrained within [con.yawRangeMin, con.yawRangeMax]\nThe constraint functions approach step functions but provide smooth gradients for optimization\nAxial induction factors are extracted from wf.States_T[wf.StartI, 1] for current time step\nYaw angles are converted from degrees to radians internally\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.runFLORIS","page":"High-Level Functions","title":"FLORIDyn.runFLORIS","text":"runFLORIS(set::Settings, location_t, states_wf, states_t, d_rotor, \n          floris::Floris, windshear::Union{Matrix, WindShear})\n\nExecute the FLORIS (FLOw Redirection and Induction in Steady State) wake model simulation for wind farm analysis.\n\nThis function performs a comprehensive wake analysis using the Gaussian wake model to calculate velocity reductions, turbulence intensity additions, and effective wind speeds at turbine locations. It accounts for wake interactions, rotor discretization, wind shear effects, and turbulence propagation.\n\nArguments\n\nset::Settings: Simulation settings containing configuration options for wind shear modeling\nlocation_t: Matrix of turbine positions [x, y, z] coordinates for each turbine [m]\nstates_wf: Wind field state matrix containing velocity, direction, and turbulence data\nstates_t: Turbine state matrix with axial induction factors, yaw angles, and turbulence intensities\nd_rotor: Vector of rotor diameters for each turbine [m]\nfloris::Floris: FLORIS model parameters containing wake model coefficients and rotor discretization settings (see Floris)\nwindshear: Wind shear profile data for vertical wind speed variation modeling, either a matrix or of type WindShear\n\nReturns\n\nA tuple (T_red_arr, T_aTI_arr, T_Ueff, T_weight) containing:\n\nT_red_arr::Vector{Float64}: Velocity reduction factors for each turbine [-]\nT_aTI_arr::Union{Vector{Float64}, Nothing}: Added turbulence intensity from upstream wakes [%]\nT_Ueff::Union{Float64, Nothing}: Effective wind speed at the last turbine location [m/s]\nT_weight::Union{Vector{Float64}, Nothing}: Gaussian weight factors for wake overlap calculations [-]\n\nDescription\n\nThe function performs the following computational steps:\n\n1. Rotor Discretization\n\nDiscretizes rotor planes into radial points using the isocell algorithm\nApplies yaw rotation transformations to rotor point coordinates\nHandles both active turbines (d_rotor > 0) and placeholder turbines\n\n2. Single Turbine Case\n\nFor single turbine simulations, only wind shear effects are calculated without wake interactions.\n\n3. Multi-Turbine Wake Analysis\n\nFor each upstream turbine affecting downstream turbines:\n\nCoordinate Transformations\n\nTransforms rotor points to wake coordinate system aligned with wind direction\nApplies rotational matrices for wind direction and turbine yaw angles\nFilters turbines based on minimum downstream distance (10 rotor diameters)\n\nWake Variable Calculations\n\nComputes wake expansion coefficients, potential core dimensions, and deflection using getVars\nCalculates crosswind wake positions and radial distances from wake centerline\nDetermines core region boundaries and near/far wake transitions\n\nVelocity Reduction Modeling\n\nApplies different deficit models for core region vs. Gaussian wake regions\nUses velocity deficit superposition for multiple wake interactions\nAccounts for yaw-induced wake deflection and asymmetry\n\nTurbulence Intensity Enhancement\n\nCalculates added turbulence intensity using empirical correlations\nApplies Gaussian weighting for spatial distribution of turbulence enhancement\nUses parameters kfa, kfb, kfc, kfd for turbulence intensity modeling\n\n4. Wind Shear Integration\n\nApplies vertical wind shear corrections to the downstream turbine\nUses wind shear profile data for realistic boundary layer effects\n\nMathematical Models\n\nThe function implements several key wake modeling equations:\n\nVelocity Deficit: Based on Gaussian wake theory with yaw corrections Deflection: Uses analytical wake deflection models for yawed turbines   Turbulence: Empirical correlations for wake-added turbulence intensity Superposition: Linear superposition of velocity deficits from multiple wakes\n\nNotes\n\nUses SOWFA (Simulator for Offshore Wind Farm Applications) coordinate conventions\nImplements state-of-the-art Gaussian wake model with yaw considerations\nSupports both research and engineering applications for wind farm optimization\nComputational complexity scales as O(N²) for N turbines due to wake interactions\nRequires proper initialization of turbine states and wind field conditions\n\nReferences\n\nBastankhah, M. and Porté-Agel, F. (2016). Experimental and theoretical study of wind turbine wakes in yawed conditions\nNiayifar, A. and Porté-Agel, F. (2016). Analytical modeling of wind farms: A new approach for power prediction\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn","page":"High-Level Functions","title":"FLORIDyn","text":"","category":"section"},{"location":"functions_II/#FLORIDyn.initSimulation","page":"High-Level Functions","title":"FLORIDyn.initSimulation","text":"initSimulation(wf::Union{Nothing, WindFarm}, sim::Sim) -> Union{Nothing, WindFarm}\n\nInitialize or load a wind farm simulation state based on simulation settings.\n\nThis function handles the initialization phase of a wind farm simulation by either saving  the current initialized state to disk or loading a previously saved state, depending on  the simulation configuration.\n\nArguments\n\nwf::Union{Nothing, WindFarm}: Wind farm object containing the initialized simulation state, or Nothing if no state is available. See WindFarm\nsim::Sim: Simulation configuration object containing initialization settings and file paths. See Sim\n\nReturns\n\nwf::Union{Nothing, WindFarm}: The wind farm state, either the original input state (for \"init\" mode) or a loaded state from disk (for \"load\" mode)\n\nBehavior\n\nThe function operates in two modes based on sim.init:\n\n\"init\" Mode\n\nUses the provided wind farm state as-is\nIf sim.save_init_state is true, saves the current state to \"T_init.jld2\" in the specified data directory\nLogs the save operation for user feedback\n\n\"load\" Mode\n\nAttempts to load a previously saved wind farm state from \"T_init.jld2\"\nFalls back to the provided state if loading fails (with warning)\nHandles file I/O errors gracefully\n\nFile Operations\n\nSave path: $(sim.path_to_data)/T_init.jld2\nFormat: JLD2 binary format for efficient Julia object serialization\nError handling: Loading failures produce warnings but do not halt execution\n\nNotes\n\nThe function is case-insensitive for the initialization mode string\nFile operations use the path specified in sim.path_to_data\nLoading errors are caught and logged as warnings, allowing simulation to proceed with the original state\nThis mechanism enables reproducible simulations by preserving and reusing initial conditions\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.findTurbineGroups","page":"High-Level Functions","title":"FLORIDyn.findTurbineGroups","text":"findTurbineGroups(wf::WindFarm, floridyn::FloriDyn) -> Vector{Vector{Int64}}\n\nDetermine wake interaction dependencies between turbines in a wind farm.\n\nThis function analyzes the spatial relationships between turbines to identify which turbines  are affected by the wakes of upstream turbines. It uses coordinate transformations to the  wind-aligned reference frame and geometric criteria to determine wake interactions.\n\nArguments\n\nwf::WindFarm: Wind farm object containing turbine positions, operational points, and wind field states. See WindFarm\nfloridyn::FloriDyn: FLORIDyn model parameters containing wake interaction thresholds. See FloriDyn\n\nReturns\n\nvv_dep::Vector{Vector{Int64}}: A vector of vectors where vv_dep[i] contains the indices of all turbines  that affect turbine i through wake interactions. Each inner vector lists the upstream turbine indices  that influence the wake conditions at the corresponding turbine.\n\nAlgorithm\n\nCoordinate Transformation: For each turbine pair, transforms coordinates to a wind-aligned frame using the closest operational point\nWake Zone Detection: Applies geometric criteria to determine if a downstream turbine lies within the wake zone:\nUpstream extent: r₁[1] ≥ -uw × D[iT] (allowing for slight upstream influence)\nDownstream extent: r₁[1] ≤ dw × D[iT] (wake extends downstream)  \nLateral extent: |r₁[2]| ≤ cw × D[iT] (wake width constraint)\nDependency Matrix: Constructs a boolean dependency matrix and extracts indices for each turbine\n\nMathematical Description\n\nThe wake interaction criteria are evaluated in the wind-aligned coordinate system:\n\nr₁ = R(φ) × (rₒₚ - rₜᵤᵣᵦ)\n\nwhere:\n\nR(φ) is the rotation matrix for wind direction angle φ\nrₒₚ is the position of the closest operational point from the upstream turbine\nrₜᵤᵣᵦ is the position of the downstream turbine being evaluated\n\nNotes\n\nThe function uses the closest operational point from each upstream turbine to determine wind direction\nWake zones are defined as multiples of rotor diameter using the FLORIDyn parameters\nSelf-interaction (turbine affecting itself) is explicitly excluded\nThe coordinate transformation accounts for the SOWFA wind direction convention\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.prepareSimulation","page":"High-Level Functions","title":"FLORIDyn.prepareSimulation","text":"prepareSimulation(set::Settings, wind::Wind, con::Con, floridyn::FloriDyn, \n                  floris::Floris, turbProp, sim::Sim) -> (WindFarm, Wind, Sim, Con, Floris)\n\nPrepares the simulation environment for a wind farm analysis using the provided settings and parameters.\n\nArguments\n\nset::Settings: Simulation settings containing configuration options.\nwind::Wind: Wind conditions or wind field data. See: Wind \ncon::Con: Controller parameters of the turbines.  See: Con\nfloridyn::FloriDyn: Parameters specific to the FLORIDyn model. See: FloriDyn\nfloris::Floris: Parameters specific to the FLORIS model. See: Floris\nturbProp: Properties of the turbines involved in the simulation.\nsim::Sim: Simulation-specific parameters or state. See: Sim\n\nArguments that get modified\n\nwind: Updated with wind velocity, direction, turbulence intensity, and shear profile.\ncon: Updated with yaw data.\nsim: Updated with the number of simulation steps.\nfloris: May include additional parameters for the FLORIS model.\n\nReturns\n\nReturns the tuple (wf, wind, sim, con, floris) where:\nwf: Wind farm struct containing turbine states and positions. See: WindFarm\nwind: Updated wind conditions.\nsim: Updated simulation parameters.\ncon: Updated controller parameters.\nfloris: Parameters for the FLORIS model.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.perturbationOfTheWF!","page":"High-Level Functions","title":"FLORIDyn.perturbationOfTheWF!","text":"perturbationOfTheWF!(wf::WindFarm, wind::Wind) -> Nothing\n\nApply stochastic perturbations to the wind field states in-place.\n\nThis function adds Gaussian noise to the wind field parameters to model measurement  uncertainty or natural variability in wind conditions. The perturbations are applied  conditionally based on the wind perturbation configuration and are added directly  to the wind farm state matrix.\n\nArguments\n\nwf::WindFarm: Wind farm struct containing the state matrix States_WF to be perturbed\nwind::Wind: Wind configuration struct containing perturbation settings. See Wind\n\nReturns\n\nnothing: The function modifies the wind farm state in-place\n\nBehavior\n\nThe function applies independent Gaussian perturbations to three wind field parameters:\n\nVelocity Perturbation\n\nCondition: wind.perturbation.vel == true\nTarget: Column 1 of wf.States_WF (wind velocity [m/s])\nNoise: wind.perturbation.vel_sigma * randn(nOP × nT)\n\nDirection Perturbation\n\nCondition: wind.perturbation.dir == true\nTarget: Column 2 of wf.States_WF (wind direction [degrees])\nNoise: wind.perturbation.dir_sigma * randn(nOP × nT)\n\nTurbulence Intensity Perturbation\n\nCondition: wind.perturbation.ti == true  \nTarget: Column 3 of wf.States_WF (turbulence intensity [-])\nNoise: wind.perturbation.ti_sigma * randn(nOP × nT)\n\nMathematical Description\n\nFor each enabled perturbation type, the function applies:\n\nStates_WF[:, col] += σ × N(0,1)\n\nwhere:\n\nσ is the standard deviation for the specific parameter\nN(0,1) is standard normal random noise with dimensions (nOP × nT)\nnOP is the number of operational points per turbine\nnT is the total number of turbines\n\nNotes\n\nThe function uses in-place modification (indicated by the ! suffix)\nPerturbations are applied independently to each operational point and turbine\nThe random noise follows a standard normal distribution scaled by the respective sigma values\nOnly enabled perturbation types (based on boolean flags) are applied\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.setUpTmpWFAndRun","page":"High-Level Functions","title":"FLORIDyn.setUpTmpWFAndRun","text":"setUpTmpWFAndRun(set::Settings, wf::WindFarm, \n                 floris::Floris, wind::Wind) --> (Matrix, WindFarm)\n\nExecute FLORIS wake calculations for all turbines in a wind farm with wake interactions.\n\nThis function orchestrates the computation of wake effects for each turbine by setting up  temporary wind farm configurations that include influencing upstream turbines. It handles  both single turbine (no wake interactions) and multi-turbine scenarios with complex wake  interaction patterns.\n\nArguments\n\nset::Settings: Simulation settings and configuration parameters\nwf::WindFarm: Wind farm object containing turbine positions, operational points, dependencies, and interpolation data\nwf.nT: Number of turbines\nwf.States_WF: Wind field states matrix\nwf.States_T: Turbine states matrix\nwf.States_OP: Operational point states matrix\nwf.dep: Turbine dependency relationships (from findTurbineGroups)\nwf.intOPs: Interpolation weights and indices (from interpolateOPs)\nwf.posBase: Base turbine positions [m]\nwf.posNac: Nacelle position offsets [m]\nwf.D: Rotor diameters [m]\nwf.StartI: Starting indices for each turbine's operational points\nfloris::Floris: FLORIS model parameters for wake calculations. See Floris\nwind::Wind: Wind field configuration including shear properties. See Wind\n\nReturns\n\nM::Matrix{Float64}: Results matrix of size (nT × 3) where each row contains:\nColumn 1: Total velocity reduction factor (product of all wake effects)\nColumn 2: Combined added turbulence intensity from all upstream turbines\nColumn 3: Effective wind speed at turbine [m/s]\nwf::WindFarm: Updated wind farm object with modified fields:\nwf.Weight: Normalized interpolation weights for each turbine\nwf.red_arr: Wake reduction matrix showing turbine-to-turbine wake effects\n\nAlgorithm\n\nThe function processes each turbine individually:\n\nSingle Turbine Case (No Dependencies)\n\nDirectly calls FLORIS with the turbine's wind field state\nNo wake interactions considered\nResults stored directly in output matrix\n\nMulti-Turbine Case (With Dependencies)\n\nTemporary Configuration Setup: Creates temporary arrays sized for the target turbine plus all influencing turbines\nInterpolation Application: Uses precomputed interpolation weights to determine states at influencing turbine positions\nCoordinate Transformation: Applies wind direction-based coordinate transformations to account for spatial offsets\nFLORIS Execution: Runs wake model with the complete multi-turbine configuration\nResult Processing: Combines wake effects and normalizes weights\n\nMathematical Description\n\nFor multi-turbine scenarios, the effective position of influencing turbines is computed as:\n\ntmp_Tpos[i] = base_position - R(φ) × [offset_x, offset_y, offset_z]\n\nwhere R(φ) is the rotation matrix for wind direction φ.\n\nThe total wake reduction is the product of individual wake effects:\n\nT_red = ∏ᵢ T_red_arr[i]\n\nCombined turbulence intensity follows root-sum-square combination:\n\nT_addedTI = √(∑ᵢ T_aTI_arr[i]²)\n\nWind Field Interpolation\n\nThe function supports optional wind field interpolation via coefficient matrices:\n\nVelocity interpolation: Uses wf.C_Vel if available\nDirection interpolation: Uses wf.C_Dir if available\n\nNotes\n\nThe function modifies the wind farm object in-place, updating weight and reduction arrays\nInterpolation weights are normalized to ensure proper weighting\nSpecial handling for variable rotor diameter configurations\nCoordinate transformations use the SOWFA to world conversion via angSOWFA2world\nThe algorithm efficiently handles both simple single-turbine and complex multi-turbine wake scenarios\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.interpolateOPs","page":"High-Level Functions","title":"FLORIDyn.interpolateOPs","text":"interpolateOPs(wf::WindFarm) -> Vector{Matrix{Float64}}\n\nCompute interpolation weights and indices for operational points affecting each turbine.\n\nThis function determines the optimal interpolation strategy for each turbine by identifying  the closest operational points from influencing upstream turbines. It computes weights and  indices that enable smooth interpolation of wind field states and turbine conditions at  arbitrary turbine positions.\n\nArguments\n\nwf::WindFarm: Wind farm object containing turbine dependencies, operational point states, and positional data\nwf.nT: Number of turbines\nwf.StartI: Starting indices for each turbine's operational points  \nwf.dep: Dependency relationships between turbines (from findTurbineGroups)\nwf.States_OP: Matrix of operational point states\nwf.posBase: Base positions of turbines [m]\nwf.nOP: Number of operational points per turbine\n\nReturns\n\nintOPs::Vector{Matrix{Float64}}: Interpolation data for each turbine where intOPs[i] is an  N×4 matrix for turbine i with N influencing turbines. Each row contains:\nColumn 1: First operational point index\nColumn 2: Weight for first operational point\nColumn 3: Second operational point index  \nColumn 4: Weight for second operational point\n\nAlgorithm\n\nFor each turbine and its influencing upstream turbines:\n\nDistance Calculation: Computes Euclidean distances from all operational points of  the influencing turbine to the target turbine position\nInterpolation Strategy Selection: Based on the closest operational point location:\nFirst OP closest: Uses first and second operational points\nLast OP closest: Uses second-to-last and last operational points\nInterior OP closest: Uses the two closest operational points for optimal interpolation\nWeight Computation: For interior cases, applies linear projection to determine interpolation weights:\nd = dot(ab, ac) / dot(ab, ab)\nweights = [1-d, d] # Clamped to [0,1]\n\nMathematical Description\n\nThe interpolation uses linear projection for weight computation:\n\nd = (b - a) · (c - a) / |b - a|²\n\nwhere:\n\na, b are positions of the two closest operational points\nc is the target turbine position\nd is the projection parameter (clamped to [0,1])\n\nNotes\n\nEdge cases (first/last operational points) use predefined weight combinations\nWeights always sum to 1.0 for proper interpolation\nThe function handles variable numbers of influencing turbines per target turbine\nInterpolation indices are global across the entire operational point matrix\nThis preprocessing enables efficient interpolation during simulation time steps\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.iterateOPs!","page":"High-Level Functions","title":"FLORIDyn.iterateOPs!","text":"iterateOPs!(::IterateOPs_basic, wf::WindFarm, sim::Sim, floris::Floris, floridyn::FloriDyn)\n\nAdvance operational points through the wind field using time-marching dynamics.\n\nThis function implements the basic time-stepping algorithm for operational points (OPs) in the  FLORIDyn simulation. It advances all operational points through space based on wind velocities  and wake deflection effects, maintaining proper ordering and updating turbine states accordingly.\n\nArguments\n\n::IterateOPs_basic: Dispatch type indicating the basic iteration algorithm\nwf::WindFarm: Wind farm object containing all turbine and operational point states. See WindFarm\nwf.States_OP: Matrix of operational point states [x, y, z, dw_pos, cw_x, cw_z, ...]\nwf.States_T: Matrix of turbine states \nwf.States_WF: Matrix of wind field states [velocity, direction, turbulence_intensity, ...]\nwf.StartI: Starting indices for each turbine's operational points\nwf.nT: Number of turbines\nwf.nOP: Number of operational points per turbine\nwf.D: Rotor diameters [m]\nsim::Sim: Simulation configuration object. See Sim\nsim.time_step: Time step size [s]\nsim.dyn.advection: Advection scaling factor\nfloris::Floris: FLORIS model parameters for wake deflection calculations. See Floris\nfloridyn::FloriDyn: FLORIDyn model parameters. See FloriDyn\n\nReturns\n\nnothing\n\nAlgorithm\n\nThe function performs the following steps for each time iteration:\n\n1. State Preservation\n\nSaves the current turbine operational point states before advancement to preserve boundary conditions.\n\n2. Spatial Advancement\n\nDownwind Movement\n\nAdvances operational points downstream based on local wind velocity:\n\nstep_dw = Δt × U × advection_factor\nOP_dw_position += step_dw\n\nCrosswind Deflection\n\nCalculates wake centerline deflection using FLORIS model and updates crosswind positions:\n\ndeflection = centerline(States_OP, States_T, States_WF, floris, D)\nOP_cw_position = deflection\n\n3. Coordinate System Transformation\n\nConverts local wind-aligned movements to world coordinates using wind direction:\n\nφ = angSOWFA2world(wind_direction)\nx_world += cos(φ) × step_dw - sin(φ) × step_cw_x\ny_world += sin(φ) × step_dw + cos(φ) × step_cw_x\nz_world += step_cw_z\n\n4. Temporal Shifting\n\nUses circular shifting to advance the time history:\n\nShifts all state matrices by one time step\nInitializes new operational points with saved turbine states\nMaintains temporal continuity of the simulation\n\n5. Spatial Ordering\n\nEnsures operational points remain ordered by downstream position for each turbine:\n\nSorts operational points by downstream position (States_OP[:, 4])\nMaintains consistency across all state matrices\n\nMathematical Description\n\nThe coordinate transformation from wind-aligned to world coordinates follows:\n\n[x']   [cos(φ)  -sin(φ)] [step_dw ]\n[y'] = [sin(φ)   cos(φ)] [step_cw_x]\n\nwhere φ is the wind direction angle in world coordinates.\n\nNotes\n\nThe function modifies the wind farm object in-place (indicated by the ! suffix)\nTemporal shifting maintains a moving window of operational point history\nSpatial ordering ensures downstream distance monotonicity for wake calculations\nThe algorithm handles both advection and deflection physics simultaneously\nCoordinate transformations account for SOWFA wind direction conventions via angSOWFA2world\n\n\n\n\n\niterateOPs!(::IterateOPs_basic, wf::WindFarm, sim::Sim, floris::Floris, \n            floridyn::FloriDyn, buffers::IterateOPsBuffers)\n\nAllocation-free version of iterateOPs! that uses pre-allocated buffers.\n\nThis is the high-performance, zero-allocation version of the operational point iteration algorithm. All temporary arrays are pre-allocated in the buffers parameter to eliminate runtime allocations.\n\nArguments\n\n::IterateOPs_basic: Dispatch type indicating the basic iteration algorithm\nwf::WindFarm: Wind farm object (same as standard version)\nsim::Sim: Simulation configuration object (same as standard version)  \nfloris::Floris: FLORIS model parameters (same as standard version)\nfloridyn::FloriDyn: FLORIDyn model parameters (same as standard version)\nbuffers::IterateOPsBuffers: Pre-allocated buffers for all temporary calculations. See IterateOPsBuffers.\n\nReturns\n\nnothing\n\nPerformance Notes\n\nZero allocations during execution (after initial buffer setup)\nSuitable for performance-critical applications and benchmarking\nBuffers can be reused across multiple calls for maximum efficiency\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.angSOWFA2world","page":"High-Level Functions","title":"FLORIDyn.angSOWFA2world","text":"angSOWFA2world(deg_SOWFA) -> Float64\n\nConvert wind direction angle from SOWFA convention to world coordinate system.\n\nThis function performs coordinate transformation between different wind direction conventions used in wind farm simulations. SOWFA (Simulator fOr Wind Farm Applications) uses a different angular reference system than the standard world coordinate system used in calculations.\n\nArguments\n\ndeg_SOWFA::Real: Wind direction angle in SOWFA convention [degrees]\n\nReturns\n\nrad_World: Wind direction angle in world coordinate system [radians]\n\nCoordinate System Conversion\n\nThe transformation follows the relationship:\n\nθ_world = 270° - θ_SOWFA\n\nSOWFA Convention\n\nWind direction angles are defined clockwise from a reference direction\n\nWorld Convention\n\nWind direction angles are defined counterclockwise for mathematical calculations\nStandard convention used in wake models and analytical computations\n\nMathematical Description\n\nThe conversion process:\n\nAngular transformation: deg_World = 270 - deg_SOWFA\nUnit conversion: rad_World = deg2rad(deg_World)\n\nThe 270° offset accounts for the difference between clockwise (SOWFA) and  counterclockwise (world) angular conventions.\n\nExamples\n\n# Convert 90° SOWFA direction to world coordinates\nworld_angle = angSOWFA2world(90.0)  # Returns 3.141592... (180° in radians)\n\n# Convert 0° SOWFA direction  \nworld_angle = angSOWFA2world(0.0)   # Returns 4.712388... (270° in radians)\n\nNotes\n\nThe function handles the sign convention difference between coordinate systems\nOutput is always in radians for use in trigonometric calculations\nThis transformation is essential for proper wake modeling in wind farm simulations\nThe 270° offset ensures proper alignment between SOWFA and mathematical conventions\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.runFLORIDyn","page":"High-Level Functions","title":"FLORIDyn.runFLORIDyn","text":"runFLORIDyn(plt, set::Settings, wf::WindFarm, wind::Wind, sim::Sim, con::Con, \n            vis::Vis, floridyn::FloriDyn, floris::Floris, pff=nothing) -> (WindFarm, DataFrame, Matrix)\n\nMain entry point for the FLORIDyn closed-loop simulation.\n\nArguments\n\nplt: Plot object for live visualization during simulation\nset::Settings: Simulation settings and configuration parameters.\nwf::WindFarm: See: WindFarm simulation state, including turbine and wind farm states.\nwind::Wind: See: Wind field settings.\nsim::Sim: Simulation state or configuration object. See: Sim\ncon::Con: Controller object or control parameters. See: Con\nvis::Vis: Visualization settings controlling online plotting and animation. See: Vis\nfloridyn::FloriDyn: Parameters specific to the FLORIDyn model. See: FloriDyn\nfloris::Floris: Parameters specific to the FLORIS model. See: Floris\npff: Optional remote plotting function for intermediate simulation results. When provided, this function  is called remotely (using @spawnat 2) to plot flow field visualization on a separate worker process. The function should accept parameters (wf, X, Y, Z, vis, t_rel; msr=1) where wf is the wind farm state, X, Y, Z are flow field coordinates and velocities, vis contains visualization settings, and t_rel  is the relative simulation time. Defaults to nothing for local plotting.\n\nReturns\n\nA tuple (wf, md, mi) containing:\n\nwf::WindFarm: Updated simulation state with final turbine positions, wind field states, and operational point data\nmd::DataFrame: Measurement data with columns:\n:Time: Simulation time steps\n:ForeignReduction: Wind speed reduction factors (%) due to wake effects from other turbines\n:AddedTurbulence: Additional turbulence intensity (%) induced by upstream turbines\n:EffWindSpeed: Effective wind speed (m/s) at each turbine after wake effects\n:FreeWindSpeed: Free-stream wind speed (m/s) without wake interference\n:PowerGen: Generated electrical power (MW) for each turbine\nmi::Matrix: Interaction matrix combining time data with turbine-to-turbine wake interaction coefficients                for each simulation step\n\nDescription\n\nRuns a closed-loop wind farm simulation using the FLORIDyn and FLORIS models,  applying control strategies and updating turbine states over time.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.run_floridyn","page":"High-Level Functions","title":"FLORIDyn.run_floridyn","text":"run_floridyn(plt, set, wf, wind, sim, con, vis, \n             floridyn, floris) -> (WindFarm, DataFrame, Matrix)\n\nUnified function that automatically handles both multi-threading and single-threading modes for running FLORIDyn simulations with appropriate plotting callbacks.\n\nArguments\n\nplt: PyPlot instance, usually provided by ControlPlots\nset: Settings object\nwf: WindFarm object\nwind: Wind field object\nsim: Simulation object\ncon: Controller object\nvis: Visualization settings\nfloridyn: FLORIDyn model object\nfloris: FLORIS model object\n\nReturns\n\nTuple (wf, md, mi): WindFarm, measurement data, and interaction matrix\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#Visualization","page":"High-Level Functions","title":"Visualization","text":"","category":"section"},{"location":"functions_II/#FLORIDyn.getMeasurements","page":"High-Level Functions","title":"FLORIDyn.getMeasurements","text":"getMeasurements(mx::Matrix, my::Matrix, nM::Int, zh::Real, wf::WindFarm, set::Settings, \n                floris::Floris, wind::Wind) -> Array{Float64,3}\n\nCalculate flow field measurements at specified grid points by treating them as virtual turbines.\n\nThis function computes flow field properties (velocity reduction, added turbulence, effective wind speed) at grid points by creating virtual turbines at each location and running the FLORIS wake model. Each grid point is treated as a turbine that depends on all real turbines in the wind farm, allowing wake effects to be captured in the flow field visualization.\n\nArguments\n\nmx::Matrix: X-coordinates of grid points (m)\nmy::Matrix: Y-coordinates of grid points (m)  \nnM::Int: Number of measurements to compute (typically 3)\nzh::Real: Hub height for measurements (m)\nwf::WindFarm: Wind farm object containing turbine data\nwf.nT: Number of real turbines\nwf.StartI: Starting indices for turbine data\nwf.posBase, wf.posNac: Turbine positions\nwf.States_*: Turbine state matrices\nset::Settings: Settings object containing simulation parameters\nfloris::Floris: FLORIS model parameters for wake calculations\nwind::Wind: Wind field configuration\n\nReturns\n\nmz::Array{Float64,3}: 3D array of measurements with dimensions (size(mx,1), size(mx,2), nM)\nmz[:,:,1]: Velocity reduction\nmz[:,:,2]: Added turbulence intensity\nmz[:,:,3]: Effective wind speed\n\nAlgorithm\n\nFor each grid point:\n\nCreates a temporary wind farm with all original turbines plus one virtual turbine at the grid point\nSets the virtual turbine to depend on all real turbines (to capture wake effects)\nRuns the FLORIS simulation to compute wake-affected flow properties\nExtracts the result for the virtual turbine position\n\nPerformance Notes\n\nSingle-threaded implementation (can be parallelized with @threads for large grids)\nEach grid point requires a full wind farm simulation, so computation time scales with grid size\nUses pre-allocated buffer to avoid repeated deepcopy operations for better performance\n\nExample\n\n# Create a 10x10 grid from 0 to 1000m\nx_range = 0:100:1000\ny_range = 0:100:1000\nmx = repeat(collect(x_range)', length(y_range), 1)\nmy = repeat(collect(y_range), 1, length(x_range))\n\n# Calculate 3 measurements at 90m hub height\nmz = getMeasurements(mx, my, 3, 90.0, wind_farm, settings, floris_model, wind_config)\n\n# Extract effective wind speed field\nwind_speed_field = mz[:, :, 3]\n\nSee Also\n\ncalcFlowField: Higher-level function that uses this to create complete flow field data\nsetUpTmpWFAndRun: Underlying simulation function used for each grid point\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.create_thread_buffers","page":"High-Level Functions","title":"FLORIDyn.create_thread_buffers","text":"create_thread_buffers(wf::WindFarm, nth::Int) -> ThreadBuffers\n\nCreate thread-local buffers for parallel flow field computation.\n\nThis function pre-allocates all necessary data structures for each thread to avoid race conditions and memory allocations during the parallel computation loop.\n\nArguments\n\nwf::WindFarm: Original wind farm object to use as template\nnth::Int: Number of threads to create buffers for\n\nReturns\n\nThreadBuffers: Struct containing all thread-local buffers\n\nPerformance Notes\n\nEach thread gets its own copy of the WindFarm structure\nPre-allocates all arrays to minimize allocations during computation\nSets up dependency structure for virtual turbines at grid points\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.getMeasurementsP","page":"High-Level Functions","title":"FLORIDyn.getMeasurementsP","text":"getMeasurementsP(mx::Matrix, my::Matrix, nM::Int, zh::Real, wf::WindFarm, set::Settings, \n                 floris::Floris, wind::Wind) -> Array{Float64,3}\n\nCalculate flow field measurements at specified grid points by treating them as virtual turbines.\n\nThis function computes flow field properties (velocity reduction, added turbulence, effective wind speed) at grid points by creating virtual turbines at each location and running the FLORIS wake model. Each grid point is treated as a turbine that depends on all real turbines in the wind farm, allowing wake effects to be captured in the flow field visualization.\n\nArguments\n\nmx::Matrix: X-coordinates of grid points (m)\nmy::Matrix: Y-coordinates of grid points (m)  \nnM::Int: Number of measurements to compute (typically 3)\nzh::Real: Hub height for measurements (m)\nwf::WindFarm: Wind farm object containing turbine data\nwf.nT: Number of real turbines\nwf.StartI: Starting indices for turbine data\nwf.posBase, wf.posNac: Turbine positions\nwf.States_*: Turbine state matrices\nset::Settings: Settings object containing simulation parameters\nfloris::Floris: FLORIS model parameters for wake calculations\nwind::Wind: Wind field configuration\n\nReturns\n\nmz::Array{Float64,3}: 3D array of measurements with dimensions (size(mx,1), size(mx,2), nM)\nmz[:,:,1]: Velocity reduction\nmz[:,:,2]: Added turbulence intensity\nmz[:,:,3]: Effective wind speed\n\nAlgorithm\n\nFor each grid point:\n\nCreates a temporary wind farm with all original turbines plus one virtual turbine at the grid point\nSets the virtual turbine to depend on all real turbines (to capture wake effects)\nRuns the FLORIS simulation to compute wake-affected flow properties\nExtracts the result for the virtual turbine position\n\nPerformance Notes\n\nMulti-threaded implementation using @threads for parallel processing of grid points\nEach grid point requires a full wind farm simulation, so computation time scales with grid size\nUses thread-local buffers created by create_thread_buffers to avoid race conditions\nScales well with the number of available CPU cores\n\nExample\n\n# Create a 10x10 grid from 0 to 1000m\nx_range = 0:100:1000\ny_range = 0:100:1000\nmx = repeat(collect(x_range)', length(y_range), 1)\nmy = repeat(collect(y_range), 1, length(x_range))\n\n# Calculate 3 measurements at 90m hub height\nmz = getMeasurements(mx, my, 3, 90.0, wind_farm, settings, floris_model, wind_config)\n\n# Extract effective wind speed field\nwind_speed_field = mz[:, :, 3]\n\nSee Also\n\ncalcFlowField: Higher-level function that uses this to create complete flow field data\nsetUpTmpWFAndRun: Underlying simulation function used for each grid point\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.calcFlowField","page":"High-Level Functions","title":"FLORIDyn.calcFlowField","text":"calcFlowField(set::Settings, wf::WindFarm, wind::Wind, floris::Floris; plt=nothing)\n\nGenerate full flow field plot data by calculating measurements across a grid.\n\nThis function creates a rectangular grid over the wind farm domain and calculates flow field properties at each grid point by treating them as virtual turbines. The computation can be performed in parallel if set.parallel is true, with automatic garbage collection management for thread safety.\n\nArguments\n\nset::Settings: Settings object containing simulation parameters\nset.parallel: If true, uses parallel computation with multiple threads\nwf::WindFarm: Wind farm object containing turbine data\nwind::Wind: Wind field configuration  \nfloris::Floris: FLORIS model parameters\n\nKeyword Arguments\n\nplt=nothing: Plot object for garbage collection control. If provided and set.parallel is true, automatically calls plt.GC.enable(false) before multithreading and plt.GC.enable(true)  after completion to prevent PyCall-related segmentation faults during parallel execution.\n\nReturns\n\nZ::Array{Float64,3}: 3D array of flow field measurements with dimensions (ny, nx, 3)\nZ[:,:,1]: Velocity reduction factor\nZ[:,:,2]: Added turbulence intensity  \nZ[:,:,3]: Effective wind speed (m/s)\nX::Matrix{Float64}: X-coordinate grid (m)\nY::Matrix{Float64}: Y-coordinate grid (m)\n\nPerformance Notes\n\nUses parallel computation when set.parallel=true for significant speedup on multi-core systems\nAutomatic garbage collection management prevents threading-related crashes\nGrid resolution is fixed at 20m with domain from [0,0] to [3000,3000] meters\nHub height is taken from the first turbine in the wind farm\n\nExample\n\n# Calculate flow field with parallel computation and GC control\nset.parallel = true\nZ, X, Y = calcFlowField(set, wf, wind, floris; plt)\n\n# Extract velocity reduction field\nvelocity_reduction = Z[:, :, 1]\n\n# Extract effective wind speed field  \nwind_speed = Z[:, :, 3]\n\nSee Also\n\ngetMeasurements: Single-threaded implementation\ngetMeasurementsP: Multi-threaded implementation\nplotFlowField: Visualization function for the generated data\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plotFlowField","page":"High-Level Functions","title":"FLORIDyn.plotFlowField","text":"plotFlowField(state::Union{Nothing, PlotState}, plt, wf, mx, my, mz, vis, t; msr=3)\n\nPlot a 2D contour of the flow field data with support for animation.\n\nArguments\n\nstate::Union{Nothing, PlotState}: Animation state object. Pass nothing for the first call,  then pass the returned state for subsequent calls to maintain the same figure and layout.\nplt: Plotting package (e.g., ControlPlots.plt)\nwf: Wind farm object containing turbine data\nmx::Matrix: X-coordinate grid\nmy::Matrix: Y-coordinate grid  \nmz::Array{Float64,3}: 3D array of measurements with dimensions (rows, cols, nM)\nvis::Vis: Visualization settings including save options and color scale parameters\nt: Time value for display in the plot title or annotations\nmsr::Int: Which measurement to plot (1, 2, or 3). Default is 3.\nmsr=1: Velocity reduction [%]\nmsr=2: Added turbulence [%]  \nmsr=3: Effective wind speed [m/s]\nvis.unit_test::Bool: Whether to automatically close plots for testing.\n\nReturns\n\nstate::PlotState: Updated or newly created plot state for use in subsequent calls\n\nDescription\n\nThis function supports creating animations by maintaining plot state across multiple calls:\n\nFirst Call (state = nothing)\n\nCreates new figure, axes, colorbar, and all plot elements\nInitializes and returns a PlotState object\n\nSubsequent Calls (state = PlotState)\n\nUpdates existing contour data, turbine positions, and operational points\nReuses the same figure and layout for smooth animation\n\nAnimation Example\n\nusing ControlPlots\n\n# Initialize state (first frame)\nstate = nothing\nvis = Vis(online=true, save=true)  # Enable saving to video folder\nfor t in time_steps\n    Z, X, Y = calcFlowField(settings, wind_farm, wind, floris)\n    state = plotFlowField(state, plt, wind_farm, X, Y, Z, vis, t; msr=1)\n    plt.pause(0.01)  # Small delay for animation\nend\n\nNotes\n\nThe function automatically handles coordinate system transformations for turbine orientations\nOperational points are displayed as white scatter points for reference\nColor scales are kept consistent across animation frames when using the same measurement type\nThe time parameter t can be used for title updates or time annotations\nWhen vis.save=true, plots are saved as PNG files to the video/ directory\nSaved filenames include measurement type and time information (e.g., velocity_reduction_t0120s.png)\nThe video/ directory is automatically created if it doesn't exist\nThis function requires a plotting package like ControlPlots.jl to be loaded and available as plt\n\n\n\n\n\nplotFlowField(plt, wf, mx, my, mz, vis, t=nothing; msr=3)\n\nCompatibility method for the original plotFlowField interface.\n\nThis method provides backward compatibility by calling the new state-based version  with state=nothing, effectively creating a single plot without animation support.\n\nArguments\n\nplt: Plotting package (e.g., ControlPlots.plt)\nwf: Wind farm object containing turbine data\nmx::Matrix: X-coordinate grid\nmy::Matrix: Y-coordinate grid  \nmz::Array{Float64,3}: 3D array of measurements with dimensions (rows, cols, nM)\nvis::Vis: Visualization settings including save options and color scale parameters\nt: Time value for display in the plot title or annotations\nmsr::Int: Which measurement to plot (1, 2, or 3). Default is 3.\nvis.unit_test::Bool: Whether to automatically close plots for testing.\n\nReturns\n\nnothing: For compatibility with the original interface\n\nNote\n\nThis method is provided for backward compatibility. For animation support,  use the new interface with explicit state management.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plot_flow_field","page":"High-Level Functions","title":"FLORIDyn.plot_flow_field","text":"plot_flow_field(wf, X, Y, Z, vis; msr=1, plt=nothing) -> Nothing\n\nHigh-level plotting function that automatically dispatches to either parallel or  sequential plotting based on the number of available threads and processes.\n\nArguments\n\nwf: WindFarm object\nX, Y, Z: Flow field coordinate arrays\nvis: Visualization settings\nmsr: Measurement type (1=velocity reduction, 2=turbulence, 3=wind speed)\nplt: Matplotlib PyPlot instance (only used in sequential mode)\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plotMeasurements","page":"High-Level Functions","title":"FLORIDyn.plotMeasurements","text":"plotMeasurements(plt, wf::WindFarm, md::DataFrame, vis::Vis; separated=false) -> Nothing\n\nPlot foreign reduction measurements from FLORIDyn simulation data.\n\nArguments\n\nplt: Plotting package (e.g., ControlPlots)\nwf::WindFarm: Wind farm object with field nT (number of turbines). See WindFarm\nmd::DataFrame: Measurements DataFrame containing time series data with columns:\nTime: Time series data [s]\nForeignReduction: Foreign reduction percentage data [%]\nvis::Vis: Visualization settings including unit_test parameter. See Vis\nseparated::Bool: Whether to use separated subplot layout (default: false)\n\nReturns\n\nnothing\n\nDescription\n\nThis function creates time series plots of foreign reduction measurements from FLORIDyn simulations. It handles:\n\nTime normalization by subtracting the start time\nForeign reduction plots in either separated (subplot) or combined layout\n\nPlotting Modes\n\nSeparated mode (separated=true): Creates individual subplots for each turbine\nCombined mode (separated=false): Plots all turbines on a single figure with different colors\n\nExample\n\nusing ControlPlots\n\n# Plot foreign reduction for all turbines in combined mode\nplotMeasurements(plt, wind_farm, measurements_df, vis)\n\n# Plot foreign reduction with separated subplots\nplotMeasurements(plt, wind_farm, measurements_df, vis; separated=true)\n\nSee Also\n\nplotFlowField: For flow field visualization\ngetMeasurements: For generating measurement data\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.plot_measurements","page":"High-Level Functions","title":"FLORIDyn.plot_measurements","text":"plot_measurements(wf, md, vis; separated=true, plt=nothing) -> Nothing\n\nHigh-level measurements plotting function that automatically dispatches to either  parallel or sequential plotting based on the number of available threads and processes.\n\nArguments\n\nwf: WindFarm object\nmd: Measurement data\nvis: Visualization settings\nseparated: Whether to use separated subplots\nplt: Matplotlib PyPlot instance (only used in sequential mode)\n\nReturns\n\nnothing\n\nSee Also\n\nplotMeasurements: The underlying plotting function used in sequential mode\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.close_all","page":"High-Level Functions","title":"FLORIDyn.close_all","text":"close_all(plt)\n\nClose all matplotlib figure windows.\n\nThis function automatically dispatches to either parallel or sequential plotting based on the number of available threads and processes.\n\nArguments\n\nplt: Matplotlib PyPlot instance (only used in sequential mode)\n\nDescription\n\nWhen running with multiple threads and processes, it uses remote plotting  capabilities to close all figures on the remote worker. Otherwise, it directly calls plt.close(\"all\") to close all figures in the current process.\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#Video-Creation","page":"High-Level Functions","title":"Video Creation","text":"","category":"section"},{"location":"functions_II/#FLORIDyn.cleanup_video_folder","page":"High-Level Functions","title":"FLORIDyn.cleanup_video_folder","text":"cleanup_video_folder() -> Nothing\n\nClean up existing PNG files in the video folder before creating new videos.\n\nDescription\n\nThis function removes all PNG files from the \"video\" directory to ensure a clean slate  before generating new video frames. It is typically called before running simulations  that create video output to prevent mixing old frames with new ones.\n\nBehavior\n\nChecks if the \"video\" directory exists\nScans the directory for files with \".png\" extension\nAttempts to delete each PNG file found\nReports the number of files deleted\nIssues warnings for any files that cannot be deleted\n\nReturns\n\nNothing\n\nExample\n\n# Clean up before creating new video frames\ncleanup_video_folder()\n\n# Run simulation that generates PNG frames\n# ...\n\n# Create video from frames\ncreateVideo()\n\nSee Also\n\ncreateVideo: Create MP4 video from PNG frames\ncreateAllVideos: Create videos for all measurement types\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.createVideo","page":"High-Level Functions","title":"FLORIDyn.createVideo","text":"createVideo(prefix::String; video_dir=\"video\", output_dir=\"video\", fps=2, delete_frames=false)\n\nConvert PNG files in a directory starting with a given prefix into an MP4 video.\n\nArguments\n\nprefix::String: The prefix string that PNG files must start with (e.g., \"velocityreduction\", \"windspeed\")\nvideo_dir::String: Directory containing the PNG files (default: \"video\")\noutput_dir::String: Directory where the output video will be saved (default: \"video\")\nfps::Int: Frames per second for the output video (default: 2)\ndelete_frames::Bool: Whether to delete the PNG files after creating the video (default: false)\n\nReturns\n\nString: Path to the created video file, or empty string if creation failed\n\nDescription\n\nThis function searches for PNG files in the specified directory that start with the given prefix, sorts them naturally (handling numeric sequences correctly), and combines them into an MP4 video using FFmpeg. The function requires FFmpeg to be installed on the system.\n\nExamples\n\n# Create video from velocity reduction frames\nvideo_path = createVideo(\"velocity_reduction\"; fps=4)\n\n# Create video from wind speed frames and delete source frames\nvideo_path = createVideo(\"wind_speed\"; fps=6, delete_frames=true)\n\n# Create video from custom directory\nvideo_path = createVideo(\"added_turbulence\"; video_dir=\"custom_plots\", output_dir=\"videos\")\n\nRequirements\n\nFFmpeg must be installed and available in the system PATH\nPNG files should follow a consistent naming pattern with the prefix\nRecommended naming: \"prefixt0000s.png\", \"prefixt0012s.png\", etc.\n\nNotes\n\nFiles are sorted naturally to handle numeric sequences correctly (e.g., t0001s, t0010s, t0100s)\nThe output video filename will be \"prefix_animation.mp4\"\nIf no matching files are found, the function returns an empty string\nFFmpeg parameters are optimized for good quality and reasonable file size\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.createAllVideos","page":"High-Level Functions","title":"FLORIDyn.createAllVideos","text":"createAllVideos(; video_dir=\"video\", output_dir=\"video\", fps=2, delete_frames=false)\n\nCreate videos for all common measurement types found in the video directory.\n\nArguments\n\nvideo_dir::String: Directory containing the PNG files (default: \"video\")\noutput_dir::String: Directory where output videos will be saved (default: \"video\")\nfps::Int: Frames per second for output videos (default: 2)\ndelete_frames::Bool: Whether to delete PNG files after creating videos (default: false)\n\nReturns\n\nVector{String}: Paths to created video files\n\nDescription\n\nThis convenience function automatically detects common measurement type prefixes in the video directory and creates videos for each type found. It looks for the following prefixes:\n\n\"velocity_reduction\"\n\"added_turbulence\" \n\"wind_speed\"\n\nExample\n\n# Create videos for all measurement types found\nvideo_paths = createAllVideos(fps=4, delete_frames=true)\nprintln(\"Created videos: \", video_paths)\n\n\n\n\n\n","category":"function"},{"location":"functions_II/#FLORIDyn.natural_sort_key","page":"High-Level Functions","title":"FLORIDyn.natural_sort_key","text":"natural_sort_key(filename::String)\n\nGenerate a sort key for natural sorting of filenames containing numbers.\n\nArguments\n\nfilename::String: The filename to generate a sort key for\n\nReturns\n\nVector: Sort key that handles numeric sequences naturally\n\nDescription\n\nThis function creates a sort key that handles numeric sequences in filenames correctly. For example, it will sort [\"file1.png\", \"file10.png\", \"file2.png\"] as  [\"file1.png\", \"file2.png\", \"file10.png\"] rather than alphabetically.\n\nExamples\n\nfiles = [\"velocity_reduction_t0001s.png\", \"velocity_reduction_t0010s.png\", \"velocity_reduction_t0002s.png\"]\nsorted_files = sort(files, by=natural_sort_key)\n# Result: [\"velocity_reduction_t0001s.png\", \"velocity_reduction_t0002s.png\", \"velocity_reduction_t0010s.png\"]\n\n\n\n\n\n","category":"function"},{"location":"#FLORIDyn","page":"Home","title":"FLORIDyn","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A dynamic wind farm simulation software, translated from FLORIDyn_Matlab, which was written by Marcus Becker.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code uses the Gaussian wake model from the quasi static wind farm simulation software FLORIS, developed by NREL.","category":"page"},{"location":"#Model-features","page":"Home","title":"Model features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulate wind farms dynamically at a low computational cost\nEstimate the power generated, added turbulence, and wake-induced losses.\nApply heterogeneous and time-varying wind speeds and directions\nTest different modeling approaches","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Flow Field)","category":"page"},{"location":"#Status:","page":"Home","title":"Status:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Five examples work, selectable via a menu:","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"examples/menu.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Python version of FLORIDyn is available at https://github.com/TUDelft-DataDrivenControl/OFF .","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia 1.11, if you haven't already. Julia 1.10 is still supported. On Linux, make sure that Python3 and Matplotlib are installed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sudo apt install python3-matplotlib","category":"page"},{"location":"","page":"Home","title":"Home","text":"Make sure that ControlPlots.jl works as explained here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Before installing this software it is suggested to create a new project, for example like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mkdir test\ncd test\njulia --project=.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Don't forget to type the dot at the end of the last command.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then add FLORIDyn from  Julia's package manager, by typing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add https://github.com/ufechner7/FLORIDyn.jl\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"at the Julia prompt. You can run the unit tests with the command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg\"test FLORIDyn\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can install the examples using the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FLORIDyn\ninstall_examples()","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you now quit Julia with <ctrl><d> and restart it with","category":"page"},{"location":"","page":"Home","title":"Home","text":"./bin/run_julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"then you can get the example menu by typing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"menu()","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can select any of the examples with the <UP> and <DOWN> keys, and then press <ENTER>.","category":"page"},{"location":"#Installation-using-GIT","page":"Home","title":"Installation using GIT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For developers, follow the developer notes.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Citation of the FLORIDyn model: FLORIDyn - A dynamic and flexible framework for real-time wind farm control, M. Becker, D. Allaerts, J.W. van Wingerden, 2022, http://doi.org/10.1088/1742-6596/2265/3/032103","category":"page"},{"location":"","page":"Home","title":"Home","text":"Used FLORIS model: Experimental and theoretical study of wind turbine wakes in yawed conditions, M. Bastankhah, F. Porté-Agel, 2020, http://doi.org/10.1017/jfm.2016.595","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional references for smaller subcomponents can be found in the code or in the related publications.","category":"page"},{"location":"faq/#Frequently-asked-questions-FAQ","page":"FAQ","title":"Frequently asked questions FAQ","text":"","category":"section"},{"location":"faq/#Why-should-I-use-Julia?","page":"FAQ","title":"Why should I use Julia?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Short answer: Speed (this code is 5-8 times faster than Matlab and 10-50 times faster than Python), which is very useful for example for solving optimization problems. Long answer: Read Why am I using Julia.","category":"page"},{"location":"faq/#How-can-I-start-Julia?","page":"FAQ","title":"How can I start Julia?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"There are different options. Suggested way:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Use a Bash terminal. On Linux this is the default, on Windows Bash is included in Git for Windows. You can launch Bash from VSCode from the menu with View->Terminal. There is a small drop-down menu at the top left of the terminal window where you might have to select Bash if it is not the default.\nBasic method to launch Julia: Type julia --project in the Bash terminal.\nImproved method: Type ./bin/run_julia. This script installs missing packages if needed and loads Revise and FLORIDyn.\nExpert method: Add the line alias jl='bin/run_julia' to your .bashrc file. Now you can start Julia by just typing jl.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Do NOT use the run button from VSCode to run Julia.","category":"page"},{"location":"faq/#Where-can-I-find-Julia-packages?","page":"FAQ","title":"Where can I find Julia packages?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you need extra packages to solve your tasks, look at: https://juliahub.com/ui/Packages . They have a good search function. Don't ask AI, they often suggest outdated packages. If there are multiple packages for your problem, you can also ask on Discourse for suggestions.","category":"page"},{"location":"faq/#What-is-a-Julia-environment?","page":"FAQ","title":"What is a Julia environment?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A Julia environment is a folder that contains a Project.toml and a Manifest.toml file. The Project.toml contains a list of the packages that are needed to run your code. It can also contain a list of the compatible package versions and more. It is important to use separate projects for each of your pieces of software that you develop, if you are not doing that (and use only the global environment), the things will break after some time. Further reading: Working with Julia projects.","category":"page"},{"location":"faq/#What-should-be-in-the-global-environment?","page":"FAQ","title":"What should be in the global environment?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Start Julia with julia. On my PC I have:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> using Pkg; Pkg.status()\nStatus `~/.julia/environments/v1.11/Project.toml`\n  [23c2ee80] ControlPlots v0.2.7\n  [5903a43b] Infiltrator v1.9.2\n  [16fef848] LiveServer v1.5.0\n  [295af30f] Revise v3.8.1\n  [0c614874] TerminalPager v0.6.4\n  [1e6cf692] TestEnv v1.102.1\n  [21f18d07] Timers v0.1.5","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can have a few more packages in there. But if you have 20 packages in your global environment you did something wrong.","category":"page"},{"location":"faq/#What-should-be-in-my-project-environment?","page":"FAQ","title":"What should be in my project environment?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you followed the developer guide and launched Julia with jl or julia --project, you should see something like:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"julia> using Pkg; Pkg.status()\nProject FLORIDyn v0.1.0\nStatus `~/repos/FLORIDyn.jl/Project.toml`\n  [336ed68f] CSV v0.10.15\n  [a93c6f00] DataFrames v1.7.0\n  [8bb1440f] DelimitedFiles v1.9.1\n  [ffbed154] DocStringExtensions v0.9.5\n  [a98d9a8b] Interpolations v0.16.1\n  [033835bb] JLD2 v0.5.15\n  [b964fa9f] LaTeXStrings v1.4.0\n  [d96e819e] Parameters v0.12.3\n⌅ [aea7be01] PrecompileTools v1.2.1\n  [90137ffa] StaticArrays v1.9.14\n  [10745b16] Statistics v1.11.1\n  [7c3b921d] StructMapping v0.2.3\n  [ddb6d928] YAML v0.4.14\n  [37e2e46d] LinearAlgebra v1.11.0\n  [56ddb016] Logging v1.11.0\n  [44cfe95a] Pkg v1.11.0\n  [9a3f8284] Random v1.11.0\nInfo Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated`","category":"page"},{"location":"faq/#Which-operating-systems-are-supported?","page":"FAQ","title":"Which operating systems are supported?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Linux, Windows and Mac are supported. In some of the examples you might have to replace / with \\\\ on Windows. If you still have a problem, create an issue on https://github.com/ufechner7/FLORIDyn.jl/issues.","category":"page"},{"location":"faq/#How-to-create-a-new-simulation?","page":"FAQ","title":"How to create a new simulation?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"in the folder data, copy 2021_9T_Data.yaml to a new file in the same folder. \ncopy the subfolder 2021_9T_Data with the .csv files to a new folder with the same name as your new .yaml file (but without the suffix .yaml)\ncopy the file examples/main.jl to a new file\nedit the line settings_file = \"data/2021_9T_Data.yaml\" to match the name of your new configuration file\nedit the new input files to match your test case\nrun your new example using \"include(\"examples/<new_main.jl>\")\"","category":"page"},{"location":"faq/#Can-I-use-other-plotting-packages?","page":"FAQ","title":"Can I use other plotting packages?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ControlPlots.jl is an easy-to-use, powerful plotting package, suitable for teaching. Furthermore it is based on Matplotlib, so you can leverage your knowledge of Matplotlib if you have used Python before. ControlPlots.jl exports the variable plt, and you can use any Matplotlib command by using the prefix plt.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can use other plotting packages, but then you have to adapt the plotting scripts that can be found here yourself. Pull requests to support other plotting packages like Plots.jl or Makie.jl are welcome.","category":"page"},{"location":"faq/#Can-I-use-this-package-with-Python?","page":"FAQ","title":"Can I use this package with Python?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can easily use Python packages in your own Julia project. I would suggest PyCall.jl to do that. You can use Conda.jl to install the required Python packages. They become part of your Julia environment and can be managed by the Julia package manager.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The other way, to use FLORIDyn.jl from Python is - in theory - possible using PythonCall.jl. This was not yet tested. ","category":"page"},{"location":"faq/#I-have-a-Problem.-Where-can-I-get-help?","page":"FAQ","title":"I have a Problem. Where can I get help?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Ask your question at Discourse. Most of the times you will get an answer in 15 min. Half of the people who answer are scientists.","category":"page"},{"location":"types/#Exported-Types","page":"Exported Types","title":"Exported Types","text":"","category":"section"},{"location":"types/#The-Wind-Farm-Simulation-struct","page":"Exported Types","title":"The Wind Farm Simulation struct","text":"","category":"section"},{"location":"types/#FLORIDyn.WindFarm","page":"Exported Types","title":"FLORIDyn.WindFarm","text":"WindFarm\n\nA mutable struct representing a wind farm. Fields can be specified using keyword arguments.\n\nFields\n\nnT::Int64: Number of turbines\nnOP::Int64: Number of operating points\nStates_WF::Matrix{Float64}: States of the wind farm\nStates_OP::Matrix{Float64}: States of the operating points\nStates_T::Matrix{Float64}: States of the turbines\nposBase::Matrix{Float64}: Base positions of the turbines\nposNac::Matrix{Float64}: Positions of the nacelles\nD::Vector{Float64}: Diameters of the turbines\nStartI::Matrix{Int}: Start indices for each turbine\nintOPs::Vector{Matrix{Float64}}: Interpolated operating points\nWeight::Vector{Vector{Float64}}: Weights for the operating points\ndep::Vector{Vector{Int}}: Dependencies between turbines\nred_arr::Matrix{Float64}: Reduced array for each turbine\nNames_T::Vector{String}: Names of the states of the turbines\nNames_WF::Vector{String}: Names of the states of the wind farm\nNames_OP::Vector{String}: Names of coordinates the operating points   \n\n\n\n\n\n","category":"type"},{"location":"types/#Abstract-types","page":"Exported Types","title":"Abstract types","text":"","category":"section"},{"location":"types/#FLORIDyn.VelModel","page":"Exported Types","title":"FLORIDyn.VelModel","text":"VelModel\n\nAbstract type representing a velocity model in the wind field module. Subtypes of VelModel implement specific velocity field representations or models.\n\nSee also: \n\nDefining the wind velocity model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.DirModel","page":"Exported Types","title":"FLORIDyn.DirModel","text":"DirModel\n\nAn abstract type representing a directional wind field model.  Subtypes of DirModel should implement specific models for wind directionality.\n\nSee: Defining the wind direction model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.ShearModel","page":"Exported Types","title":"FLORIDyn.ShearModel","text":"ShearModel\n\nAn abstract type representing a wind shear model for vertical wind profiles. Subtypes of ShearModel should implement specific models for wind shear calculations.\n\nSee: Defining the wind shear model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TurbulenceModel","page":"Exported Types","title":"FLORIDyn.TurbulenceModel","text":"TurbulenceModel\n\nAn abstract type representing a turbulence model for wind field calculations. Subtypes of TurbulenceModel should implement specific models for wind turbulence intensity.\n\nSee: Defining the wind turbulence model for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.VelCorrection","page":"Exported Types","title":"FLORIDyn.VelCorrection","text":"VelCorrection\n\nAn abstract type representing a velocity correction model for wind field adjustments. Subtypes of VelCorrection should implement specific correction methods for wind velocity.\n\nSee: Defining the velocity correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.DirCorrection","page":"Exported Types","title":"FLORIDyn.DirCorrection","text":"DirCorrection\n\nAn abstract type representing a direction correction model for wind field adjustments. Subtypes of DirCorrection should implement specific correction methods for wind direction.\n\nSee: Defining the direction correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TurbulenceCorrection","page":"Exported Types","title":"FLORIDyn.TurbulenceCorrection","text":"TurbulenceCorrection\n\nAn abstract type representing a turbulence correction model for wind field adjustments. Subtypes of TurbulenceCorrection should implement specific correction methods for turbulence intensity.\n\nSee: Defining the turbulence correction for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_model","page":"Exported Types","title":"FLORIDyn.IterateOPs_model","text":"IterateOPs_model\n\nAbstract supertype for all operational point iteration algorithms in FLORIDyn.\n\nThis abstract type defines the interface for different strategies used to advance  operational points through the wind field during time-stepping simulations. All  concrete iteration models must be subtypes of this abstract type.\n\nPurpose\n\nThe iteration models determine how operational points (OPs) move through space  and time, affecting:\n\nWake propagation dynamics\nSpatial discretization accuracy\nComputational efficiency\nPhysical representation of wind farm interactions\n\nImplementation\n\nConcrete subtypes implement specific iteration strategies through method dispatch  on functions like iterateOPs!. Each model represents a different  approach to handling the temporal and spatial evolution of operational points.\n\nAvailable Models\n\nIterateOPs_basic: Basic time-stepping with simple advection\nIterateOPs_average: Averaged dynamics for stability\nIterateOPs_buffer: Buffered approach for memory efficiency\nIterateOPs_maximum: Maximum value-based iteration\nIterateOPs_weighted: Weighted interpolation method\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.ControllerModel","page":"Exported Types","title":"FLORIDyn.ControllerModel","text":"ControllerModel\n\nAn abstract type representing a controller model for wind turbines. Subtypes of ControllerModel should implement specific control strategies for turbine operation.\n\nSee: Defining the controller for more details.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-velocity-model","page":"Exported Types","title":"Defining the wind velocity model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind velocity. They are all subtypes of VelModel","category":"page"},{"location":"types/#FLORIDyn.Velocity_Constant","page":"Exported Types","title":"FLORIDyn.Velocity_Constant","text":"Velocity_Constant <: VelModel\n\nA velocity model representing a constant wind velocity field. This struct is used as a type marker  to indicate that the wind velocity does not vary in space or time.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Constant_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_Constant_wErrorCov","text":"Velocity_Constant_wErrorCov <: VelModel\n\nA velocity model representing a constant wind field with associated  error covariance. This struct is a subtype of VelModel and is used  to model wind velocity with an constant value and an error covariance  for uncertainty quantification.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Velocity_EnKF_InterpTurbine","text":"Velocity_EnKF_InterpTurbine <: VelModel\n\nA velocity model type representing an interpolated turbine velocity field using the  Ensemble Kalman Filter (EnKF) approach.\n\nDescription\n\nThis struct is used within the wind field modeling framework to represent the velocity at a turbine location,  where the velocity is estimated or interpolated using EnKF-based techniques.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_I_and_I","page":"Exported Types","title":"FLORIDyn.Velocity_I_and_I","text":"Velocity_I_and_I <: VelModel\n\nA velocity model implementing an interpolation and integration approach for wind velocity estimation.\n\nDescription\n\nThis struct represents a velocity model that combines interpolation techniques with integration methods  to estimate wind velocity fields, typically used for advanced wind field reconstruction scenarios.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Interpolation","page":"Exported Types","title":"FLORIDyn.Velocity_Interpolation","text":"Velocity_Interpolation <: VelModel\n\nA velocity model that uses spatial interpolation techniques to estimate wind velocity fields.\n\nDescription\n\nThis struct represents a velocity model that employs interpolation methods to determine wind velocities  at arbitrary spatial locations based on available measurement data or model predictions.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_Interpolation_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_Interpolation_wErrorCov","text":"Velocity_Interpolation_wErrorCov <: VelModel\n\nA velocity model that uses spatial interpolation with associated error covariance information.\n\nDescription\n\nThis struct represents a velocity model that employs interpolation methods to determine wind velocities  and includes error covariance matrices for uncertainty quantification and probabilistic analysis.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Velocity_InterpTurbine","text":"Velocity_InterpTurbine <: VelModel\n\nA velocity model for interpolating wind velocities specifically at turbine locations.\n\nDescription\n\nThis struct represents a velocity model that focuses on estimating wind velocities at turbine hub heights  and rotor positions using interpolation techniques from surrounding measurement points or model data.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_InterpTurbine_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_InterpTurbine_wErrorCov","text":"Velocity_InterpTurbine_wErrorCov <: VelModel\n\nA velocity model for interpolating wind velocities at turbine locations with error covariance information.\n\nDescription\n\nThis struct represents a velocity model that estimates wind velocities at turbine positions using  interpolation techniques and includes associated error covariance matrices for uncertainty analysis  and robust wind farm control applications.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_RW_with_Mean","page":"Exported Types","title":"FLORIDyn.Velocity_RW_with_Mean","text":"Velocity_RW_with_Mean <: VelModel\n\nA velocity model implementing a random walk process with a mean trend component.\n\nDescription\n\nThis struct represents a velocity model that combines a random walk stochastic process with a  deterministic mean component, typically used for modeling wind velocity evolution over time  with both predictable trends and random fluctuations.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_ZOH_wErrorCov","page":"Exported Types","title":"FLORIDyn.Velocity_ZOH_wErrorCov","text":"Velocity_ZOH_wErrorCov <: VelModel\n\nA velocity model using Zero-Order Hold (ZOH) interpolation with error covariance information.\n\nDescription\n\nThis struct represents a velocity model that employs zero-order hold interpolation (piecewise constant)  for wind velocity estimation between measurement points, and includes error covariance matrices for  uncertainty quantification and statistical analysis.\n\nSee also:\n\nVelModel: Abstract supertype for velocity models.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-direction-model","page":"Exported Types","title":"Defining the wind direction model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind direction. They are all subtypes of DirModel","category":"page"},{"location":"types/#FLORIDyn.Direction_Constant","page":"Exported Types","title":"FLORIDyn.Direction_Constant","text":"Direction_Constant <: DirModel\n\nA marker struct used to represent a constant wind direction.\n\nExample:\n\ndir_mode = Direction_constant()\nphi = getWindDirT(dir_mode, 270, [1,2,3], nothing)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Constant_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_Constant_wErrorCov","text":"Direction_Constant_wErrorCov <: DirModel\n\nA marker struct used to indicate a wind direction that is constant with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Direction_EnKF_InterpTurbine","text":"Direction_EnKF_InterpTurbine <: DirModel\n\nA marker struct used to indicate the use of direction-aware Ensemble Kalman Filter (EnKF) interpolation for turbine modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Interpolation","page":"Exported Types","title":"FLORIDyn.Direction_Interpolation","text":"Direction_Interpolation <: DirModel\n\nA marker struct used to represent direction interpolation functionality within the FLORIDyn framework.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Interpolation_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_Interpolation_wErrorCov","text":"Direction_Interpolation_wErrorCov <: DirModel\n\nA marker struct representing a direction interpolation method with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Direction_InterpTurbine","text":"Direction_InterpTurbine <: DirModel\n\nA marker struct used to indicate direction interpolation for turbines.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_InterpTurbine_wErrorCov","page":"Exported Types","title":"FLORIDyn.Direction_InterpTurbine_wErrorCov","text":"Direction_InterpTurbine_wErrorCov <: DirModel\n\nA marker struct used to indicate the use of direction interpolation for turbines with associated error covariance.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_RW_with_Mean","page":"Exported Types","title":"FLORIDyn.Direction_RW_with_Mean","text":"Direction_RW_with_Mean <: DirModel\n\nA marker struct used to indicate the use of a random walk direction model with a mean component.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-shear-model","page":"Exported Types","title":"Defining the wind shear model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind shear.","category":"page"},{"location":"types/#FLORIDyn.Shear_Interpolation","page":"Exported Types","title":"FLORIDyn.Shear_Interpolation","text":"Shear_Interpolation <: ShearModel\n\nA marker struct used to represent the linear interpolation for wind shear profiles.\n\nSee also\n\nShear_PowerLaw\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Shear_PowerLaw","page":"Exported Types","title":"FLORIDyn.Shear_PowerLaw","text":"Shear_PowerLaw <: ShearModel\n\nA marker struct representing the logarithmic law for modeling wind shear profiles.\n\nSee also\n\nShear_Interpolation\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-wind-turbulence-model","page":"Exported Types","title":"Defining the wind turbulence model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that calculate the wind turbulence.","category":"page"},{"location":"types/#FLORIDyn.TI_Constant","page":"Exported Types","title":"FLORIDyn.TI_Constant","text":"TI_Constant <: TurbulenceModel\n\nA marker struct representing a constant turbulence intensity. \n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_EnKF_InterpTurbine","page":"Exported Types","title":"FLORIDyn.TI_EnKF_InterpTurbine","text":"TI_EnKF_InterpTurbine <: TurbulenceModel\n\nA marker struct representing the Turbulence Intensity (TI) Ensemble Kalman Filter (EnKF) interpolation model.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_Interpolation","page":"Exported Types","title":"FLORIDyn.TI_Interpolation","text":"TI_Interpolation <: TurbulenceModel\n\nA marker struct representing the interpolation method for modeling the turbulence.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_InterpTurbine","page":"Exported Types","title":"FLORIDyn.TI_InterpTurbine","text":"TI_InterpTurbine <: TurbulenceModel\n\nA marker struct representing an interpolated turbine model for turbulence intensity calculations.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-velocity-correction","page":"Exported Types","title":"Defining the velocity correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct wind velocity. They are all subtypes of VelCorrection","category":"page"},{"location":"types/#FLORIDyn.Velocity_Influence","page":"Exported Types","title":"FLORIDyn.Velocity_Influence","text":"Velocity_Influence <: VelCorrection\n\nA marker struct used to represent velocity correction based on influence modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_None","page":"Exported Types","title":"FLORIDyn.Velocity_None","text":"Velocity_None <: VelCorrection\n\nA marker struct used to indicate that no velocity corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Velocity_wGaspariAndCohn","page":"Exported Types","title":"FLORIDyn.Velocity_wGaspariAndCohn","text":"Velocity_wGaspariAndCohn <: VelCorrection\n\nA marker struct used to represent velocity correction using the Gaspari and Cohn localization method. This correction method is commonly used in ensemble data assimilation for spatial localization.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-direction-correction","page":"Exported Types","title":"Defining the direction correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct wind direction. They are all subtypes of DirCorrection","category":"page"},{"location":"types/#FLORIDyn.Direction_All","page":"Exported Types","title":"FLORIDyn.Direction_All","text":"Direction_All <: DirCorrection\n\nA marker struct used to indicate that all direction corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_Influence","page":"Exported Types","title":"FLORIDyn.Direction_Influence","text":"Direction_Influence <: DirCorrection\n\nA marker struct used to represent direction correction based on influence modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Direction_None","page":"Exported Types","title":"FLORIDyn.Direction_None","text":"Direction_None <: DirCorrection\n\nA marker struct used to indicate that no direction corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-turbulence-correction","page":"Exported Types","title":"Defining the turbulence correction","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that correct turbulence intensity. They are all subtypes of TurbulenceCorrection","category":"page"},{"location":"types/#FLORIDyn.TI_Influence","page":"Exported Types","title":"FLORIDyn.TI_Influence","text":"TI_Influence <: TurbulenceCorrection\n\nA marker struct used to represent turbulence intensity correction based on influence modeling.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_None","page":"Exported Types","title":"FLORIDyn.TI_None","text":"TI_None <: TurbulenceCorrection\n\nA marker struct used to indicate that no turbulence intensity corrections should be applied.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.TI_wGaspariAndCohn","page":"Exported Types","title":"FLORIDyn.TI_wGaspariAndCohn","text":"TI_wGaspariAndCohn <: TurbulenceCorrection\n\nA marker struct used to represent turbulence intensity correction using the Gaspari and Cohn localization method. This correction method is commonly used in ensemble data assimilation for spatial localization.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-controller","page":"Exported Types","title":"Defining the controller","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that control turbine behavior. They are all subtypes of ControllerModel","category":"page"},{"location":"types/#FLORIDyn.Yaw_Constant","page":"Exported Types","title":"FLORIDyn.Yaw_Constant","text":"Yaw_Constant <: ControllerModel\n\nA marker struct used to represent a constant yaw control strategy. In this mode, turbines maintain a fixed yaw angle throughout the simulation.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Yaw_InterpTurbine","page":"Exported Types","title":"FLORIDyn.Yaw_InterpTurbine","text":"Yaw_InterpTurbine <: ControllerModel\n\nA marker struct used to indicate yaw control with turbine interpolation. This mode allows for interpolated yaw angles across different turbine positions.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.Yaw_SOWFA","page":"Exported Types","title":"FLORIDyn.Yaw_SOWFA","text":"Yaw_SOWFA <: ControllerModel\n\nA marker struct used to represent yaw control compatible with SOWFA (Simulator fOr Wind Farm Applications). This mode is specifically designed for integration with SOWFA simulation data.\n\n\n\n\n\n","category":"type"},{"location":"types/#Defining-the-OP-iteration-model","page":"Exported Types","title":"Defining the OP iteration model","text":"","category":"section"},{"location":"types/","page":"Exported Types","title":"Exported Types","text":"An instance of these structs needs to be passed to the functions that iterate operational points (OPs) through the wind field. They are all subtypes of IterateOPs_model","category":"page"},{"location":"types/#FLORIDyn.IterateOPs_average","page":"Exported Types","title":"FLORIDyn.IterateOPs_average","text":"IterateOPs_average <: IterateOPs_model\n\nOperational point iteration model using averaged dynamics.\n\nThis iteration strategy employs averaging techniques to advance operational  points through the wind field, providing enhanced numerical stability and  smoother wake evolution compared to basic methods.\n\nAlgorithm Characteristics\n\nStability: Improved numerical stability through temporal averaging\nSmoothness: Reduces oscillations in wake dynamics\nComputational Cost: Moderate overhead due to averaging operations\nAccuracy: Good balance between stability and physical representation\n\nUse Cases\n\nRecommended for:\n\nSimulations requiring smooth wake evolution\nCases with high turbulence or complex wind conditions\nLong-duration simulations where stability is critical\nResearch applications focusing on ensemble statistics\n\nMathematical Approach\n\nThe averaging process involves temporal or spatial averaging of  relevant quantities (velocities, deflections, turbulence) before applying  the advancement step, resulting in more stable operational point trajectories.\n\nNotes\n\nThis model may require additional computational resources compared to basic  methods but provides better stability characteristics for challenging  simulation scenarios.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_basic","page":"Exported Types","title":"FLORIDyn.IterateOPs_basic","text":"IterateOPs_basic <: IterateOPs_model\n\nBasic operational point iteration model with simple time-stepping.\n\nThis is the fundamental iteration strategy that advances operational points  using direct time-stepping based on local wind velocities and wake deflection  effects. It provides the core functionality for FLORIDyn simulations.\n\nAlgorithm Characteristics\n\nSimplicity: Straightforward implementation with minimal overhead\nPerformance: Fastest execution among available iteration models\nAccuracy: Direct physical representation of wake advection\nMemory: Minimal memory requirements\n\nImplementation\n\nThe basic algorithm performs:\n\nDownwind advection based on local wind speed\nCrosswind deflection using wake centerline calculations\nCoordinate transformation to world coordinates\nTemporal advancement through circular shifting\nSpatial reordering to maintain downstream position order\n\nUse Cases\n\nRecommended for:\n\nStandard wind farm simulations\nPerformance-critical applications\nValidation studies against reference data\nInitial model development and testing\n\nMathematical Foundation\n\nUses explicit time-stepping with:\n\nΔx = U × Δt × advection_factor\n\nwhere operational points move downstream based on local wind conditions.\n\nNotes\n\nThis model serves as the reference implementation and baseline for  comparison with other iteration strategies. See iterateOPs! for detailed implementation.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_buffer","page":"Exported Types","title":"FLORIDyn.IterateOPs_buffer","text":"IterateOPs_buffer <: IterateOPs_model\n\nOperational point iteration model with buffered memory management.\n\nThis iteration strategy implements buffering techniques to optimize memory  usage and computational efficiency during operational point advancement,  particularly beneficial for large-scale wind farm simulations.\n\nAlgorithm Characteristics\n\nMemory Efficiency: Optimized memory access patterns\nScalability: Better performance for large numbers of operational points\nCaching: Intelligent buffering of frequently accessed data\nComputational Cost: Reduced overhead for memory-intensive operations\n\nUse Cases\n\nRecommended for:\n\nLarge wind farms with many turbines\nMemory-constrained computing environments\nHigh-resolution simulations with dense operational point grids\nProduction simulations requiring optimal resource utilization\n\nImplementation Strategy\n\nThe buffering approach manages operational point data through:\n\nEfficient memory allocation patterns\nReduced data copying operations\nOptimized access to state matrices\nStrategic caching of intermediate results\n\nPerformance Benefits\n\nImproved cache locality for better CPU performance\nReduced memory bandwidth requirements\nBetter scaling with problem size\nLower memory fragmentation\n\nNotes\n\nThis model is particularly effective when computational resources are  limited or when dealing with very large simulation domains.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_maximum","page":"Exported Types","title":"FLORIDyn.IterateOPs_maximum","text":"IterateOPs_maximum <: IterateOPs_model\n\nOperational point iteration model using maximum value selection.\n\nThis iteration strategy employs maximum value-based decision making during  operational point advancement, potentially useful for conservative estimates  or worst-case scenario analysis in wind farm simulations.\n\nAlgorithm Characteristics\n\nConservative Approach: Tends toward maximum/conservative values\nRobustness: Provides bounds on simulation behavior\nSpecial Cases: Handles extreme conditions effectively\nAnalysis: Useful for sensitivity and worst-case studies\n\nUse Cases\n\nRecommended for:\n\nConservative design analysis\nWorst-case scenario evaluation\nRisk assessment studies\nValidation of simulation bounds\nResearch on extreme wind conditions\n\nMathematical Approach\n\nThe maximum selection process applies maximum operators to relevant  quantities during the iteration step, which may include:\n\nMaximum wind speeds in the vicinity\nMaximum deflection values\nMaximum turbulence intensities\nConservative time step selection\n\nApplications\n\nParticularly useful in:\n\nSafety factor determination\nConservative power estimation\nExtreme load analysis\nUncertainty quantification studies\n\nNotes\n\nThis model may produce more conservative results compared to other  iteration strategies and should be used when understanding bounds  on simulation behavior is important.\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPs_weighted","page":"Exported Types","title":"FLORIDyn.IterateOPs_weighted","text":"IterateOPs_weighted <: IterateOPs_model\n\nOperational point iteration model using weighted interpolation.\n\nThis iteration strategy employs sophisticated weighted interpolation  techniques to advance operational points, providing enhanced accuracy  through spatial and temporal weighting of relevant physical quantities.\n\nAlgorithm Characteristics\n\nHigh Accuracy: Superior interpolation accuracy\nSmoothness: Smooth transitions between operational points\nComputational Cost: Higher due to interpolation calculations\nFlexibility: Adaptable weighting schemes\n\nUse Cases\n\nRecommended for:\n\nHigh-accuracy research simulations\nDetailed wake interaction studies\nValidation against experimental data\nApplications requiring smooth field representations\nAdvanced control algorithm development\n\nInterpolation Strategy\n\nThe weighted approach typically involves:\n\nDistance-based spatial weighting\nTemporal interpolation of quantities\nMulti-point interpolation schemes\nAdaptive weight calculation based on local conditions\n\nMathematical Foundation\n\nUses interpolation weights w_i such that:\n\nquantity_interpolated = Σ w_i × quantity_i\n\nwhere weights satisfy Σ w_i = 1 and are computed based on distance,  time, or other relevant metrics.\n\nAccuracy Benefits\n\nReduced numerical diffusion\nBetter preservation of wake structures\nImproved representation of turbulence effects\nEnhanced spatial resolution\n\nNotes\n\nThis model provides the highest accuracy among available iteration  strategies but requires additional computational resources. Best suited  for applications where accuracy is prioritized over computational speed.\n\n\n\n\n\n","category":"type"},{"location":"types/#Types-for-storing-wind-field-params","page":"Exported Types","title":"Types for storing wind field params","text":"","category":"section"},{"location":"types/#FLORIDyn.WindDirType","page":"Exported Types","title":"FLORIDyn.WindDirType","text":" WindDirType\n\nFields\n\nData::Float64: wind direction value\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindDirMatrix","page":"Exported Types","title":"FLORIDyn.WindDirMatrix","text":"struct WindDirMatrix\n\nFields\n\nData::Matrix{Float64}:    Columns [time, phi] or [time, phi_T0, phi_T1, ... phi_Tn]\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindDirTriple","page":"Exported Types","title":"FLORIDyn.WindDirTriple","text":"WindDirTriple\n\nA structure representing a wind direction triple. \n\nFields\n\nInit::Vector{Float64}:    Mean direction (vector or scalar)\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\nMeanPull::Float64:        Scalar mean reversion factor\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindVelType","page":"Exported Types","title":"FLORIDyn.WindVelType","text":" WindVelType\n\nFields\n\nData::Float64: wind speed\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindVelMatrix","page":"Exported Types","title":"FLORIDyn.WindVelMatrix","text":"struct WindVelMatrix\n\nFields\n\nData::Matrix{Float64}:    Nx2 matrix: column 1 = time, column 2 = wind speed\nCholSig::Matrix{Float64}: Cholesky factor of covariance matrix (nT x nT)\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindShear","page":"Exported Types","title":"FLORIDyn.WindShear","text":"WindShear\n\nA struct representing the wind shear profile. This type is used to model the variation of wind speed with height,  which is important in atmospheric and wind energy simulations.\n\nFields\n\nz0::Float64: Reference height (not used in the getWindShearT)\nalpha::Float64: WindShear coefficient\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.WindPerturbation","page":"Exported Types","title":"FLORIDyn.WindPerturbation","text":"WindPerturbation\n\nA mutable struct for configuring stochastic wind perturbations in wind farm simulations.\n\nThis struct controls whether perturbations are applied to different wind parameters and defines the magnitude of these perturbations using standard deviations. Wind perturbations are used to  model uncertainty in wind measurements or to perform sensitivity analysis.\n\nFields\n\nvel::Bool: Enable/disable velocity perturbations. When true, random perturbations are applied to wind velocity.\nvel_sigma::Float64: Standard deviation for velocity perturbations [m/s]. Determines the magnitude of random variations added to the wind velocity.\ndir::Bool: Enable/disable direction perturbations. When true, random perturbations are applied to wind direction.\ndir_sigma::Float64: Standard deviation for direction perturbations [degrees]. Determines the magnitude of random variations added to the wind direction.\nti::Bool: Enable/disable turbulence intensity perturbations. When true, random perturbations are applied to turbulence intensity.\nti_sigma::Float64: Standard deviation for turbulence intensity perturbations [-]. Determines the magnitude of random variations added to the turbulence intensity.\n\nNotes\n\nPerturbations are typically applied as additive Gaussian noise with zero mean and the specified standard deviation\nThe perturbation flags (vel, dir, ti) act as switches to enable or disable specific types of perturbations\nSetting a flag to false will disable perturbations for that parameter regardless of the sigma value\nStandard deviations should be positive values.\n\n\n\n\n\n","category":"type"},{"location":"types/#Other-types","page":"Exported Types","title":"Other types","text":"","category":"section"},{"location":"types/#FLORIDyn.States","page":"Exported Types","title":"FLORIDyn.States","text":"States\n\nA mutable struct representing the state variables used in the Gaussian wake model.  This struct is intended to store and update the dynamic properties of the wake during simulation.\n\nFields\n\nT_names::Vector{String}: Names of turbine state variables (e.g., \"a\", \"yaw\", \"TI\" for axial induction factor, yaw angle, and turbulence intensity)\nTurbine::Int: Number of turbine state variables (length of T_names)\nOP_names::Vector{String}: Names of observation point state variables (e.g., \"x0\", \"y0\", \"z0\", \"x1\", \"y1\", \"z1\" for 3D coordinates)\nOP::Int: Number of observation point state variables (length of OP_names)\nWF_names::Vector{String}: Names of wind field state variables (e.g., \"windvel\", \"winddir\", \"TI0\" for velocity, direction, and ambient turbulence)\nWF::Int: Number of wind field state variables (length of WF_names)\n\nDescription\n\nThis struct organizes the naming and counting of different types of state variables used in wind farm simulations:\n\nTurbine states represent individual turbine properties and control settings\nObservation point states track spatial coordinates for wake calculations\nWind field states capture environmental conditions affecting the entire wind farm\n\n\n\n\n\n","category":"type"},{"location":"types/#FLORIDyn.IterateOPsBuffers","page":"Exported Types","title":"FLORIDyn.IterateOPsBuffers","text":"IterateOPsBuffers\n\nA struct containing pre-allocated buffers for allocation-free execution of iterateOPs!.\n\nThis struct eliminates all allocations during the operational point iteration by  pre-allocating all necessary temporary arrays. It should be created once and reused across multiple calls to iterateOPs! for maximum performance.\n\nFields\n\ntmpOPStates::Matrix{Float64}: Buffer for saving turbine operational point states  \ntmpTStates::Matrix{Float64}: Buffer for saving turbine states\ntmpWFStates::Matrix{Float64}: Buffer for saving wind farm states\nstep_dw::Vector{Float64}: Buffer for downwind step calculations\ndeflection::Matrix{Float64}: Buffer for centerline deflection calculations  \nstep_cw::Matrix{Float64}: Buffer for crosswind step calculations\ntemp_states_op::Matrix{Float64}: Temporary buffer for States_OP circular shifting\ntemp_states_t::Matrix{Float64}: Temporary buffer for States_T circular shifting  \ntemp_states_wf::Matrix{Float64}: Temporary buffer for States_WF circular shifting\nsort_buffer::Vector{Int}: Buffer for sorting operational points\n\nConstructor\n\nIterateOPsBuffers(wf::WindFarm)\n\nCreates buffers appropriately sized for the given WindFarm object.\n\n\n\n\n\n","category":"type"}]
}
