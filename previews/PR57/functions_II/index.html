<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>High-Level Functions · FLORIDyn.jl</title><meta name="title" content="High-Level Functions · FLORIDyn.jl"/><meta property="og:title" content="High-Level Functions · FLORIDyn.jl"/><meta property="twitter:title" content="High-Level Functions · FLORIDyn.jl"/><meta name="description" content="Documentation for FLORIDyn.jl."/><meta property="og:description" content="Documentation for FLORIDyn.jl."/><meta property="twitter:description" content="Documentation for FLORIDyn.jl."/><meta property="og:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><meta property="twitter:url" content="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><link rel="canonical" href="https://ufechner7.github.io/FLORIDyn.jl/dev/functions_II/"/><meta property="og:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:image" content="https://ufechner7.github.io/FLORIDyn.jl/dev/assets/preview.png"/><meta property="twitter:card" content="summary_large_image"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="FLORIDyn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLORIDyn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">Exported Types</a></li><li><a class="tocitem" href="../functions/">Low-Level Functions</a></li><li class="is-active"><a class="tocitem" href>High-Level Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#FLORIS"><span>FLORIS</span></a></li><li class="toplevel"><a class="tocitem" href="#FLORIDyn"><span>FLORIDyn</span></a></li><li class="toplevel"><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li class="toplevel"><a class="tocitem" href="#Video-Creation"><span>Video Creation</span></a></li></ul></li><li><a class="tocitem" href="../settings/">Settings</a></li><li><a class="tocitem" href="../video_creation/">Video Creation</a></li><li><a class="tocitem" href="../user_guide/">User Guide</a></li><li><a class="tocitem" href="../developer/">Developer notes</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>High-Level Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>High-Level Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ufechner7/FLORIDyn.jl/blob/main/docs/src/functions_II.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="High-Level-Functions"><a class="docs-heading-anchor" href="#High-Level-Functions">High-Level Functions</a><a id="High-Level-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Functions" title="Permalink"></a></h1><h1 id="FLORIS"><a class="docs-heading-anchor" href="#FLORIS">FLORIS</a><a id="FLORIS-1"></a><a class="docs-heading-anchor-permalink" href="#FLORIS" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.calcCt" href="#FLORIDyn.calcCt"><code>FLORIDyn.calcCt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcCt(a, _) -&gt; Number or Vector</code></pre><p>Calculate the thrust coefficient <code>ct</code> for a wind turbine based on the axial induction factor <code>a</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: Axial induction factor, typically between 0 and 0.5 (can be a scalar or vector)</li><li>_: unused parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>ct::Number</code>: The calculated thrust coefficient.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floris/gaussian.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.centerline" href="#FLORIDyn.centerline"><code>FLORIDyn.centerline</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centerline(states_op, states_t, states_wf, floris, d_rotor) -&gt; Matrix{Float64}</code></pre><p>Compute the centerline wake properties for a wind farm simulation.</p><p><strong>Arguments</strong></p><ul><li><code>states_op</code>: Operational states of the turbines (e.g., yaw, pitch, etc.).</li><li><code>states_t</code>: Turbine-specific states (e.g., rotor speed, torque, etc.).</li><li><code>states_wf</code>: Wind farm-level states (e.g., wind direction, wind speed, etc.).</li><li><code>floris</code>: Parameters for the FLORIS wake model.</li><li><code>d_rotor</code>: Rotor diameter or characteristic length scale.</li></ul><p><strong>Returns</strong></p><ul><li>The computed centerline wake properties <code>delta</code>, which includes the deflection in the y and z directions.</li></ul><p><strong>Notes</strong></p><p>This function is part of the Gaussian wake model implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floris/gaussian.jl#L66-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.discretizeRotor" href="#FLORIDyn.discretizeRotor"><code>FLORIDyn.discretizeRotor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretizeRotor(n_rp::Int) -&gt; Tuple{Matrix{Float64}, Vector{Float64}}</code></pre><p>Discretizes the rotor into a <code>n_rp</code> segments. The algorithm returns the normalized center location ∈ [-0.5, 0.5] and the relative area the segment represents.</p><p><strong>Arguments</strong></p><ul><li><code>n_rp::Int</code>: The number of radial points to discretize the rotor into.</li></ul><p><strong>Returns</strong></p><ul><li>The tuple <code>(m_rp, w)</code> where:<ul><li><code>m_rp</code>: A matrix of size <code>(nC, 3)</code> where <code>nC</code> is the number of segments. The first column is all zeros,   the second and third columns contain the normalized radial positions.</li><li><code>w</code>: A vector of weights corresponding to each segment, summing to approximately 1.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>The algorithm returns the normalized center location in the range <code>[-0.5, 0.5]</code> and the relative area that each segment represents.</li><li>The isocell algorithm is used, which may not yield exactly <code>n_rp</code> cells but aims to achieve a similar number.</li><li>For details, see the publication by Masset et al.: <a href="https://orbi.uliege.be/bitstream/2268/91953/1/masset_isocell_orbi.pdf">Masset et al. (2009)</a></li><li>The choice of <code>N1 = 3</code> is made here, but values of <code>4</code> or <code>5</code> are also viable options. The choice of <code>3</code> is close to optimal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floris/discretization.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.init_states" href="#FLORIDyn.init_states"><code>FLORIDyn.init_states</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_states(set::Settings, wf::WindFarm, wind::Wind, init_turb, 
            floris::Floris, sim::Sim) -&gt; Tuple{Matrix, Matrix, Matrix}</code></pre><p>Initialize the state arrays for wind farm simulation using the Gaussian wake model.</p><p>This function sets up the initial conditions for turbines, observation points, and wind field  states based on the provided configuration parameters. It computes initial positions, wind  conditions, and wake properties for each turbine in the wind farm.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options for velocity, direction, and turbulence models</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, dimensions, and state arrays (see <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>)</li><li><code>wind::Wind</code>: Wind conditions including velocity, direction, and turbulence intensity data (see <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a>)</li><li><code>init_turb</code>: Initial turbine state parameters (axial induction factor, yaw angle, turbulence intensity)</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>sim::Sim</code>: Simulation parameters including time step and start time (see <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a>)</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(states_op, states_t, states_wf)</code> containing:</p><ul><li><code>states_op::Matrix</code>: Observation point states with 3D coordinates and wake positions</li><li><code>states_t::Matrix</code>: Turbine states including control parameters and operational conditions  </li><li><code>states_wf::Matrix</code>: Wind field states with velocity, direction, and turbulence data</li></ul><p><strong>Description</strong></p><p>The function performs the following initialization steps for each turbine:</p><ol><li>Retrieves wind field data (velocity, direction, turbulence intensity) based on the specified input methods</li><li>Initializes wind field states at all observation points for the turbine</li><li>Calculates downwind distances for wake coordinate system</li><li>Sets initial turbine states from provided parameters</li><li>Computes crosswind wake deflections using the centerline function</li><li>Transforms coordinates from wake-relative to world coordinate system</li><li>Updates observation point positions including turbine base and nacelle offsets</li></ol><p><strong>Notes</strong></p><ul><li>Supports multiple wind input methods including interpolation, constant values, and random walk models</li><li>Handles both 3D and 4D wind field configurations (with optional orientation data)</li><li>Uses SOWFA coordinate system conventions for angle transformations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floris/gaussian.jl#L231-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getVars" href="#FLORIDyn.getVars"><code>FLORIDyn.getVars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getVars(rps::Union{Matrix, Adjoint}, c_t, yaw, ti, ti0, 
        floris::Floris, d_rotor) -&gt; Tuple{Vector, Vector, Vector, Vector, Vector, Vector, Vector}</code></pre><p>Compute and return variables related to the Gaussian wake model for wind turbines.</p><p>In particular, it calculates the field width, the potential core data and the deflection. These values are needed for the calculation of the wake shape and speed  reduction. The values are based of the state of every individual OP.</p><p><strong>Arguments</strong></p><ul><li><code>rps</code>: Matrix of reference points where the variables are evaluated.</li><li><code>c_t</code>: Thrust coefficient(s) for the turbine(s).</li><li><code>yaw</code>: Yaw angle(s) of the turbine(s) in radians or degrees.</li><li><code>ti</code>: Turbulence intensity at the reference points.</li><li><code>ti0</code>: Ambient turbulence intensity.</li><li><code>floris::Floris</code>: FLORIS model parameters containing Gaussian wake model parameters (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>).</li><li><code>d_rotor</code>: Rotor diameter(s) of the turbine(s).</li></ul><p><strong>Returns</strong></p><p>Returns the tuple</p><ul><li>sig_y::Vector: Gaussian variance in y direction (sqrt of)</li><li>sig_z::Vector: Gaussian variance in z direction (sqrt of)</li><li>c_t: Thrust coefficient, same as OP.Ct</li><li>x_0: Potential core length</li><li>delta: Deflection</li><li>pc_y: Potential core boundary in y dir</li><li>pc_z: Potential core boundary in z dir</li></ul><p><strong>SOURCES</strong></p><ul><li>[1] Experimental and theoretical study of wind turbine wakes in yawed conditions - M. Bastankhah and F. Porté-Agel</li><li>[2] Design and analysis of a spatially heterogeneous wake - A. Farrell, J. King et al.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floris/gaussian.jl#L338-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getPower" href="#FLORIDyn.getPower"><code>FLORIDyn.getPower</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getPower(wf::WindFarm, m::AbstractMatrix, floris::Floris, con::Con)</code></pre><p>Calculate the power output of wind turbines in a wind farm simulation.</p><p>This function computes the power generated by wind turbines based on their operational states, wind conditions, and control settings. It accounts for yaw angle effects and optional yaw range constraints using hyperbolic tangent functions for smooth operational limits.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine states, dimensions, and operational data with current axial induction factors and yaw angles (see <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a>)</li><li><code>m::Matrix</code>: Measurement or simulation data matrix where column 3 contains effective wind speeds at turbine locations [m/s]</li><li><code>floris::Floris</code>: FLORIS model parameters containing air density, drivetrain efficiency, and power curve parameters (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>con::Con</code>: Controller configuration object with yaw control settings and operational constraints (see <a href="../settings/#FLORIDyn.Con"><code>Con</code></a>)</li></ul><p><strong>Returns</strong></p><ul><li><code>P::Vector{Float64}</code>: Power output for each turbine in the wind farm [W]</li></ul><p><strong>Description</strong></p><p>The function calculates power using the standard wind turbine power equation with yaw corrections:</p><pre><code class="language-julia hljs">P = 0.5 × ρ × A × Cp × U³ × η × cos(γ)^p_p × f_yaw_constraints</code></pre><p>Where:</p><ul><li><code>ρ</code> is air density [<code>floris.airDen</code>] [kg/m³]</li><li><code>A</code> is rotor swept area <code>π × (D/2)²</code> [m²]</li><li><code>Cp</code> is power coefficient calculated as <code>4a(1-a)²</code> [-]</li><li><code>U</code> is effective wind speed from column 3 of matrix <code>m</code> [m/s]</li><li><code>η</code> is drivetrain efficiency [<code>floris.eta</code>] [-]</li><li><code>γ</code> is yaw angle [rad]</li><li><code>p_p</code> is yaw power exponent [<code>floris.p_p</code>] [-]</li><li><code>f_yaw_constraints</code> is optional yaw range constraint factor [-]</li></ul><p>The yaw constraint factor is applied when <code>con.tanh_yaw</code> is true:</p><pre><code class="language-julia hljs">f_yaw_constraints = [0.5 × tanh((γ_max - γ) × 50) + 0.5] × 
                           [-0.5 × tanh((γ_min - γ) × 50) + 0.5]</code></pre><p><strong>Notes</strong></p><ul><li>Power coefficient is calculated from axial induction factor: <code>Cp = 4a(1-a)²</code></li><li>Yaw effects reduce power output according to <code>cos(γ)^p_p</code> where <code>p_p</code> is typically 1.88</li><li>Optional yaw range constraints use hyperbolic tangent functions with slope factor 50 for smooth transitions</li><li>When <code>con.tanh_yaw</code> is enabled, power is smoothly constrained within [<code>con.yawRangeMin</code>, <code>con.yawRangeMax</code>]</li><li>The constraint functions approach step functions but provide smooth gradients for optimization</li><li>Axial induction factors are extracted from <code>wf.States_T[wf.StartI, 1]</code> for current time step</li><li>Yaw angles are converted from degrees to radians internally</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floris/gaussian.jl#L634-L683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.runFLORIS" href="#FLORIDyn.runFLORIS"><code>FLORIDyn.runFLORIS</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runFLORIS(set::Settings, location_t, states_wf, states_t, d_rotor, 
          floris::Floris, windshear::Union{Matrix, WindShear})</code></pre><p>Execute the FLORIS (FLOw Redirection and Induction in Steady State) wake model simulation for wind farm analysis.</p><p>This function performs a comprehensive wake analysis using the Gaussian wake model to calculate velocity reductions, turbulence intensity additions, and effective wind speeds at turbine locations. It accounts for wake interactions, rotor discretization, wind shear effects, and turbulence propagation.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options for wind shear modeling</li><li><code>location_t</code>: Matrix of turbine positions [x, y, z] coordinates for each turbine [m]</li><li><code>states_wf</code>: Wind field state matrix containing velocity, direction, and turbulence data</li><li><code>states_t</code>: Turbine state matrix with axial induction factors, yaw angles, and turbulence intensities</li><li><code>d_rotor</code>: Vector of rotor diameters for each turbine [m]</li><li><code>floris::Floris</code>: FLORIS model parameters containing wake model coefficients and rotor discretization settings (see <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a>)</li><li><code>windshear</code>: Wind shear profile data for vertical wind speed variation modeling, either a matrix or of type <a href="../types/#FLORIDyn.WindShear"><code>WindShear</code></a></li></ul><p><strong>Returns</strong></p><p>A tuple <code>(T_red_arr, T_aTI_arr, T_Ueff, T_weight)</code> containing:</p><ul><li><code>T_red_arr::Vector{Float64}</code>: Velocity reduction factors for each turbine [-]</li><li><code>T_aTI_arr::Union{Vector{Float64}, Nothing}</code>: Added turbulence intensity from upstream wakes [%]</li><li><code>T_Ueff::Union{Float64, Nothing}</code>: Effective wind speed at the last turbine location [m/s]</li><li><code>T_weight::Union{Vector{Float64}, Nothing}</code>: Gaussian weight factors for wake overlap calculations [-]</li></ul><p><strong>Description</strong></p><p>The function performs the following computational steps:</p><p><strong>1. Rotor Discretization</strong></p><ul><li>Discretizes rotor planes into radial points using the isocell algorithm</li><li>Applies yaw rotation transformations to rotor point coordinates</li><li>Handles both active turbines (d_rotor &gt; 0) and placeholder turbines</li></ul><p><strong>2. Single Turbine Case</strong></p><p>For single turbine simulations, only wind shear effects are calculated without wake interactions.</p><p><strong>3. Multi-Turbine Wake Analysis</strong></p><p>For each upstream turbine affecting downstream turbines:</p><p><strong>Coordinate Transformations</strong></p><ul><li>Transforms rotor points to wake coordinate system aligned with wind direction</li><li>Applies rotational matrices for wind direction and turbine yaw angles</li><li>Filters turbines based on minimum downstream distance (10 rotor diameters)</li></ul><p><strong>Wake Variable Calculations</strong></p><ul><li>Computes wake expansion coefficients, potential core dimensions, and deflection using <code>getVars</code></li><li>Calculates crosswind wake positions and radial distances from wake centerline</li><li>Determines core region boundaries and near/far wake transitions</li></ul><p><strong>Velocity Reduction Modeling</strong></p><ul><li>Applies different deficit models for core region vs. Gaussian wake regions</li><li>Uses velocity deficit superposition for multiple wake interactions</li><li>Accounts for yaw-induced wake deflection and asymmetry</li></ul><p><strong>Turbulence Intensity Enhancement</strong></p><ul><li>Calculates added turbulence intensity using empirical correlations</li><li>Applies Gaussian weighting for spatial distribution of turbulence enhancement</li><li>Uses parameters k<em>fa, k</em>fb, k<em>fc, k</em>fd for turbulence intensity modeling</li></ul><p><strong>4. Wind Shear Integration</strong></p><ul><li>Applies vertical wind shear corrections to the downstream turbine</li><li>Uses wind shear profile data for realistic boundary layer effects</li></ul><p><strong>Mathematical Models</strong></p><p>The function implements several key wake modeling equations:</p><p><strong>Velocity Deficit</strong>: Based on Gaussian wake theory with yaw corrections <strong>Deflection</strong>: Uses analytical wake deflection models for yawed turbines   <strong>Turbulence</strong>: Empirical correlations for wake-added turbulence intensity <strong>Superposition</strong>: Linear superposition of velocity deficits from multiple wakes</p><p><strong>Notes</strong></p><ul><li>Uses SOWFA (Simulator for Offshore Wind Farm Applications) coordinate conventions</li><li>Implements state-of-the-art Gaussian wake model with yaw considerations</li><li>Supports both research and engineering applications for wind farm optimization</li><li>Computational complexity scales as O(N²) for N turbines due to wake interactions</li><li>Requires proper initialization of turbine states and wind field conditions</li></ul><p><strong>References</strong></p><ul><li>Bastankhah, M. and Porté-Agel, F. (2016). Experimental and theoretical study of wind turbine wakes in yawed conditions</li><li>Niayifar, A. and Porté-Agel, F. (2016). Analytical modeling of wind farms: A new approach for power prediction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floris/gaussian.jl#L441-L523">source</a></section></article><h1 id="FLORIDyn"><a class="docs-heading-anchor" href="#FLORIDyn">FLORIDyn</a><a id="FLORIDyn-1"></a><a class="docs-heading-anchor-permalink" href="#FLORIDyn" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.initSimulation" href="#FLORIDyn.initSimulation"><code>FLORIDyn.initSimulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initSimulation(wf::Union{Nothing, WindFarm}, sim::Sim) -&gt; Union{Nothing, WindFarm}</code></pre><p>Initialize or load a wind farm simulation state based on simulation settings.</p><p>This function handles the initialization phase of a wind farm simulation by either saving  the current initialized state to disk or loading a previously saved state, depending on  the simulation configuration.</p><p><strong>Arguments</strong></p><ul><li><code>wf::Union{Nothing, WindFarm}</code>: Wind farm object containing the initialized simulation state, or <code>Nothing</code> if no state is available. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>sim::Sim</code>: Simulation configuration object containing initialization settings and file paths. See <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>wf::Union{Nothing, WindFarm}</code>: The wind farm state, either the original input state (for &quot;init&quot; mode) or a loaded state from disk (for &quot;load&quot; mode)</li></ul><p><strong>Behavior</strong></p><p>The function operates in two modes based on <code>sim.init</code>:</p><p><strong>&quot;init&quot; Mode</strong></p><ul><li>Uses the provided wind farm state as-is</li><li>If <code>sim.save_init_state</code> is <code>true</code>, saves the current state to <code>&quot;T_init.jld2&quot;</code> in the specified data directory</li><li>Logs the save operation for user feedback</li></ul><p><strong>&quot;load&quot; Mode</strong></p><ul><li>Attempts to load a previously saved wind farm state from <code>&quot;T_init.jld2&quot;</code></li><li>Falls back to the provided state if loading fails (with warning)</li><li>Handles file I/O errors gracefully</li></ul><p><strong>File Operations</strong></p><ul><li><strong>Save path</strong>: <code>$(sim.path_to_data)/T_init.jld2</code></li><li><strong>Format</strong>: JLD2 binary format for efficient Julia object serialization</li><li><strong>Error handling</strong>: Loading failures produce warnings but do not halt execution</li></ul><p><strong>Notes</strong></p><ul><li>The function is case-insensitive for the initialization mode string</li><li>File operations use the path specified in <code>sim.path_to_data</code></li><li>Loading errors are caught and logged as warnings, allowing simulation to proceed with the original state</li><li>This mechanism enables reproducible simulations by preserving and reusing initial conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/floridyn_cl.jl#L61-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.findTurbineGroups" href="#FLORIDyn.findTurbineGroups"><code>FLORIDyn.findTurbineGroups</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findTurbineGroups(wf::WindFarm, floridyn::FloriDyn) -&gt; Vector{Vector{Int64}}</code></pre><p>Determine wake interaction dependencies between turbines in a wind farm.</p><p>This function analyzes the spatial relationships between turbines to identify which turbines  are affected by the wakes of upstream turbines. It uses coordinate transformations to the  wind-aligned reference frame and geometric criteria to determine wake interactions.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, operational points, and wind field states. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters containing wake interaction thresholds. See <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>vv_dep::Vector{Vector{Int64}}</code>: A vector of vectors where <code>vv_dep[i]</code> contains the indices of all turbines  that affect turbine <code>i</code> through wake interactions. Each inner vector lists the upstream turbine indices  that influence the wake conditions at the corresponding turbine.</li></ul><p><strong>Algorithm</strong></p><ol><li><strong>Coordinate Transformation</strong>: For each turbine pair, transforms coordinates to a wind-aligned frame using the closest operational point</li><li><strong>Wake Zone Detection</strong>: Applies geometric criteria to determine if a downstream turbine lies within the wake zone:<ul><li>Upstream extent: <code>r₁[1] ≥ -uw × D[iT]</code> (allowing for slight upstream influence)</li><li>Downstream extent: <code>r₁[1] ≤ dw × D[iT]</code> (wake extends downstream)  </li><li>Lateral extent: <code>|r₁[2]| ≤ cw × D[iT]</code> (wake width constraint)</li></ul></li><li><strong>Dependency Matrix</strong>: Constructs a boolean dependency matrix and extracts indices for each turbine</li></ol><p><strong>Mathematical Description</strong></p><p>The wake interaction criteria are evaluated in the wind-aligned coordinate system:</p><pre><code class="nohighlight hljs">r₁ = R(φ) × (rₒₚ - rₜᵤᵣᵦ)</code></pre><p>where:</p><ul><li><code>R(φ)</code> is the rotation matrix for wind direction angle <code>φ</code></li><li><code>rₒₚ</code> is the position of the closest operational point from the upstream turbine</li><li><code>rₜᵤᵣᵦ</code> is the position of the downstream turbine being evaluated</li></ul><p><strong>Notes</strong></p><ul><li>The function uses the closest operational point from each upstream turbine to determine wind direction</li><li>Wake zones are defined as multiples of rotor diameter using the FLORIDyn parameters</li><li>Self-interaction (turbine affecting itself) is explicitly excluded</li><li>The coordinate transformation accounts for the SOWFA wind direction convention</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/floridyn_cl.jl#L196-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.prepareSimulation" href="#FLORIDyn.prepareSimulation"><code>FLORIDyn.prepareSimulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepareSimulation(set::Settings, wind::Wind, con::Con, floridyn::FloriDyn, 
                  floris::Floris, turbProp, sim::Sim) -&gt; (WindFarm, Wind, Sim, Con, Floris)</code></pre><p>Prepares the simulation environment for a wind farm analysis using the provided settings and parameters.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings containing configuration options.</li><li><code>wind::Wind</code>: Wind conditions or wind field data. See: <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a> </li><li><code>con::Con</code>: Controller parameters of the turbines.  See: <a href="../settings/#FLORIDyn.Con"><code>Con</code></a></li><li><code>floridyn::FloriDyn</code>: Parameters specific to the FLORIDyn model. See: <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li><li><code>floris::Floris</code>: Parameters specific to the FLORIS model. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>turbProp</code>: Properties of the turbines involved in the simulation.</li><li><code>sim::Sim</code>: Simulation-specific parameters or state. See: <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li></ul><p><strong>Arguments that get modified</strong></p><ul><li><code>wind</code>: Updated with wind velocity, direction, turbulence intensity, and shear profile.</li><li><code>con</code>: Updated with yaw data.</li><li><code>sim</code>: Updated with the number of simulation steps.</li><li><code>floris</code>: May include additional parameters for the FLORIS model.</li></ul><p><strong>Returns</strong></p><ul><li>Returns the tuple <code>(wf, wind, sim, con, floris)</code> where:<ul><li><code>wf</code>: Wind farm struct containing turbine states and positions. See: <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>wind</code>: Updated wind conditions.</li><li><code>sim</code>: Updated simulation parameters.</li><li><code>con</code>: Updated controller parameters.</li><li><code>floris</code>: Parameters for the FLORIS model.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/prepare_simulation.jl#L136-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.perturbationOfTheWF!" href="#FLORIDyn.perturbationOfTheWF!"><code>FLORIDyn.perturbationOfTheWF!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">perturbationOfTheWF!(wf::WindFarm, wind::Wind) -&gt; Nothing</code></pre><p>Apply stochastic perturbations to the wind field states in-place.</p><p>This function adds Gaussian noise to the wind field parameters to model measurement  uncertainty or natural variability in wind conditions. The perturbations are applied  conditionally based on the wind perturbation configuration and are added directly  to the wind farm state matrix.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm struct containing the state matrix <code>States_WF</code> to be perturbed</li><li><code>wind::Wind</code>: Wind configuration struct containing perturbation settings. See <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: The function modifies the wind farm state in-place</li></ul><p><strong>Behavior</strong></p><p>The function applies independent Gaussian perturbations to three wind field parameters:</p><p><strong>Velocity Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.vel == true</code></li><li><strong>Target</strong>: Column 1 of <code>wf.States_WF</code> (wind velocity [m/s])</li><li><strong>Noise</strong>: <code>wind.perturbation.vel_sigma * randn(nOP × nT)</code></li></ul><p><strong>Direction Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.dir == true</code></li><li><strong>Target</strong>: Column 2 of <code>wf.States_WF</code> (wind direction [degrees])</li><li><strong>Noise</strong>: <code>wind.perturbation.dir_sigma * randn(nOP × nT)</code></li></ul><p><strong>Turbulence Intensity Perturbation</strong></p><ul><li><strong>Condition</strong>: <code>wind.perturbation.ti == true</code>  </li><li><strong>Target</strong>: Column 3 of <code>wf.States_WF</code> (turbulence intensity [-])</li><li><strong>Noise</strong>: <code>wind.perturbation.ti_sigma * randn(nOP × nT)</code></li></ul><p><strong>Mathematical Description</strong></p><p>For each enabled perturbation type, the function applies:</p><pre><code class="nohighlight hljs">States_WF[:, col] += σ × N(0,1)</code></pre><p>where:</p><ul><li><code>σ</code> is the standard deviation for the specific parameter</li><li><code>N(0,1)</code> is standard normal random noise with dimensions <code>(nOP × nT)</code></li><li><code>nOP</code> is the number of operational points per turbine</li><li><code>nT</code> is the total number of turbines</li></ul><p><strong>Notes</strong></p><ul><li>The function uses in-place modification (indicated by the <code>!</code> suffix)</li><li>Perturbations are applied independently to each operational point and turbine</li><li>The random noise follows a standard normal distribution scaled by the respective sigma values</li><li>Only enabled perturbation types (based on boolean flags) are applied</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/floridyn_cl.jl#L123-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.setUpTmpWFAndRun" href="#FLORIDyn.setUpTmpWFAndRun"><code>FLORIDyn.setUpTmpWFAndRun</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setUpTmpWFAndRun(set::Settings, wf::WindFarm, 
                 floris::Floris, wind::Wind) --&gt; (Matrix, WindFarm)</code></pre><p>Execute FLORIS wake calculations for all turbines in a wind farm with wake interactions.</p><p>This function orchestrates the computation of wake effects for each turbine by setting up  temporary wind farm configurations that include influencing upstream turbines. It handles  both single turbine (no wake interactions) and multi-turbine scenarios with complex wake  interaction patterns.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Simulation settings and configuration parameters</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine positions, operational points, dependencies, and interpolation data<ul><li><code>wf.nT</code>: Number of turbines</li><li><code>wf.States_WF</code>: Wind field states matrix</li><li><code>wf.States_T</code>: Turbine states matrix</li><li><code>wf.States_OP</code>: Operational point states matrix</li><li><code>wf.dep</code>: Turbine dependency relationships (from <a href="#FLORIDyn.findTurbineGroups"><code>findTurbineGroups</code></a>)</li><li><code>wf.intOPs</code>: Interpolation weights and indices (from <a href="#FLORIDyn.interpolateOPs"><code>interpolateOPs</code></a>)</li><li><code>wf.posBase</code>: Base turbine positions [m]</li><li><code>wf.posNac</code>: Nacelle position offsets [m]</li><li><code>wf.D</code>: Rotor diameters [m]</li><li><code>wf.StartI</code>: Starting indices for each turbine&#39;s operational points</li></ul></li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations. See <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>wind::Wind</code>: Wind field configuration including shear properties. See <a href="../settings/#FLORIDyn.Wind"><code>Wind</code></a></li></ul><p><strong>Returns</strong></p><ul><li><code>M::Matrix{Float64}</code>: Results matrix of size <code>(nT × 3)</code> where each row contains:<ul><li>Column 1: Total velocity reduction factor (product of all wake effects)</li><li>Column 2: Combined added turbulence intensity from all upstream turbines</li><li>Column 3: Effective wind speed at turbine [m/s]</li></ul></li><li><code>wf::WindFarm</code>: Updated wind farm object with modified fields:<ul><li><code>wf.Weight</code>: Normalized interpolation weights for each turbine</li><li><code>wf.red_arr</code>: Wake reduction matrix showing turbine-to-turbine wake effects</li></ul></li></ul><p><strong>Algorithm</strong></p><p>The function processes each turbine individually:</p><p><strong>Single Turbine Case (No Dependencies)</strong></p><ul><li>Directly calls FLORIS with the turbine&#39;s wind field state</li><li>No wake interactions considered</li><li>Results stored directly in output matrix</li></ul><p><strong>Multi-Turbine Case (With Dependencies)</strong></p><ol><li><strong>Temporary Configuration Setup</strong>: Creates temporary arrays sized for the target turbine plus all influencing turbines</li><li><strong>Interpolation Application</strong>: Uses precomputed interpolation weights to determine states at influencing turbine positions</li><li><strong>Coordinate Transformation</strong>: Applies wind direction-based coordinate transformations to account for spatial offsets</li><li><strong>FLORIS Execution</strong>: Runs wake model with the complete multi-turbine configuration</li><li><strong>Result Processing</strong>: Combines wake effects and normalizes weights</li></ol><p><strong>Mathematical Description</strong></p><p>For multi-turbine scenarios, the effective position of influencing turbines is computed as:</p><pre><code class="nohighlight hljs">tmp_Tpos[i] = base_position - R(φ) × [offset_x, offset_y, offset_z]</code></pre><p>where <code>R(φ)</code> is the rotation matrix for wind direction <code>φ</code>.</p><p>The total wake reduction is the product of individual wake effects:</p><pre><code class="nohighlight hljs">T_red = ∏ᵢ T_red_arr[i]</code></pre><p>Combined turbulence intensity follows root-sum-square combination:</p><pre><code class="nohighlight hljs">T_addedTI = √(∑ᵢ T_aTI_arr[i]²)</code></pre><p><strong>Wind Field Interpolation</strong></p><p>The function supports optional wind field interpolation via coefficient matrices:</p><ul><li><strong>Velocity interpolation</strong>: Uses <code>wf.C_Vel</code> if available</li><li><strong>Direction interpolation</strong>: Uses <code>wf.C_Dir</code> if available</li></ul><p><strong>Notes</strong></p><ul><li>The function modifies the wind farm object in-place, updating weight and reduction arrays</li><li>Interpolation weights are normalized to ensure proper weighting</li><li>Special handling for variable rotor diameter configurations</li><li>Coordinate transformations use the SOWFA to world conversion via <a href="#FLORIDyn.angSOWFA2world"><code>angSOWFA2world</code></a></li><li>The algorithm efficiently handles both simple single-turbine and complex multi-turbine wake scenarios</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/floridyn_cl.jl#L541-L620">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.interpolateOPs" href="#FLORIDyn.interpolateOPs"><code>FLORIDyn.interpolateOPs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolateOPs(wf::WindFarm) -&gt; Vector{Matrix{Float64}}</code></pre><p>Compute interpolation weights and indices for operational points affecting each turbine.</p><p>This function determines the optimal interpolation strategy for each turbine by identifying  the closest operational points from influencing upstream turbines. It computes weights and  indices that enable smooth interpolation of wind field states and turbine conditions at  arbitrary turbine positions.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Wind farm object containing turbine dependencies, operational point states, and positional data<ul><li><code>wf.nT</code>: Number of turbines</li><li><code>wf.StartI</code>: Starting indices for each turbine&#39;s operational points  </li><li><code>wf.dep</code>: Dependency relationships between turbines (from <a href="#FLORIDyn.findTurbineGroups"><code>findTurbineGroups</code></a>)</li><li><code>wf.States_OP</code>: Matrix of operational point states</li><li><code>wf.posBase</code>: Base positions of turbines [m]</li><li><code>wf.nOP</code>: Number of operational points per turbine</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>intOPs::Vector{Matrix{Float64}}</code>: Interpolation data for each turbine where <code>intOPs[i]</code> is an  <code>N×4</code> matrix for turbine <code>i</code> with <code>N</code> influencing turbines. Each row contains:<ul><li>Column 1: First operational point index</li><li>Column 2: Weight for first operational point</li><li>Column 3: Second operational point index  </li><li>Column 4: Weight for second operational point</li></ul></li></ul><p><strong>Algorithm</strong></p><p>For each turbine and its influencing upstream turbines:</p><ol><li><p><strong>Distance Calculation</strong>: Computes Euclidean distances from all operational points of  the influencing turbine to the target turbine position</p></li><li><p><strong>Interpolation Strategy Selection</strong>: Based on the closest operational point location:</p><ul><li><strong>First OP closest</strong>: Uses first and second operational points</li><li><strong>Last OP closest</strong>: Uses second-to-last and last operational points</li><li><strong>Interior OP closest</strong>: Uses the two closest operational points for optimal interpolation</li></ul></li><li><p><strong>Weight Computation</strong>: For interior cases, applies linear projection to determine interpolation weights:</p><pre><code class="language-julia hljs">d = dot(ab, ac) / dot(ab, ab)
weights = [1-d, d] # Clamped to [0,1]</code></pre></li></ol><p><strong>Mathematical Description</strong></p><p>The interpolation uses linear projection for weight computation:</p><pre><code class="nohighlight hljs">d = (b - a) · (c - a) / |b - a|²</code></pre><p>where:</p><ul><li><code>a</code>, <code>b</code> are positions of the two closest operational points</li><li><code>c</code> is the target turbine position</li><li><code>d</code> is the projection parameter (clamped to [0,1])</li></ul><p><strong>Notes</strong></p><ul><li>Edge cases (first/last operational points) use predefined weight combinations</li><li>Weights always sum to 1.0 for proper interpolation</li><li>The function handles variable numbers of influencing turbines per target turbine</li><li>Interpolation indices are global across the entire operational point matrix</li><li>This preprocessing enables efficient interpolation during simulation time steps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/floridyn_cl.jl#L317-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.iterateOPs!" href="#FLORIDyn.iterateOPs!"><code>FLORIDyn.iterateOPs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterateOPs!(::IterateOPs_basic, wf::WindFarm, sim::Sim, floris::Floris, floridyn::FloriDyn)</code></pre><p>Advance operational points through the wind field using time-marching dynamics.</p><p>This function implements the basic time-stepping algorithm for operational points (OPs) in the  FLORIDyn simulation. It advances all operational points through space based on wind velocities  and wake deflection effects, maintaining proper ordering and updating turbine states accordingly.</p><p><strong>Arguments</strong></p><ul><li><code>::IterateOPs_basic</code>: Dispatch type indicating the basic iteration algorithm</li><li><code>wf::WindFarm</code>: Wind farm object containing all turbine and operational point states. See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a><ul><li><code>wf.States_OP</code>: Matrix of operational point states [x, y, z, <code>dw_pos</code>, <code>cw_x</code>, <code>cw_z</code>, ...]</li><li><code>wf.States_T</code>: Matrix of turbine states </li><li><code>wf.States_WF</code>: Matrix of wind field states [velocity, direction, <code>turbulence_intensity</code>, ...]</li><li><code>wf.StartI</code>: Starting indices for each turbine&#39;s operational points</li><li><code>wf.nT</code>: Number of turbines</li><li><code>wf.nOP</code>: Number of operational points per turbine</li><li><code>wf.D</code>: Rotor diameters [m]</li></ul></li><li><code>sim::Sim</code>: Simulation configuration object. See <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a><ul><li><code>sim.time_step</code>: Time step size [s]</li><li><code>sim.dyn.advection</code>: Advection scaling factor</li></ul></li><li><code>floris::Floris</code>: FLORIS model parameters for wake deflection calculations. See <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters. See <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>Algorithm</strong></p><p>The function performs the following steps for each time iteration:</p><p><strong>1. State Preservation</strong></p><p>Saves the current turbine operational point states before advancement to preserve boundary conditions.</p><p><strong>2. Spatial Advancement</strong></p><p><strong>Downwind Movement</strong></p><p>Advances operational points downstream based on local wind velocity:</p><pre><code class="nohighlight hljs">step_dw = Δt × U × advection_factor
OP_dw_position += step_dw</code></pre><p><strong>Crosswind Deflection</strong></p><p>Calculates wake centerline deflection using FLORIS model and updates crosswind positions:</p><pre><code class="nohighlight hljs">deflection = centerline(States_OP, States_T, States_WF, floris, D)
OP_cw_position = deflection</code></pre><p><strong>3. Coordinate System Transformation</strong></p><p>Converts local wind-aligned movements to world coordinates using wind direction:</p><pre><code class="nohighlight hljs">φ = angSOWFA2world(wind_direction)
x_world += cos(φ) × step_dw - sin(φ) × step_cw_x
y_world += sin(φ) × step_dw + cos(φ) × step_cw_x
z_world += step_cw_z</code></pre><p><strong>4. Temporal Shifting</strong></p><p>Uses circular shifting to advance the time history:</p><ul><li>Shifts all state matrices by one time step</li><li>Initializes new operational points with saved turbine states</li><li>Maintains temporal continuity of the simulation</li></ul><p><strong>5. Spatial Ordering</strong></p><p>Ensures operational points remain ordered by downstream position for each turbine:</p><ul><li>Sorts operational points by downstream position (<code>States_OP[:, 4]</code>)</li><li>Maintains consistency across all state matrices</li></ul><p><strong>Mathematical Description</strong></p><p>The coordinate transformation from wind-aligned to world coordinates follows:</p><pre><code class="nohighlight hljs">[x&#39;]   [cos(φ)  -sin(φ)] [step_dw ]
[y&#39;] = [sin(φ)   cos(φ)] [step_cw_x]</code></pre><p>where <code>φ</code> is the wind direction angle in world coordinates.</p><p><strong>Notes</strong></p><ul><li>The function modifies the wind farm object in-place (indicated by the <code>!</code> suffix)</li><li>Temporal shifting maintains a moving window of operational point history</li><li>Spatial ordering ensures downstream distance monotonicity for wake calculations</li><li>The algorithm handles both advection and deflection physics simultaneously</li><li>Coordinate transformations account for SOWFA wind direction conventions via <a href="#FLORIDyn.angSOWFA2world"><code>angSOWFA2world</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/iterate.jl#L4-L87">source</a></section><section><div><pre><code class="language-julia hljs">iterateOPs!(::IterateOPs_basic, wf::WindFarm, sim::Sim, floris::Floris, 
            floridyn::FloriDyn, buffers::IterateOPsBuffers)</code></pre><p>Allocation-free version of iterateOPs! that uses pre-allocated buffers.</p><p>This is the high-performance, zero-allocation version of the operational point iteration algorithm. All temporary arrays are pre-allocated in the buffers parameter to eliminate runtime allocations.</p><p><strong>Arguments</strong></p><ul><li><code>::IterateOPs_basic</code>: Dispatch type indicating the basic iteration algorithm</li><li><code>wf::WindFarm</code>: Wind farm object (same as standard version)</li><li><code>sim::Sim</code>: Simulation configuration object (same as standard version)  </li><li><code>floris::Floris</code>: FLORIS model parameters (same as standard version)</li><li><code>floridyn::FloriDyn</code>: FLORIDyn model parameters (same as standard version)</li><li><code>buffers::IterateOPsBuffers</code>: Pre-allocated buffers for all temporary calculations. See <a href="../types/#FLORIDyn.IterateOPsBuffers"><code>IterateOPsBuffers</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>Performance Notes</strong></p><ul><li>Zero allocations during execution (after initial buffer setup)</li><li>Suitable for performance-critical applications and benchmarking</li><li>Buffers can be reused across multiple calls for maximum efficiency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/iterate.jl#L204-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.angSOWFA2world" href="#FLORIDyn.angSOWFA2world"><code>FLORIDyn.angSOWFA2world</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angSOWFA2world(deg_SOWFA) -&gt; Float64</code></pre><p>Convert wind direction angle from SOWFA convention to world coordinate system.</p><p>This function performs coordinate transformation between different wind direction conventions used in wind farm simulations. SOWFA (Simulator fOr Wind Farm Applications) uses a different angular reference system than the standard world coordinate system used in calculations.</p><p><strong>Arguments</strong></p><ul><li><code>deg_SOWFA::Real</code>: Wind direction angle in SOWFA convention [degrees]</li></ul><p><strong>Returns</strong></p><ul><li><code>rad_World</code>: Wind direction angle in world coordinate system [radians]</li></ul><p><strong>Coordinate System Conversion</strong></p><p>The transformation follows the relationship:</p><pre><code class="nohighlight hljs">θ_world = 270° - θ_SOWFA</code></pre><p><strong>SOWFA Convention</strong></p><ul><li>Wind direction angles are defined clockwise from a reference direction</li></ul><p><strong>World Convention</strong></p><ul><li>Wind direction angles are defined counterclockwise for mathematical calculations</li><li>Standard convention used in wake models and analytical computations</li></ul><p><strong>Mathematical Description</strong></p><p>The conversion process:</p><ol><li><strong>Angular transformation</strong>: <code>deg_World = 270 - deg_SOWFA</code></li><li><strong>Unit conversion</strong>: <code>rad_World = deg2rad(deg_World)</code></li></ol><p>The 270° offset accounts for the difference between clockwise (SOWFA) and  counterclockwise (world) angular conventions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Convert 90° SOWFA direction to world coordinates
world_angle = angSOWFA2world(90.0)  # Returns 3.141592... (180° in radians)

# Convert 0° SOWFA direction  
world_angle = angSOWFA2world(0.0)   # Returns 4.712388... (270° in radians)</code></pre><p><strong>Notes</strong></p><ul><li>The function handles the sign convention difference between coordinate systems</li><li>Output is always in radians for use in trigonometric calculations</li><li>This transformation is essential for proper wake modeling in wind farm simulations</li><li>The 270° offset ensures proper alignment between SOWFA and mathematical conventions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/floridyn_cl.jl#L4-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.runFLORIDyn" href="#FLORIDyn.runFLORIDyn"><code>FLORIDyn.runFLORIDyn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runFLORIDyn(plt, set::Settings, wf::WindFarm, wind::Wind, sim::Sim, con::Con, vis::Vis,
            floridyn::FloriDyn, floris::Floris, pff=nothing) -&gt; (WindFarm, DataFrame, Matrix)</code></pre><p>Main entry point for the FLORIDyn closed-loop simulation.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plot object for live visualization during simulation</li><li><code>set::Settings</code>: Simulation settings and configuration parameters.</li><li><code>wf::WindFarm</code>: See: <a href="../types/#FLORIDyn.WindFarm">WindFarm</a> simulation state, including turbine and wind farm states.</li><li><code>wind::Wind</code>: See: <a href="../settings/#FLORIDyn.Wind">Wind</a> field settings.</li><li><code>sim::Sim</code>: Simulation state or configuration object. See: <a href="../settings/#FLORIDyn.Sim"><code>Sim</code></a></li><li><code>con::Con</code>: Controller object or control parameters. See: <a href="../settings/#FLORIDyn.Con"><code>Con</code></a></li><li><code>vis::Vis</code>: Visualization settings controlling online plotting and animation. See: <a href="../settings/#FLORIDyn.Vis"><code>Vis</code></a></li><li><code>floridyn::FloriDyn</code>: Parameters specific to the FLORIDyn model. See: <a href="../settings/#FLORIDyn.FloriDyn"><code>FloriDyn</code></a></li><li><code>floris::Floris</code>: Parameters specific to the FLORIS model. See: <a href="../settings/#FLORIDyn.Floris"><code>Floris</code></a></li><li><code>pff</code>: Optional remote plotting function for intermediate simulation results. When provided, this function  is called remotely (using <code>@spawnat 2</code>) to plot flow field visualization on a separate worker process. The function should accept parameters <code>(wf, X, Y, Z, vis, t_rel; msr=VelReduction)</code> where <code>wf</code> is the wind farm state, <code>X</code>, <code>Y</code>, <code>Z</code> are flow field coordinates and velocities, <code>vis</code> contains visualization settings, and <code>t_rel</code>  is the relative simulation time. Defaults to <code>nothing</code> for local plotting.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(wf, md, mi)</code> containing:</p><ul><li><code>wf::WindFarm</code>: Updated simulation state with final turbine positions, wind field states, and operational point data</li><li><code>md::DataFrame</code>: Measurement data with columns:<ul><li><code>:Time</code>: Simulation time steps</li><li><code>:ForeignReduction</code>: Wind speed reduction factors (%) due to wake effects from other turbines</li><li><code>:AddedTurbulence</code>: Additional turbulence intensity (%) induced by upstream turbines</li><li><code>:EffWindSpeed</code>: Effective wind speed (m/s) at each turbine after wake effects</li><li><code>:FreeWindSpeed</code>: Free-stream wind speed (m/s) without wake interference</li><li><code>:PowerGen</code>: Generated electrical power (MW) for each turbine</li></ul></li><li><code>mi::Matrix</code>: Interaction matrix combining time data with turbine-to-turbine wake interaction coefficients                for each simulation step</li></ul><p><strong>Description</strong></p><p>Runs a closed-loop wind farm simulation using the FLORIDyn and FLORIS models,  applying control strategies and updating turbine states over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/floridyn_cl/floridyn_cl.jl#L930-L969">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.run_floridyn" href="#FLORIDyn.run_floridyn"><code>FLORIDyn.run_floridyn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_floridyn(plt, set, wf, wind, sim, con, vis, 
             floridyn, floris; msr=VelReduction) -&gt; (WindFarm, DataFrame, Matrix)</code></pre><p>Unified function that automatically handles both multi-threading and single-threading modes for running FLORIDyn simulations with appropriate plotting callbacks.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: PyPlot instance, usually provided by ControlPlots</li><li><code>set</code>: Settings object</li><li><code>wf</code>: WindFarm object</li><li><code>wind</code>: Wind field object</li><li><code>sim</code>: Simulation object</li><li><code>con</code>: Controller object</li><li><code>vis</code>: Visualization settings</li><li><code>floridyn</code>: FLORIDyn model object</li><li><code>floris</code>: FLORIS model object</li><li><code>msr</code>: Measurement index for online flow field plotting (1=velocity reduction, 2=added turbulence, 3=effective wind speed). Default 1.</li></ul><p><strong>Returns</strong></p><ul><li>Tuple (wf, md, mi): WindFarm, measurement data, and interaction matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/FLORIDyn.jl#L351-L372">source</a></section></article><h1 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getMeasurements" href="#FLORIDyn.getMeasurements"><code>FLORIDyn.getMeasurements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getMeasurements(mx::Matrix, my::Matrix, nM::Int, zh::Real, wf::WindFarm, set::Settings, 
                floris::Floris, wind::Wind) -&gt; Array{Float64,3}</code></pre><p>Calculate flow field measurements at specified grid points by treating them as virtual turbines.</p><p>This function computes flow field properties (velocity reduction, added turbulence, effective wind speed) at grid points by creating virtual turbines at each location and running the FLORIS wake model. Each grid point is treated as a turbine that depends on all real turbines in the wind farm, allowing wake effects to be captured in the flow field visualization.</p><p><strong>Arguments</strong></p><ul><li><code>mx::Matrix</code>: X-coordinates of grid points (m)</li><li><code>my::Matrix</code>: Y-coordinates of grid points (m)  </li><li><code>nM::Int</code>: Number of measurements to compute (typically 3)</li><li><code>zh::Real</code>: Hub height for measurements (m)</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine data<ul><li><code>wf.nT</code>: Number of real turbines</li><li><code>wf.StartI</code>: Starting indices for turbine data</li><li><code>wf.posBase</code>, <code>wf.posNac</code>: Turbine positions</li><li><code>wf.States_*</code>: Turbine state matrices</li></ul></li><li><code>set::Settings</code>: Settings object containing simulation parameters</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations</li><li><code>wind::Wind</code>: Wind field configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions <code>(size(mx,1), size(mx,2), nM)</code><ul><li><code>mz[:,:,1]</code>: Velocity reduction</li><li><code>mz[:,:,2]</code>: Added turbulence intensity</li><li><code>mz[:,:,3]</code>: Effective wind speed</li></ul></li></ul><p><strong>Algorithm</strong></p><p>For each grid point:</p><ol><li>Creates a temporary wind farm with all original turbines plus one virtual turbine at the grid point</li><li>Sets the virtual turbine to depend on all real turbines (to capture wake effects)</li><li>Runs the FLORIS simulation to compute wake-affected flow properties</li><li>Extracts the result for the virtual turbine position</li></ol><p><strong>Performance Notes</strong></p><ul><li>Single-threaded implementation (can be parallelized with <code>@threads</code> for large grids)</li><li>Each grid point requires a full wind farm simulation, so computation time scales with grid size</li><li>Uses pre-allocated buffer to avoid repeated <code>deepcopy</code> operations for better performance</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a 10x10 grid from 0 to 1000m
x_range = 0:100:1000
y_range = 0:100:1000
mx = repeat(collect(x_range)&#39;, length(y_range), 1)
my = repeat(collect(y_range), 1, length(x_range))

# Calculate 3 measurements at 90m hub height
mz = getMeasurements(mx, my, 3, 90.0, wind_farm, settings, floris_model, wind_config)

# Extract effective wind speed field
wind_speed_field = mz[:, :, 3]</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.calcFlowField"><code>calcFlowField</code></a>: Higher-level function that uses this to create complete flow field data</li><li><a href="#FLORIDyn.setUpTmpWFAndRun"><code>setUpTmpWFAndRun</code></a>: Underlying simulation function used for each grid point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/calc_flowfield.jl#L128-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.create_thread_buffers" href="#FLORIDyn.create_thread_buffers"><code>FLORIDyn.create_thread_buffers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_thread_buffers(wf::WindFarm, nth::Int) -&gt; ThreadBuffers</code></pre><p>Create thread-local buffers for parallel flow field computation.</p><p>This function pre-allocates all necessary data structures for each thread to avoid race conditions and memory allocations during the parallel computation loop.</p><p><strong>Arguments</strong></p><ul><li><code>wf::WindFarm</code>: Original wind farm object to use as template</li><li><code>nth::Int</code>: Number of threads to create buffers for</li></ul><p><strong>Returns</strong></p><ul><li><code>ThreadBuffers</code>: Struct containing all thread-local buffers</li></ul><p><strong>Performance Notes</strong></p><ul><li>Each thread gets its own copy of the WindFarm structure</li><li>Pre-allocates all arrays to minimize allocations during computation</li><li>Sets up dependency structure for virtual turbines at grid points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/calc_flowfield.jl#L31-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.getMeasurementsP" href="#FLORIDyn.getMeasurementsP"><code>FLORIDyn.getMeasurementsP</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getMeasurementsP(mx::Matrix, my::Matrix, nM::Int, zh::Real, wf::WindFarm, set::Settings, 
                 floris::Floris, wind::Wind) -&gt; Array{Float64,3}</code></pre><p>Calculate flow field measurements at specified grid points by treating them as virtual turbines.</p><p>This function computes flow field properties (velocity reduction, added turbulence, effective wind speed) at grid points by creating virtual turbines at each location and running the FLORIS wake model. Each grid point is treated as a turbine that depends on all real turbines in the wind farm, allowing wake effects to be captured in the flow field visualization.</p><p><strong>Arguments</strong></p><ul><li><code>mx::Matrix</code>: X-coordinates of grid points (m)</li><li><code>my::Matrix</code>: Y-coordinates of grid points (m)  </li><li><code>nM::Int</code>: Number of measurements to compute (typically 3)</li><li><code>zh::Real</code>: Hub height for measurements (m)</li><li><code>wf::WindFarm</code>: Wind farm object containing turbine data<ul><li><code>wf.nT</code>: Number of real turbines</li><li><code>wf.StartI</code>: Starting indices for turbine data</li><li><code>wf.posBase</code>, <code>wf.posNac</code>: Turbine positions</li><li><code>wf.States_*</code>: Turbine state matrices</li></ul></li><li><code>set::Settings</code>: Settings object containing simulation parameters</li><li><code>floris::Floris</code>: FLORIS model parameters for wake calculations</li><li><code>wind::Wind</code>: Wind field configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions <code>(size(mx,1), size(mx,2), nM)</code><ul><li><code>mz[:,:,1]</code>: Velocity reduction</li><li><code>mz[:,:,2]</code>: Added turbulence intensity</li><li><code>mz[:,:,3]</code>: Effective wind speed</li></ul></li></ul><p><strong>Algorithm</strong></p><p>For each grid point:</p><ol><li>Creates a temporary wind farm with all original turbines plus one virtual turbine at the grid point</li><li>Sets the virtual turbine to depend on all real turbines (to capture wake effects)</li><li>Runs the FLORIS simulation to compute wake-affected flow properties</li><li>Extracts the result for the virtual turbine position</li></ol><p><strong>Performance Notes</strong></p><ul><li>Multi-threaded implementation using <code>@threads</code> for parallel processing of grid points</li><li>Each grid point requires a full wind farm simulation, so computation time scales with grid size</li><li>Uses thread-local buffers created by <a href="#FLORIDyn.create_thread_buffers"><code>create_thread_buffers</code></a> to avoid race conditions</li><li>Scales well with the number of available CPU cores</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a 10x10 grid from 0 to 1000m
x_range = 0:100:1000
y_range = 0:100:1000
mx = repeat(collect(x_range)&#39;, length(y_range), 1)
my = repeat(collect(y_range), 1, length(x_range))

# Calculate 3 measurements at 90m hub height
mz = getMeasurements(mx, my, 3, 90.0, wind_farm, settings, floris_model, wind_config)

# Extract effective wind speed field
wind_speed_field = mz[:, :, 3]</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.calcFlowField"><code>calcFlowField</code></a>: Higher-level function that uses this to create complete flow field data</li><li><a href="#FLORIDyn.setUpTmpWFAndRun"><code>setUpTmpWFAndRun</code></a>: Underlying simulation function used for each grid point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/calc_flowfield.jl#L265-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.calcFlowField" href="#FLORIDyn.calcFlowField"><code>FLORIDyn.calcFlowField</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calcFlowField(set::Settings, wf::WindFarm, wind::Wind, floris::Floris; plt=nothing)</code></pre><p>Generate full flow field plot data by calculating measurements across a grid.</p><p>This function creates a rectangular grid over the wind farm domain and calculates flow field properties at each grid point by treating them as virtual turbines. The computation can be performed in parallel if <code>set.parallel</code> is true, with automatic garbage collection management for thread safety.</p><p><strong>Arguments</strong></p><ul><li><code>set::Settings</code>: Settings object containing simulation parameters<ul><li><code>set.parallel</code>: If true, uses parallel computation with multiple threads</li></ul></li><li><code>wf::WindFarm</code>: Wind farm object containing turbine data</li><li><code>wind::Wind</code>: Wind field configuration  </li><li><code>floris::Floris</code>: FLORIS model parameters</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>plt=nothing</code>: Plot object for garbage collection control. If provided and <code>set.parallel</code> is true, automatically calls <code>plt.GC.enable(false)</code> before multithreading and <code>plt.GC.enable(true)</code>  after completion to prevent PyCall-related segmentation faults during parallel execution.</li></ul><p><strong>Returns</strong></p><ul><li><code>Z::Array{Float64,3}</code>: 3D array of flow field measurements with dimensions <code>(ny, nx, 3)</code><ul><li><code>Z[:,:,1]</code>: Velocity reduction factor</li><li><code>Z[:,:,2]</code>: Added turbulence intensity  </li><li><code>Z[:,:,3]</code>: Effective wind speed (m/s)</li></ul></li><li><code>X::Matrix{Float64}</code>: X-coordinate grid (m)</li><li><code>Y::Matrix{Float64}</code>: Y-coordinate grid (m)</li></ul><p><strong>Performance Notes</strong></p><ul><li>Uses parallel computation when <code>set.parallel=true</code> for significant speedup on multi-core systems</li><li>Automatic garbage collection management prevents threading-related crashes</li><li>Grid resolution is fixed at 20m with domain from [0,0] to [3000,3000] meters</li><li>Hub height is taken from the first turbine in the wind farm</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Calculate flow field with parallel computation and GC control
set.parallel = true
Z, X, Y = calcFlowField(set, wf, wind, floris; plt)

# Extract velocity reduction field
velocity_reduction = Z[:, :, 1]

# Extract effective wind speed field  
wind_speed = Z[:, :, 3]</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.getMeasurements"><code>getMeasurements</code></a>: Single-threaded implementation</li><li><a href="#FLORIDyn.getMeasurementsP"><code>getMeasurementsP</code></a>: Multi-threaded implementation</li><li><a href="#FLORIDyn.plotFlowField"><code>plotFlowField</code></a>: Visualization function for the generated data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/calc_flowfield.jl#L384-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.plotFlowField" href="#FLORIDyn.plotFlowField"><code>FLORIDyn.plotFlowField</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plotFlowField(state::Union{Nothing, PlotState}, plt, wf, mx, my, mz, vis, t; msr=EffWind)</code></pre><p>Plot a 2D contour of the flow field data with support for animation.</p><p><strong>Arguments</strong></p><ul><li><code>state::Union{Nothing, PlotState}</code>: Animation state object. Pass <code>nothing</code> for the first call,  then pass the returned state for subsequent calls to maintain the same figure and layout.</li><li><code>plt</code>: Plotting package (e.g., ControlPlots.plt)</li><li><code>wf</code>: Wind farm object containing turbine data</li><li><code>mx::Matrix</code>: X-coordinate grid</li><li><code>my::Matrix</code>: Y-coordinate grid  </li><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions (rows, cols, nM)</li><li><code>vis::Vis</code>: Visualization settings including save options and color scale parameters</li><li><code>t</code>: Time value for display in the plot title or annotations</li><li><code>msr::MSR</code>: Which measurement to plot. See: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>vis.unit_test::Bool</code>: Whether to automatically close plots for testing.</li></ul><p><strong>Returns</strong></p><ul><li><code>state::PlotState</code>: Updated or newly created plot state for use in subsequent calls</li></ul><p><strong>Description</strong></p><p>This function supports creating animations by maintaining plot state across multiple calls:</p><p><strong>First Call (state = nothing)</strong></p><ul><li>Creates new figure, axes, colorbar, and all plot elements</li><li>Initializes and returns a PlotState object</li></ul><p><strong>Subsequent Calls (state = PlotState)</strong></p><ul><li>Updates existing contour data, turbine positions, and operational points</li><li>Reuses the same figure and layout for smooth animation</li></ul><p><strong>Animation Example</strong></p><pre><code class="language-julia hljs">using ControlPlots

# Initialize state (first frame)
state = nothing
vis = Vis(online=true, save=true)  # Enable saving to video folder
for t in time_steps
    Z, X, Y = calcFlowField(settings, wind_farm, wind, floris)
    state = plotFlowField(state, plt, wind_farm, X, Y, Z, vis, t; msr=EffWind)
    plt.pause(0.01)  # Small delay for animation
end</code></pre><p><strong>Notes</strong></p><ul><li>The function automatically handles coordinate system transformations for turbine orientations</li><li>Operational points are displayed as white scatter points for reference</li><li>Color scales are kept consistent across animation frames when using the same measurement type</li><li>The time parameter <code>t</code> can be used for title updates or time annotations</li><li>When <code>vis.save=true</code>, plots are saved as PNG files to the <code>video/</code> directory</li><li>Saved filenames include measurement type and time information (e.g., <code>velocity_reduction_t0120s.png</code>)</li><li>The <code>video/</code> directory is automatically created if it doesn&#39;t exist</li><li>This function requires a plotting package like ControlPlots.jl to be loaded and available as <code>plt</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/plot_flowfield.jl#L40-L95">source</a></section><section><div><pre><code class="language-julia hljs">plotFlowField(plt, wf, mx, my, mz, vis, t=nothing; msr=EffWind)</code></pre><p>Compatibility method for the original plotFlowField interface.</p><p>This method provides backward compatibility by calling the new state-based version  with <code>state=nothing</code>, effectively creating a single plot without animation support.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plotting package (e.g., ControlPlots.plt)</li><li><code>wf</code>: Wind farm object containing turbine data</li><li><code>mx::Matrix</code>: X-coordinate grid</li><li><code>my::Matrix</code>: Y-coordinate grid  </li><li><code>mz::Array{Float64,3}</code>: 3D array of measurements with dimensions (rows, cols, nM)</li><li><code>vis::Vis</code>: Visualization settings including save options and color scale parameters</li><li><code>t</code>: Time value for display in the plot title or annotations</li><li><code>msr::MSR</code>: Which measurement to plot. See: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>vis.unit_test::Bool</code>: Whether to automatically close plots for testing.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: For compatibility with the original interface</li></ul><p><strong>Note</strong></p><p>This method is provided for backward compatibility. For animation support,  use the new interface with explicit state management.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/plot_flowfield.jl#L355-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.plot_flow_field" href="#FLORIDyn.plot_flow_field"><code>FLORIDyn.plot_flow_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_flow_field(wf, X, Y, Z, vis; msr=VelReduction, plt=nothing) -&gt; Nothing</code></pre><p>High-level plotting function that automatically dispatches to either parallel or  sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>wf</code>: WindFarm object</li><li><code>X</code>, <code>Y</code>, <code>Z</code>: Flow field coordinate arrays</li><li><code>vis</code>: Visualization settings</li><li><code>msr</code>: Measurement type, see: <a href="../types/#FLORIDyn.MSR">MSR</a></li><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/smart_plotting.jl#L4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.plotMeasurements" href="#FLORIDyn.plotMeasurements"><code>FLORIDyn.plotMeasurements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plotMeasurements(plt, wf::WindFarm, md::DataFrame, vis::Vis; separated=false, msr=VelReduction) -&gt; Nothing</code></pre><p>Plot foreign reduction measurements from FLORIDyn simulation data.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Plotting package (e.g., PyPlot, which is exported from ControlPlots)</li><li><code>wf::WindFarm</code>: Wind farm object with field <code>nT</code> (number of turbines). See <a href="../types/#FLORIDyn.WindFarm"><code>WindFarm</code></a></li><li><code>md::DataFrame</code>: Measurements DataFrame containing time series data with columns:<ul><li><code>Time</code>: Simulation time [s]</li><li><code>ForeignReduction</code>: Foreign reduction  [%]</li></ul></li><li><code>vis::Vis</code>: Visualization settings including unit_test parameter. See <a href="../settings/#FLORIDyn.Vis"><code>Vis</code></a></li><li><code>separated::Bool</code>: Whether to use separated subplot layout (default: false)</li><li><code>msr::MSR</code>: Measurement type to plot, see: <a href="../types/#FLORIDyn.MSR">MSR</a> </li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Description</strong></p><p>This function creates time series plots of foreign reduction measurements from FLORIDyn simulations. It handles:</p><ol><li>Time normalization by subtracting the start time</li><li>Foreign reduction plots in either separated (subplot) or combined layout</li><li>Different measurement types based on the <code>msr</code> parameter</li></ol><p><strong>Plotting Modes</strong></p><ul><li><strong>Separated mode</strong> (<code>separated=true</code>): Creates individual subplots for each turbine</li><li><strong>Combined mode</strong> (<code>separated=false</code>): Plots all turbines on a single figure with different colors</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ControlPlots

# Plot velocity reduction for all turbines in combined mode
plotMeasurements(plt, wind_farm, measurements_df, vis; msr=VelReduction)

# Plot added turbulence with separated subplots
plotMeasurements(plt, wind_farm, measurements_df, vis; separated=true, msr=AddedTurbulence)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.plotFlowField"><code>plotFlowField</code></a>: For flow field visualization</li><li><a href="#FLORIDyn.getMeasurements"><code>getMeasurements</code></a>: For generating measurement data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/plot_measurements.jl#L4-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.plot_measurements" href="#FLORIDyn.plot_measurements"><code>FLORIDyn.plot_measurements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_measurements(wf, md, vis; separated=true, msr=VelReduction, plt=nothing) -&gt; Nothing</code></pre><p>High-level measurements plotting function that automatically dispatches to either  parallel or sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>wf</code>: WindFarm object</li><li><code>md</code>: Measurement data</li><li><code>vis</code>: Visualization settings</li><li><code>separated</code>: Whether to use separated subplots</li><li><code>msr</code>: Measurement type, see: <a href="../types/#FLORIDyn.MSR">MSR</a> </li><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.plotMeasurements"><code>plotMeasurements</code></a>: The underlying plotting function used in sequential mode</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/smart_plotting.jl#L34-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.close_all" href="#FLORIDyn.close_all"><code>FLORIDyn.close_all</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">close_all(plt)</code></pre><p>Close all matplotlib figure windows.</p><p>This function automatically dispatches to either parallel or sequential plotting based on the number of available threads and processes.</p><p><strong>Arguments</strong></p><ul><li><code>plt</code>: Matplotlib PyPlot instance (only used in sequential mode)</li></ul><p><strong>Description</strong></p><p>When running with multiple threads and processes, it uses remote plotting  capabilities to close all figures on the remote worker. Otherwise, it directly calls <code>plt.close(&quot;all&quot;)</code> to close all figures in the current process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/smart_plotting.jl#L68-L83">source</a></section></article><h1 id="Video-Creation"><a class="docs-heading-anchor" href="#Video-Creation">Video Creation</a><a id="Video-Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Video-Creation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.cleanup_video_folder" href="#FLORIDyn.cleanup_video_folder"><code>FLORIDyn.cleanup_video_folder</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cleanup_video_folder() -&gt; Nothing</code></pre><p>Clean up existing PNG files in the video folder before creating new videos.</p><p><strong>Description</strong></p><p>This function removes all PNG files from the &quot;video&quot; directory to ensure a clean slate  before generating new video frames. It is typically called before running simulations  that create video output to prevent mixing old frames with new ones.</p><p><strong>Behavior</strong></p><ul><li>Checks if the &quot;video&quot; directory exists</li><li>Scans the directory for files with &quot;.png&quot; extension</li><li>Attempts to delete each PNG file found</li><li>Reports the number of files deleted</li><li>Issues warnings for any files that cannot be deleted</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Clean up before creating new video frames
cleanup_video_folder()

# Run simulation that generates PNG frames
# ...

# Create video from frames
createVideo()</code></pre><p><strong>See Also</strong></p><ul><li><a href="#FLORIDyn.createVideo"><code>createVideo</code></a>: Create MP4 video from PNG frames</li><li><a href="#FLORIDyn.createAllVideos"><code>createAllVideos</code></a>: Create videos for all measurement types</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/plot_flowfield.jl#L386-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.createVideo" href="#FLORIDyn.createVideo"><code>FLORIDyn.createVideo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createVideo(prefix::String; video_dir=&quot;video&quot;, output_dir=&quot;video&quot;, fps=2, delete_frames=false)</code></pre><p>Convert PNG files in a directory starting with a given prefix into an MP4 video.</p><p><strong>Arguments</strong></p><ul><li><code>prefix::String</code>: The prefix string that PNG files must start with (e.g., &quot;velocity<em>reduction&quot;, &quot;wind</em>speed&quot;)</li><li><code>video_dir::String</code>: Directory containing the PNG files (default: &quot;video&quot;)</li><li><code>output_dir::String</code>: Directory where the output video will be saved (default: &quot;video&quot;)</li><li><code>fps::Int</code>: Frames per second for the output video (default: 2)</li><li><code>delete_frames::Bool</code>: Whether to delete the PNG files after creating the video (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the created video file, or empty string if creation failed</li></ul><p><strong>Description</strong></p><p>This function searches for PNG files in the specified directory that start with the given prefix, sorts them naturally (handling numeric sequences correctly), and combines them into an MP4 video using FFmpeg. The function requires FFmpeg to be installed on the system.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create video from velocity reduction frames
video_path = createVideo(&quot;velocity_reduction&quot;; fps=4)

# Create video from wind speed frames and delete source frames
video_path = createVideo(&quot;wind_speed&quot;; fps=6, delete_frames=true)

# Create video from custom directory
video_path = createVideo(&quot;added_turbulence&quot;; video_dir=&quot;custom_plots&quot;, output_dir=&quot;videos&quot;)</code></pre><p><strong>Requirements</strong></p><ul><li>FFmpeg must be installed and available in the system PATH</li><li>PNG files should follow a consistent naming pattern with the prefix</li><li>Recommended naming: &quot;prefix<em>t0000s.png&quot;, &quot;prefix</em>t0012s.png&quot;, etc.</li></ul><p><strong>Notes</strong></p><ul><li>Files are sorted naturally to handle numeric sequences correctly (e.g., t0001s, t0010s, t0100s)</li><li>The output video filename will be &quot;prefix_animation.mp4&quot;</li><li>If no matching files are found, the function returns an empty string</li><li>FFmpeg parameters are optimized for good quality and reasonable file size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/create_video.jl#L6-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.createAllVideos" href="#FLORIDyn.createAllVideos"><code>FLORIDyn.createAllVideos</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createAllVideos(; video_dir=&quot;video&quot;, output_dir=&quot;video&quot;, fps=2, delete_frames=false)</code></pre><p>Create videos for all common measurement types found in the video directory.</p><p><strong>Arguments</strong></p><ul><li><code>video_dir::String</code>: Directory containing the PNG files (default: &quot;video&quot;)</li><li><code>output_dir::String</code>: Directory where output videos will be saved (default: &quot;video&quot;)</li><li><code>fps::Int</code>: Frames per second for output videos (default: 2)</li><li><code>delete_frames::Bool</code>: Whether to delete PNG files after creating videos (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Paths to created video files</li></ul><p><strong>Description</strong></p><p>This convenience function automatically detects common measurement type prefixes in the video directory and creates videos for each type found. It looks for the following prefixes:</p><ul><li>&quot;velocity_reduction&quot;</li><li>&quot;added_turbulence&quot; </li><li>&quot;wind_speed&quot;</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create videos for all measurement types found
video_paths = createAllVideos(fps=4, delete_frames=true)
println(&quot;Created videos: &quot;, video_paths)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/create_video.jl#L244-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FLORIDyn.natural_sort_key" href="#FLORIDyn.natural_sort_key"><code>FLORIDyn.natural_sort_key</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">natural_sort_key(filename::String)</code></pre><p>Generate a sort key for natural sorting of filenames containing numbers.</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: The filename to generate a sort key for</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Sort key that handles numeric sequences naturally</li></ul><p><strong>Description</strong></p><p>This function creates a sort key that handles numeric sequences in filenames correctly. For example, it will sort [&quot;file1.png&quot;, &quot;file10.png&quot;, &quot;file2.png&quot;] as  [&quot;file1.png&quot;, &quot;file2.png&quot;, &quot;file10.png&quot;] rather than alphabetically.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">files = [&quot;velocity_reduction_t0001s.png&quot;, &quot;velocity_reduction_t0010s.png&quot;, &quot;velocity_reduction_t0002s.png&quot;]
sorted_files = sort(files, by=natural_sort_key)
# Result: [&quot;velocity_reduction_t0001s.png&quot;, &quot;velocity_reduction_t0002s.png&quot;, &quot;velocity_reduction_t0010s.png&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ufechner7/FLORIDyn.jl/blob/59594aeab98fc67af3f03cab27ac4850b570173c/src/visualisation/create_video.jl#L175-L197">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions/">« Low-Level Functions</a><a class="docs-footer-nextpage" href="../settings/">Settings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 11 August 2025 09:58">Monday 11 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
